"use strict";(self.webpackChunkpike_cookbook=self.webpackChunkpike_cookbook||[]).push([[837],{32(n,e,a){a.r(e),a.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>t,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"basics/hashes","title":"Hashes","description":"Introduction","source":"@site/docs/basics/hashes.md","sourceDirName":"basics","slug":"/basics/hashes","permalink":"/pike-cookbook/docs/basics/hashes","draft":false,"unlisted":false,"editUrl":"https://github.com/smuks/pike-cookbook/tree/main/docs/basics/hashes.md","tags":[],"version":"current","frontMatter":{"id":"hashes","title":"Hashes","sidebar_label":"Hashes"},"sidebar":"tutorialSidebar","previous":{"title":"Arrays","permalink":"/pike-cookbook/docs/basics/arrays"},"next":{"title":"Dates and Times","permalink":"/pike-cookbook/docs/basics/dates"}}');var s=a(4848),r=a(8453);const t={id:"hashes",title:"Hashes",sidebar_label:"Hashes"},o=void 0,l={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Adding an Element to a Hash",id:"adding-an-element-to-a-hash",level:2},{value:"Testing for the Presence of a Key in a Hash",id:"testing-for-the-presence-of-a-key-in-a-hash",level:2},{value:"Deleting from a Hash",id:"deleting-from-a-hash",level:2},{value:"Traversing a Hash",id:"traversing-a-hash",level:2},{value:"Printing a Hash",id:"printing-a-hash",level:2},{value:"Retrieving from a Hash in Insertion Order",id:"retrieving-from-a-hash-in-insertion-order",level:2},{value:"Hashes with Multiple Values Per Key",id:"hashes-with-multiple-values-per-key",level:2},{value:"Inverting a Hash",id:"inverting-a-hash",level:2},{value:"Sorting a Hash",id:"sorting-a-hash",level:2},{value:"Merging Hashes",id:"merging-hashes",level:2},{value:"Finding Common or Different Keys in Two Hashes",id:"finding-common-or-different-keys-in-two-hashes",level:2},{value:"Hashing References",id:"hashing-references",level:2},{value:"Presizing a Hash",id:"presizing-a-hash",level:2},{value:"Finding the Most Common Anything",id:"finding-the-most-common-anything",level:2},{value:"Representing Relationships Between Data",id:"representing-relationships-between-data",level:2},{value:"Program: dutree",id:"program-dutree",level:2},{value:"Modern Mapping Operations in Pike 8",id:"modern-mapping-operations-in-pike-8",level:2},{value:"Mapping.pmod Utilities",id:"mappingpmod-utilities",level:2},{value:"Safe Indexing with -&gt;?",id:"safe-indexing-with--",level:2},{value:"Advanced Hash Patterns",id:"advanced-hash-patterns",level:2}];function g(n){const e={code:"code",h2:"h2",pre:"pre",...(0,r.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-pike",children:'// creating a mapping from arrays\nmapping age = mkmapping( ({ "Nat", "Jules", "Josh", }), ({ 24, 25, 17 }) );\n\n// initialize one index at a time\nmapping age = ([]);\nage["Nat"] = 24;\nage["Jules"] = 25;\nage["Josh"] = 17;\n\n// if your index names are valid identifiers:\nage->Nat = 24;\nage->Jules = 25;\nage->Josh = 17;\n\n// the traditional way to initialize mappings\nmapping age = ([ "Nat":24, "Jules":25, "Josh":17 ]);\n\nmapping(string:string) food_color = ([\n                                      "Apple":"red",\n                                      "Banana":"yellow",\n                                      "Lemon":"yellow",\n                                      "Carrot":"orange"\n                                     ]);\n\n// a index may be of any type\nmapping any = ([ "1":"a string", 1:"an int", 1.0:"a float" ]);\n\n// you may use other types too, but be aware that they are matched by\n// reference, and not by value.\n'})}),"\n",(0,s.jsx)(e.h2,{id:"adding-an-element-to-a-hash",children:"Adding an Element to a Hash"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-pike",children:'// simplest way to add an element to a mapping:\nmapping age = ([ "Nat":24 ]);\nage["Jules"] = 25;\nage->Josh = 17;\n\n// you can also use the assign function:\nmapping new_age = age + ([ "Steve":35 ]);\n\n// m_add() is deprecated\n// in Pike 7.7+ use the + operator\n'})}),"\n",(0,s.jsx)(e.h2,{id:"testing-for-the-presence-of-a-key-in-a-hash",children:"Testing for the Presence of a Key in a Hash"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-pike",children:'// an undefined value in a mapping gets turned to 0.\n// assigning 0 as a value is allowed and will not remove the index.\n// checking for the index will of course return 0 and be interpreted as false.\n// to check if the index is really there, use zero_type()\n\nif(!zero_type(mapping->index))\n{\n  // it exists\n}\nelse\n{\n  // it doesn\'t\n}\n\n// food_color as per section 5.0\nforeach( ({ "Banana", "Milk" }) ;; string name)\n{\n  if(!zero_type(food_color[name]))\n    write("%s is a food.\\n", name);\n  else\n    write("%s is a drink.\\n", name);\n}\n// Banana is a food.\n// Milk is a drink.\n\n// ---------------------------------------------------------\nmapping age = ([ "Toddler":3,\n                 "Unborn":0,\n                 "Newborn":0.0,\n                 "Phantasm":UNDEFINED ]);\n\nforeach( ({ "Toddler", "Unborn", "Newborn", "Phantasm", "Relic"});; string thing)\n{\n    write(thing+":");\n    if(!zero_type(age[thing]))\n      write(" Exists");\n    if(age[thing])\n      write(" True");\n    write("\\n");\n}\n// Toddler: Exists True\n// Unborn: Exists\n// Newborn: Exists True\n// Phantasm: Exists\n// Relic:\n\n// age->Toddler exists, because zero_type() is only true if the index is not in\n// the mapping. it is true because the value is not 0.\n// age->Unborn exists, but is false because 0 is false\n// age->Newborn exists and is true, because 0.0 is not false\n// age->Phantasm exists and is false, like Unborn\n// age->Relic does not exist\n\n// we can not test for defined. UNDEFINED is a special value used internally by\n// the compiler. it gets converted to 0 as soon as it is assigned in a mapping\n\n// however we can create something equivalent that can be treated like any\n// other value, except that it is false:\n\nclass Nil\n{\n  // this is a minimal example.\n  // a more complete one would also handle casting\n\n  int `!() {return 1;}\n  string _sprintf() {return "Nil";}\n\n  // we could have this function externally, but this is more convenient\n  int defined(mixed var)\n  {\n    return !zero_type(var) && var!=this;\n  }\n}\n\nNil NIL = Nil();                    // create an instance so we can use it\nfunction defined = NIL->defined;  // just for symetry\n\nmapping age = ([ "Toddler":3,\n                 "Unborn":0,\n                 "Phantasm":NIL ]);\n'})}),"\n",(0,s.jsx)(e.h2,{id:"deleting-from-a-hash",children:"Deleting from a Hash"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-pike",children:'// users occasionally may get the idea that mapping[index]=0; may remove index\n// from mapping. the normal way to remove a index from a mapping is to\n// subtract: mapping -= ([ index:0 ]); the following shall demonstrate the\n// difference between subtracting a index and assigning 0 to it.\n\n// food_color as per section 5.0\nvoid print_foods()\n{\n  write("Foods:%{ %s%}\\n", indices(food_color));\n  write("Values: ");\n\n  foreach(food_color; string food; string color)\n  {\n    if(color)\n      write(color+" ");\n    else\n      write("(no value) ");\n  }\n  write("\\n");\n}\n\nwrite("Initially:\\n");\nprint_foods();\n\nwrite("\\nWith Banana set to 0\\n");\nfood_color->Banana = 0;\nprint_foods();\n\nwrite("\\nWith Banana deleted\\n");\nfood_color -= ([ "Banana":"the value is irrelevant" ]);\nprint_foods();\n\n// Initially:\n// Foods: Lemon Banana Apple Carrot\n// Values: yellow yellow red orange\n//\n// With Banana set to 0\n// Foods: Banana Lemon Apple Carrot\n// Values: (no value) yellow red orange\n//\n// With Banana deleted\n// Foods: Lemon Carrot Apple\n// Values: yellow orange red\n\n// you can also subtract multiple indices:\nfood_color -= ([ "Banana":0, "Apple":0, "Cabbage":0 ]);\n\n// note that subtracting a mapping from another creates a new mapping.\n// thus any references you have to a mapping will be broken.\n// in most cases this is what you want anyways. if it is not, you can also\n// remove indices using m_delete();\n\nm_delete(food_color, "Banana");\n'})}),"\n",(0,s.jsx)(e.h2,{id:"traversing-a-hash",children:"Traversing a Hash"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-pike",children:'foreach( mapping; type index; type value)\n{\n  //do something with index and value\n}\n\n// food_color as per 5.0\nforeach(food_color; string food; string color)\n{\n  write("%s is %s.\\n", food, color);\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"printing-a-hash",children:"Printing a Hash"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-pike",children:'// since mappings are not ordered, printing them directly can result in\n// seemingly random output:\n\nmapping age = ([ "Nat":24, "Jules":25, "Josh":17 ]);\nwrite(age); // ([ "Josh":17, "Jules":25, "Nat":24 ])\n\n// to get consistent output you can sort the indices:\nwrite(sprintf("%{ %s:%s%}", sort(indices(age))..., age));\n\n// if you want a specific order, you can specify it:\nwrite("Nat:%d, Jules:%d, Josh:%d\\n", age->Nat, age->Jules, age->Josh);\n\n// or\narray(string) names = ({ "Nat", "Jules", "Josh" });\nforeach(names; int i; string name)\n  write("%s:%d\\n", name, age[name]);\n\n// this will always print:\n// Nat:24\n// Jules:25\n// Josh:17\n\n// for food_color, which maps to another string, you could write:\nforeach(food_color; string food; string color)\n  write("%s: %s\\n", food, color);\n'})}),"\n",(0,s.jsx)(e.h2,{id:"retrieving-from-a-hash-in-insertion-order",children:"Retrieving from a Hash in Insertion Order"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-pike",children:'// Pike mappings do not preserve insertion order, but you can simulate it by\n// keeping a separate array of keys in the order you want:\n\nmapping(string:string) food_color = ([]);\narray(string) insertion_order = ({});\n\nvoid add_food(string food, string color)\n{\n  food_color[food] = color;\n  insertion_order += ({ food });\n}\n\n// now you can retrieve in insertion order:\nforeach(insertion_order; string food)\n  write("%s: %s\\n", food, food_color[food]);\n'})}),"\n",(0,s.jsx)(e.h2,{id:"hashes-with-multiple-values-per-key",children:"Hashes with Multiple Values Per Key"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-pike",children:"// there are several ways to handle multiple values per key:\n\n// 1. using arrays as values\nmapping(string:array(int)) ages = ([]);\n\nvoid add_age(string name, int age)\n{\n  if(!ages[name]) ages[name] = ({});\n  ages[name] += ({ age });\n}\n\n// 2. using a multiset\nmapping(string:multiset(int)) age_set = ([]);\n\nvoid add_age(string name, int age)\n{\n  if(!age_set[name]) age_set[name] = (< >);\n  age_set[name][age] = 1;\n}\n\n// 3. using a custom class\nclass AgeList\n{\n  array(int) ages = ({});\n\n  void add(int age) { ages += ({ age }); }\n  array(int) get() { return ages; }\n}\n\nmapping(string:AgeList) age_lists = ([]);\n\nvoid add_age(string name, int age)\n{\n  if(!age_lists[name]) age_lists[name] = AgeList();\n  age_lists[name]->add(age);\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"inverting-a-hash",children:"Inverting a Hash"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-pike",children:'// to invert a hash (swap keys and values):\nmapping(string:string) food_color = ([\n  "Apple":"red", "Banana":"yellow",\n  "Lemon":"yellow", "Carrot":"orange"\n]);\n\nmapping(string:array(string)) color_foods = ([]);\n\nforeach(food_color; string food; string color)\n{\n  if(!color_foods[color]) color_foods[color] = ({});\n  color_foods[color] += ({ food });\n}\n\n// resulting structure:\n// ([ "red":({ "Apple" }), "yellow":({ "Banana", "Lemon" }),\n//    "orange":({ "Carrot" }) ])\n\n// for one-to-one mappings, you can use:\nmapping inverted = mkmapping(values(food_color), indices(food_color));\n'})}),"\n",(0,s.jsx)(e.h2,{id:"sorting-a-hash",children:"Sorting a Hash"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-pike",children:'// to get the keys of a hash sorted:\nmapping age = ([ "Nat":24, "Jules":25, "Josh":17 ]);\narray(string) sorted_names = sort(indices(age));\n\n// to sort by values:\narray(int) sorted_ages = sort(values(age));\n\n// to sort by keys with custom comparison:\narray(string) names = ({ "Josh", "Nat", "Jules" });\nsorted_names = sort(names, lambda(string a, string b) {\n  return sizeof(a) - sizeof(b);\n});\n\n// to sort the entire mapping by keys:\nmapping sorted_by_key = ([]);\nforeach(sort(indices(age)), string name)\n  sorted_by_key[name] = age[name];\n\n// to sort by values (descending):\nmapping sorted_by_value = ([]);\narray(int) ages = sort(values(age));\nforeach(reverse(ages), int age) {\n  foreach(age; string name; int value)\n    if(value == age)\n      sorted_by_value[name] = age;\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"merging-hashes",children:"Merging Hashes"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-pike",children:'// in Pike 7.7+ you can use the + operator:\nmapping age1 = ([ "Nat":24, "Jules":25 ]);\nmapping age2 = ([ "Josh":17, "Steve":35 ]);\nmapping combined = age1 + age2;\n\n// duplicate keys will take the value from the second mapping\n// values from age2 will overwrite values from age1\n\n// to merge without overwriting, you can:\nmapping merge_safe = ([]);\nforeach(age1; string key; mixed val)\n  merge_safe[key] = val;\nforeach(age2; string key; mixed val)\n  if(!merge_safe[key])\n    merge_safe[key] = val;\n\n// for Pike 7.6 and earlier, use:\nmapping combined = age1 + ([ "Josh":17, "Steve":35 ]);\n'})}),"\n",(0,s.jsx)(e.h2,{id:"finding-common-or-different-keys-in-two-hashes",children:"Finding Common or Different Keys in Two Hashes"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-pike",children:'mapping age1 = ([ "Nat":24, "Jules":25, "Josh":17 ]);\nmapping age2 = ([ "Jules":26, "Steve":35, "Josh":17 ]);\n\n// common keys:\narray(string) common = intersect(indices(age1), indices(age2));\n\n// keys only in first mapping:\narray(string) only_in_first = difference(indices(age1), indices(age2));\n\n// keys only in second mapping:\narray(string) only_in_second = difference(indices(age2), indices(age1));\n\n// symmetric difference (keys in either but not both):\narray(string) unique = symmetric_difference(indices(age1), indices(age2));\n\n// to get key-value pairs from both mappings:\nmapping both = ([]);\nforeach(common; string key)\n  both[key] = ({ age1[key], age2[key] });\n\n// where both[key] = ({ value_from_age1, value_from_age2 })\n'})}),"\n",(0,s.jsx)(e.h2,{id:"hashing-references",children:"Hashing References"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-pike",children:'// in Pike, hash keys are compared by reference, not by value:\nclass Person\n{\n  string name;\n  void create(string n) { name = n; }\n}\n\nPerson p1 = Person("Alice");\nPerson p2 = Person("Alice");\n\nmapping people = ([ p1:"found", p2:"not found" ]);\n// both entries exist because p1 and p2 are different objects\n\n// to use value-based comparison, create a custom hash:\nclass PersonHash\n{\n  inherit Stdio.HashTable;\n\n  int key(object p) { return p->hash(); }\n\n  int equal(object a, object b)\n  {\n    return a->name == b->name;\n  }\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"presizing-a-hash",children:"Presizing a Hash"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-pike",children:"// mappings in Pike auto-grow as needed, but you can preallocate:\nmapping age = allocate_mapping(100);\n\n// or for a more precise estimate:\nmapping age = ([]);\nif(sizeof(keys) > 0)\n  age = allocate_mapping(sizeof(keys));\n\n// the estimated size helps optimize memory usage for large mappings\n"})}),"\n",(0,s.jsx)(e.h2,{id:"finding-the-most-common-anything",children:"Finding the Most Common Anything"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-pike",children:'// to find the most common item in an array:\narray(string) items = ({ "a", "b", "a", "c", "b", "a" });\nmapping count = ([]);\n\nforeach(items; string item)\n  count[item]++;\n\nstring most_common = indices(count)[0];\nforeach(count; string item; int cnt)\n  if(cnt > count[most_common])\n    most_common = item;\n\n// more concise version:\nmapping counts = aggregate_mapping(@(array(int))mapping_create(@items), 0);\ncounts++;\nstring most_common = max(@indices(counts), lambda(string a, string b) {\n  return counts[a] - counts[b];\n});\n'})}),"\n",(0,s.jsx)(e.h2,{id:"representing-relationships-between-data",children:"Representing Relationships Between Data"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-pike",children:"// using mappings to represent relationships:\nmapping(string:array(string)) friends = ([]);\n\nvoid add_friend(string person, string friend)\n{\n  if(!friends[person]) friends[person] = ({});\n  if(!friends[friend]) friends[friend] = ({});\n\n  if(!has_value(friends[person], friend))\n    friends[person] += ({ friend });\n  if(!has_value(friends[friend], person))\n    friends[friend] += ({ person });\n}\n\n// checking relationships:\nbool are_friends(string a, string b)\n{\n  return friends[a] && has_value(friends[a], b);\n}\n\n// friend of a friend:\narray(string) friends_of_friends(string person)\n{\n  array(string) result = ({});\n  foreach(friends[person] || ({}); string friend)\n    foreach(friends[friend] || ({}); string fof)\n      if(fof != person && !has_value(friends[person], fof))\n        result += ({ fof });\n  return result;\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"program-dutree",children:"Program: dutree"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-pike",children:'// dutree - directory tree analyzer\n// usage: pike dutree.pike [directory]\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <dirent.h>\n#include <sys/stat.h>\n\nmapping file_stats = ([]);\n\nvoid scan_directory(string dir, int level)\n{\n  DIR *d;\n  struct dirent *entry;\n  struct stat st;\n\n  if(!(d = opendir(dir)))\n    return;\n\n  while((entry = readdir(d)))\n  {\n    if(entry->d_name[0] == \'.\') continue;\n\n    string path = dir + "/" + entry->d_name;\n    if(lstat(path, &st))\n      continue;\n\n    if(S_ISDIR(st.st_mode))\n    {\n      printf("%*s%s/\\n", level * 2, "", entry->d_name);\n      scan_directory(path, level + 1);\n    }\n    else\n    {\n      printf("%*s%s\\n", level * 2, "", entry->d_name);\n      file_stats[path] = st.st_size;\n    }\n  }\n\n  closedir(d);\n}\n\nint main(int argc, string|array argv)\n{\n  string dir = argc > 1 ? argv[1] : ".";\n  printf("Directory tree for %s:\\n", dir);\n  scan_directory(dir, 0);\n\n  if(sizeof(file_stats))\n  {\n    int total = aggregate(@values(file_stats));\n    printf("\\nTotal files: %d\\n", sizeof(file_stats));\n    printf("Total size: %d bytes\\n", total);\n  }\n\n  return 0;\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"modern-mapping-operations-in-pike-8",children:"Modern Mapping Operations in Pike 8"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-pike",children:'// Pike 8 introduces more mapping operations:\n\n// filter() - create new mapping with filtered key-value pairs\nmapping age = ([ "Nat":24, "Jules":25, "Josh":17 ]);\nmapping adults = filter(age, lambda(string name, int age) { return age >= 18; });\n\n// map() - transform values\nmapping age_doubled = map(age, lambda(int age) { return age * 2; });\n\n// reduce() - reduce values to single value\nint sum_age = reduce(values(age), lambda(int a, int b) { return a + b; });\n\n// any() and all() - check conditions\nbool has_adult = any(age, lambda(int age) { return age >= 18; });\nbool all_adult = all(age, lambda(int age) { return age >= 18; });\n\n// unzip() - split mapping into two arrays\narray(array) split = unzip(age);\n// split[0] is keys, split[1] is values\n'})}),"\n",(0,s.jsx)(e.h2,{id:"mappingpmod-utilities",children:"Mapping.pmod Utilities"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-pike",children:'// the Mapping.pmod module provides many utilities:\n\n#include <Mapping.pmod>\n\n// merge_mappings() - merge multiple mappings\nmapping m1 = ([ "a":1, "b":2 ]);\nmapping m2 = ([ "c":3, "d":4 ]);\nmapping merged = Mapping()->merge_mappings(m1, m2);\n\n// filter_mapping() - filter by key or value\nmapping filtered = Mapping()->filter_mapping(age, lambda(int age) { return age > 20; });\n\n// mapping_search() - find key by value\nstring name = Mapping()->mapping_search(age, 24); // returns "Nat"\n\n// invert_mapping() - simple inversion\nmapping inverted = Mapping()->invert_mapping(food_color);\n'})}),"\n",(0,s.jsx)(e.h2,{id:"safe-indexing-with--",children:"Safe Indexing with ->?"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-pike",children:'// Pike 8 introduces safe indexing operator ->?\nmapping age = ([ "Nat":24, "Jules":25 ]);\n\n// safe access - returns UNDEFINED if key doesn\'t exist\nint nat_age = age->?"Nat"; // 24\nint josh_age = age->?"Josh"; // UNDEFINED\n\n// safe nested access\nmapping nested = ([ "user": ([ "name": "Alice", "age": 25 ]) ]);\nstring name = nested->?"user"->?"name"; // "Alice"\nstring email = nested->?"user"->?"email"; // UNDEFINED\n\n// conditional chaining\nint user_age = nested->?"user" && nested->user->?"age"; // 25\n'})}),"\n",(0,s.jsx)(e.h2,{id:"advanced-hash-patterns",children:"Advanced Hash Patterns"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-pike",children:'// memoization pattern:\nclass Memoizer\n{\n  mapping cache = ([]);\n\n  mixed execute(function f, mixed ... args)\n  {\n    string key = sprintf("%O", args);\n    if(cache[key]) return cache[key];\n\n    mixed result = f(@args);\n    cache[key] = result;\n    return result;\n  }\n}\n\n// cache decorator:\nfunction cache_results(function f)\n{\n  mapping cache = ([]);\n  return lambda(mixed ... args) {\n    string key = sprintf("%O", args);\n    if(cache[key]) return cache[key];\n    return cache[key] = f(@args);\n  };\n}\n\n// singleton pattern:\nclass Singleton\n{\n  static private Singleton instance;\n  private void create() {}\n\n  static Singleton get()\n  {\n    if(!instance) instance = Singleton();\n    return instance;\n  }\n}\n\n// observer pattern:\nclass Observable\n{\n  mapping observers = ([]);\n\n  void add_observer(string event, function callback)\n  {\n    if(!observers[event]) observers[event] = ({});\n    observers[event] += ({ callback });\n  }\n\n  void notify(string event, mixed ... data)\n  {\n    if(observers[event])\n      foreach(observers[event]; function cb)\n        cb(@data);\n  }\n}\n'})})]})}function c(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(g,{...n})}):g(n)}},8453(n,e,a){a.d(e,{R:()=>t,x:()=>o});var i=a(6540);const s={},r=i.createContext(s);function t(n){const e=i.useContext(r);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:t(n.components),i.createElement(r.Provider,{value:e},n.children)}}}]);