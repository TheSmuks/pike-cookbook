"use strict";(self.webpackChunkpike_cookbook=self.webpackChunkpike_cookbook||[]).push([[688],{8003(n,e,t){t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>r,toc:()=>g});const r=JSON.parse('{"id":"network/cgi-programming","title":"CGI Programming","description":"19. CGI Programming","source":"@site/docs/network/cgi-programming.md","sourceDirName":"network","slug":"/network/cgi-programming","permalink":"/pike-cookbook/docs/network/cgi-programming","draft":false,"unlisted":false,"editUrl":"https://github.com/smuks/pike-cookbook/tree/main/docs/network/cgi-programming.md","tags":[],"version":"current","frontMatter":{"id":"cgi-programming","title":"CGI Programming","sidebar_label":"CGI Programming"},"sidebar":"tutorialSidebar","previous":{"title":"Database Access","permalink":"/pike-cookbook/docs/files/database-access"},"next":{"title":"Sockets","permalink":"/pike-cookbook/docs/network/sockets"}}');var i=t(4848),s=t(8453);const a={id:"cgi-programming",title:"CGI Programming",sidebar_label:"CGI Programming"},o=void 0,l={},g=[{value:"19. CGI Programming",id:"19-cgi-programming",level:2},{value:"Introduction to CGI Programming",id:"introduction-to-cgi-programming",level:3},{value:"Writing a CGI Script",id:"writing-a-cgi-script",level:3},{value:"Redirecting Error Messages",id:"redirecting-error-messages",level:3},{value:"Fixing a 500 Server Error",id:"fixing-a-500-server-error",level:3},{value:"Writing a Safe CGI Program",id:"writing-a-safe-cgi-program",level:3},{value:"Making CGI Scripts Efficient",id:"making-cgi-scripts-efficient",level:3},{value:"Executing Commands Without Shell Escapes",id:"executing-commands-without-shell-escapes",level:3},{value:"Formatting Lists and Tables with HTML Shortcuts",id:"formatting-lists-and-tables-with-html-shortcuts",level:3},{value:"Redirecting to a Different Location",id:"redirecting-to-a-different-location",level:3},{value:"Debugging the Raw HTTP Exchange",id:"debugging-the-raw-http-exchange",level:3},{value:"Managing Cookies",id:"managing-cookies",level:3},{value:"Creating Sticky Widgets",id:"creating-sticky-widgets",level:3},{value:"Writing a Multiscreen CGI Script",id:"writing-a-multiscreen-cgi-script",level:3},{value:"Saving a Form to a File or Mail Pipe",id:"saving-a-form-to-a-file-or-mail-pipe",level:3},{value:"Program: chemiserie",id:"program-chemiserie",level:3}];function d(n){const e={code:"code",h2:"h2",h3:"h3",pre:"pre",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{id:"19-cgi-programming",children:"19. CGI Programming"}),"\n",(0,i.jsx)(e.h3,{id:"introduction-to-cgi-programming",children:"Introduction to CGI Programming"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'CGI (Common Gateway Interface) allows web servers to execute programs\nand display their output. Pike provides built-in CGI support through\nvarious modules including Protocols.HTTP and CGI.\nEnvironment variables available in CGI:\nREQUEST_METHOD, QUERY_STRING, CONTENT_TYPE, CONTENT_LENGTH\nSCRIPT_NAME, PATH_INFO, PATH_TRANSLATED, SERVER_NAME, SERVER_PORT\nHTTP_USER_AGENT, HTTP_REFERER, HTTP_COOKIE, REMOTE_ADDR, etc.\nimport Standards.JSON;\nDisplay all CGI environment variables\nvoid show_env_vars() {\nwrite("Content-Type: text/html\\r\\n\\r\\n");\nwrite("\\n");\nwrite("CGI Environment\\n");\nwrite("CGI Environment Variables\\n");\nwrite("\\n");\nforeach(getenv(); string key; string value) {\nwrite("%s%s\\n",\nkey, value);\n}\nwrite("\\n");\n}\nSimple JSON endpoint\nvoid json_endpoint() {\nmapping(string:string) data = ([\n"method": getenv("REQUEST_METHOD") || "UNKNOWN",\n"query": getenv("QUERY_STRING") || "",\n"user_agent": getenv("HTTP_USER_AGENT") || "Unknown",\n"remote_addr": getenv("REMOTE_ADDR") || "Unknown"\n]);\nstring json = Standards.JSON.encode(data);\nwrite("Content-Type: application/json\\r\\n");\nwrite("Access-Control-Allow-Origin: *\\r\\n");\nwrite("\\r\\n");\nwrite(json);\n}\nMain entry point - determine response type based on Accept header\nvoid main() {\nstring accept = getenv("HTTP_ACCEPT") || "";\nif (has_prefix(accept, "application/json")) {\njson_endpoint();\n} else {\nshow_env_vars();\n}\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"writing-a-cgi-script",children:"Writing a CGI Script"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'#pragma strict_types\n#pragma no_clone\nA complete CGI script that handles GET and POST requests\nimport Protocols.HTTP;\nURL decoding function\nstring url_decode(string s) {\nreturn replace(replace(replace(s, "+", " "),\n"%20", " "),\n"\\\\\\\\", "\\");\n}\nURL encoding function\nstring url_encode(string s) {\nreturn Protocols.HTTP.http_encode_url(s);\n}\nParse query string or POST data into a mapping\nmapping(string:string) parse_form_data() {\nmapping(string:string) form = ([]);\nstring data;\nstring method = getenv("REQUEST_METHOD") || "GET";\nif (method == "GET") {\ndata = getenv("QUERY_STRING") || "";\n} else if (method == "POST") {\nint length = (int)(getenv("CONTENT_LENGTH") || "0");\nif (length > 0 && length ", ">"),\n"\\"", """);\n}\nSend HTTP headers\nvoid send_headers(string|void content_type, int|void status) {\nif (!content_type) content_type = "text/html";\nif (!status) status = 200;\nstring status_text = ([\n200: "OK",\n301: "Moved Permanently",\n302: "Found",\n400: "Bad Request",\n404: "Not Found",\n500: "Internal Server Error"\n])[status] || "OK";\nwrite("Status: %d %s\\r\\n", status, status_text);\nwrite("Content-Type: %s; charset=utf-8\\r\\n", content_type);\nwrite("\\r\\n");\n}\nGenerate HTML form\nstring generate_form(mapping(string:string) values) {\nstring name = html_escape(values->name || "");\nstring email = html_escape(values->email || "");\nstring message = html_escape(values->message || "");\nreturn sprintf(#\nContact Form\nbody { font-family: Arial, sans-serif; margin: 40px; }\ninput, textarea { display: block; margin: 10px 0; padding: 8px; }\nbutton { padding: 10px 20px; cursor: pointer; }\nContact Form\nName:\nEmail:\nMessage:\n%s\nSubmit\n", name, email, message);\n}\nProcess form submission\nstring process_form(mapping(string:string) form) {\n// Validate required fields\nif (!form->name || !String.trim_all(form->name)) {\nreturn "ErrorName is required.";\n}\nif (!form->email || !has_suffix(form->email, "@")) {\nreturn "ErrorValid email is required.";\n}\n// In production, save to database or send email\nstring name = html_escape(form->name);\nstring email = html_escape(form->email);\nstring message = html_escape(form->message || "");\nreturn sprintf(#\nThank You\nThank You!\nYour message has been received:\nName: %s\nEmail: %s\nMessage: %s\n", name, email, message);\n}\nMain entry point\nvoid main() {\nmapping(string:string) form = parse_form_data();\nstring output;\nif (getenv("REQUEST_METHOD") == "POST") {\noutput = process_form(form);\n} else {\noutput = generate_form(form);\n}\nsend_headers();\nwrite(output);\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"redirecting-error-messages",children:"Redirecting Error Messages"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'#pragma strict_types\n#pragma no_clone\nCapture and redirect error messages to browser instead of server log\nconstant ERROR_LOG_FILE = "/tmp/cgi_errors.log";\nCustom error handler that captures errors\nmapping(string:string) error_data = ([\n"has_error": "0",\n"error_message": "",\n"backtrace": ""\n]);\nInstall error handler at the start of your CGI script\nvoid install_error_handler() {\nmaster()->set_inhibit_compile_errors(lambda(mixed err) {\nerror_data["has_error"] = "1";\nerror_data["error_message"] = sprintf("%O", err);\n});\n// Redirect stderr to a file\nStdio.File(ERROR_LOG_FILE, "wac")->dup2(stderr);\n}\nSend error page to browser\nvoid send_error_page(string title, string message, string|void backtrace) {\nwrite("Content-Type: text/html; charset=utf-8\\r\\n");\nwrite("Status: 500 Internal Server Error\\r\\n");\nwrite("\\r\\n");\nstring safe_title = replace(replace(replace(title, "", ">"), "\\"", """);\nstring safe_message = replace(replace(replace(message, "\\n", "\\n"), "", ">");\nstring safe_backtrace = backtrace ? replace(replace(backtrace, "\\n", "\\n"), "\nError\nbody { font-family: Arial, sans-serif; margin: 40px; background: #f0f0f0; }\n.error-box { background: #fff; border-left: 4px solid #d32f2f; padding: 20px; }\n.error-title { color: #d32f2f; margin-top: 0; }\n.error-message { white-space: pre-wrap; }\n.backtrace { background: #f5f5f5; padding: 15px; margin-top: 20px;\nfont-family: monospace; font-size: 12px; }\n%s\n%s", safe_title, safe_message);\nif (safe_backtrace != "") {\nwrite(sprintf("        Backtrace:%s\\n", safe_backtrace));\n}\nwrite("    \\n");\nwrite("\\n");\n}\nLog error to file with timestamp\nvoid log_error(string message) {\nstring timestamp = Calendar.now()->format_time();\nstring remote = getenv("REMOTE_ADDR") || "unknown";\nstring uri = getenv("REQUEST_URI") || "unknown";\nstring log_entry = sprintf("[%s] %s %s: %s\\n", timestamp, remote, uri, message);\nStdio.File f = Stdio.File();\nif (f->open(ERROR_LOG_FILE, "wac")) {\nf->write(log_entry);\nf->close();\n}\n}\nWrapper function for safe execution\nmixed safe_execute(function():mixed cb) {\ninstall_error_handler();\nmixed result = catch {\nreturn cb();\n};\nif (result) {\n// Error was caught\nstring err_msg = describe_error(result);\nlog_error(err_msg);\nsend_error_page("Application Error", err_msg, backtrace());\nreturn 0;\n}\nif (error_data["has_error"] == "1") {\nlog_error(error_data["error_message"]);\nsend_error_page("Compilation Error", error_data["error_message"]);\nreturn 0;\n}\nreturn UNDEFINED;\n}\nExample usage\nvoid main() {\nmixed err = safe_execute(lambda() {\n// Your CGI code here\nwrite("Content-Type: text/html\\r\\n\\r\\n");\nwrite("Hello World!\\n");\n});\nif (err) {\n// Error was already handled by safe_execute\nreturn;\n}\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"fixing-a-500-server-error",children:"Fixing a 500 Server Error"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'#pragma strict_types\n#pragma no_clone\nCommon causes of 500 errors and how to debug them\n1. Check file permissions (must be executable)\n$ chmod +x yourscript.pike\n2. Check shebang line at top of file\n#!/usr/bin/pike8\n3. Ensure proper HTTP headers are sent FIRST\nvoid debug_cgi() {\nstring debug = getenv("DEBUG_CGI") || "";\nif (debug == "1") {\n// Enable verbose error output for debugging\nmaster()->set_inhibit_compile_errors(0);\nadd_constant("verbose_errors", 1);\n}\n}\nCommon 500 error causes checklist\nmapping(string:string) check_environment() {\nmapping(string:string) issues = ([]);\n// Check if we have required CGI environment variables\nif (!getenv("REQUEST_METHOD")) {\nissues["no_cgi_env"] = "Not running in CGI environment";\n}\n// Check if we can write to stdout\nStdio.File stdout_file = Stdio.File(stdout);\nif (!stdout_file || stdout_file->is_open()) {\nissues["stdout_closed"] = "Cannot write to stdout";\n}\nreturn issues;\n}\nSend proper error response\nvoid error_response(int code, string message) {\nstring title = ([\n400: "Bad Request",\n404: "Not Found",\n500: "Internal Server Error",\n503: "Service Unavailable"\n])[code] || "Error";\nwrite("Status: %d %s\\r\\n", code, title);\nwrite("Content-Type: text/html; charset=utf-8\\r\\n\\r\\n");\nwrite(sprintf(#\n%d %s\nbody{font-family:Arial,sans-serif;margin:40px;text-align:center;}\n%d %s%s",\ncode, title, code, title, message));\n}\nValidate CGI script syntax before execution\nint validate_script(string script_path) {\nstring content;\nStdio.File f = Stdio.File();\nif (!f->open(script_path, "r")) {\nreturn 0;  // Cannot open file\n}\ncontent = f->read();\nf->close();\n// Check for shebang\nif (!has_prefix(content, "#!")) {\nreturn 0;  // Missing shebang\n}\n// Check for main() function\nif (!has_value(content, "void main()") &&\n!has_value(content, "int main()")) {\nreturn 0;  // Missing main() function\n}\nreturn 1;\n}\nDebug helper - outputs diagnostic information\nvoid show_diagnostics() {\nwrite("Content-Type: text/plain\\r\\n\\r\\n");\nwrite("CGI Diagnostics\\n===============\\n\\n");\nwrite("Environment Variables:\\n");\nforeach (getenv(); string k; string v) {\nwrite("  %s: %s\\n", k, v);\n}\nwrite(sprintf("\\nPike Version: %s\\n", __VERSION__));\nwrite(sprintf("Current Working Directory: %s\\n", getcwd()));\n}\nExample CGI script with proper error handling\nvoid main() {\n// Enable debugging if requested\ndebug_cgi();\n// Check environment\nmapping(string:string) issues = check_environment();\nif (sizeof(issues)) {\nif (getenv("DEBUG_CGI") == "1") {\nshow_diagnostics();\n} else {\nerror_response(500, "CGI environment error");\n}\nreturn;\n}\n// Your CGI code here - ALWAYS send headers first\nmixed err = catch {\nwrite("Content-Type: text/html; charset=utf-8\\r\\n\\r\\n");\nwrite("\\n");\nwrite("Success\\n");\nwrite("CGI Script Working!\\n");\n};\nif (err) {\nerror_response(500, sprintf("%O", err));\n}\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"writing-a-safe-cgi-program",children:"Writing a Safe CGI Program"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'#pragma strict_types\n#pragma no_clone\nSecurity-focused CGI programming with input validation and XSS prevention\nimport Protocols.HTTP;\nConfiguration constants\nconstant MAX_POST_SIZE = 1048576;         // 1MB limit\nconstant MAX_FIELD_LENGTH = 1000;          // Per-field limit\nconstant ALLOWED_TAGS = (["b":1, "i":1, "em":1, "strong":1, "p":1, "br":1]);\nHTML escape to prevent XSS attacks\nstring html_escape(string s) {\nreturn replace(replace(replace(replace(s, "&", "&"),\n"", ">"),\n"\\"", """);\n}\nStrip dangerous HTML tags (basic XSS prevention)\nstring sanitize_html(string html) {\n// Remove script tags and content\nstring result = replace(html, " max_length) {\nreturn 0;\n}\n// Trim whitespace\nstring result = String.trim_all(input);\n// Check for null bytes\nif (has_value(result, "\\0")) {\nreturn 0;\n}\n// Remove HTML unless explicitly allowed\nif (!allow_html) {\nresult = html_escape(result);\n} else {\nresult = sanitize_html(result);\n}\nreturn result;\n}\nValidate email format\nint is_valid_email(string email) {\nif (!email || sizeof(email)  254) {\nreturn 0;\n}\n// Basic email validation using Regexp\nreturn Regexp.simple(email, "^[\\\\w._%+-]+@[\\\\w.-]+\\\\.[a-zA-Z]{2,}$");\n}\nValidate URL format\nint is_valid_url(string url) {\nif (!url) return 0;\n// Check for allowed protocols only\narray(string) allowed = ({"http://", "https://", "ftp://"});\nforeach(allowed; string proto) {\nif (has_prefix(url, proto)) return 1;\n}\nreturn 0;\n}\nRate limiting using simple file-based storage\nmapping(string:int) rate_limits = ([]);\nint rate_limit_window = 60;  // seconds\nint max_requests_per_window = 10;\nint check_rate_limit(string identifier) {\nint now = time();\nif (!rate_limits[identifier]) {\nrate_limits[identifier] = now;\nreturn 1;\n}\nint last_request = rate_limits[identifier];\nint elapsed = now - last_request;\nif (elapsed >= rate_limit_window) {\nrate_limits[identifier] = now;\nreturn 1;\n}\nreturn 0;  // Rate limited\n}\nCSRF token generation and validation\nstring generate_csrf_token(string session_id) {\nstring secret = getenv("CSRF_SECRET") || "default-secret-change-me";\nstring timestamp = (string)time();\nstring data = session_id + timestamp + secret;\nreturn String.hash2(data, "SHA256");\n}\nParse and validate form data\nmapping(string:string) parse_and_validate() {\nmapping(string:string) form = ([]);\nstring data;\nstring method = getenv("REQUEST_METHOD") || "GET";\nif (method == "POST") {\nstring content_length = getenv("CONTENT_LENGTH") || "0";\nint len = (int)content_length;\n// Enforce size limit\nif (len > MAX_POST_SIZE) {\nwrite("Status: 413 Payload Too Large\\r\\n\\r\\nRequest too large.");\nreturn ([]);\n}\nif (len > 0) {\ndata = Stdio.File(stdin).read(len);\n}\n} else {\ndata = getenv("QUERY_STRING") || "";\n}\nif (data) {\nforeach(data / "&"; string pair) {\narray(string) parts = pair / "=";\nif (sizeof(parts) == 2) {\nstring|zero val = validate_string(\nProtocols.HTTP.http_decode_url(parts[1])\n);\nif (val) form[parts[0]] = val;\n}\n}\n}\nreturn form;\n}\nSend secure headers\nvoid send_secure_headers() {\nwrite("X-Content-Type-Options: nosniff\\r\\n");\nwrite("X-Frame-Options: SAMEORIGIN\\r\\n");\nwrite("X-XSS-Protection: 1; mode=block\\r\\n");\nwrite("Content-Type: text/html; charset=utf-8\\r\\n");\nwrite("\\r\\n");\n}\nExample safe CGI handler\nvoid main() {\n// Check rate limit by IP\nstring ip = getenv("REMOTE_ADDR") || "unknown";\nif (!check_rate_limit(ip)) {\nwrite("Status: 429 Too Many Requests\\r\\n\\r\\nRate limit exceeded.");\nreturn;\n}\nmapping(string:string) form = parse_and_validate();\n// Validate email if provided\nif (form->email && !is_valid_email(form->email)) {\nsend_secure_headers();\nwrite("Invalid email address\\n");\nreturn;\n}\n// Safe output with all input escaped\nsend_secure_headers();\nwrite("\\n");\nwrite("Safe CGI\\n");\nwrite("Safe Form Submission\\n");\nif (form->name) {\nwrite(sprintf("Hello, %s!\\n", form->name));\n}\nwrite("\\n");\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"making-cgi-scripts-efficient",children:"Making CGI Scripts Efficient"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'#pragma strict_types\n#pragma no_clone\nEfficiency techniques for CGI scripts in Pike\n1. Use persistent connection for database access\nconstant DB_CACHE_FILE = "/tmp/cgi_db_cache.pike";\nSimple in-memory cache (process-specific)\nmapping(string:mixed) cache = ([]);\nmapping(string:int) cache_times = ([]);\nint cache_ttl = 300;  // 5 minutes\nGet value from cache if available and fresh\nmixed|zero cache_get(string key) {\nif (cache[key] && cache_times[key]) {\nif (time() - cache_times[key] \n%s\n%s\n;\nstring footer_template #\n\xa9 2024 My App\n;\nEfficient string builder for large output\nclass StringBuilder {\narray(string) parts = ({});\nint total_size = 0;\nvoid append(string|mixed s) {\nstring str = (string)s;\nparts += ({ str });\ntotal_size += sizeof(str);\n}\nvoid appendf(string fmt, mixed... args) {\nstring str = sprintf(fmt, @args);\nparts += ({ str });\ntotal_size += sizeof(str);\n}\nstring get() {\nreturn parts * "";\n}\nint length() {\nreturn total_size;\n}\n}\n3. Lazy loading of expensive resources\nclass LazyLoader {\nmixed value;\nfunction(:mixed) loader;\nint loaded = 0;\nvoid create(function(:mixed) f) {\nloader = f;\n}\nmixed get() {\nif (!loaded) {\nvalue = loader();\nloaded = 1;\n}\nreturn value;\n}\n}\n4. Batched database queries (simulated)\narray(mapping) fetch_users_batch(array(int) user_ids) {\n// In production, use a single IN query instead of N queries\n// SELECT * FROM users WHERE id IN (1,2,3,...)\nreturn ({});  // Simulated\n}\n5. Output buffering - send headers once, then body\nclass BufferedOutput {\nStringBuilder buffer = StringBuilder();\nint headers_sent = 0;\nmapping(string:string) headers = ([\n"Content-Type": "text/html; charset=utf-8"\n]);\nvoid set_header(string name, string value) {\nheaders[name] = value;\n}\nvoid write(string|mixed s) {\nbuffer->append(s);\n}\nvoid flush() {\nif (!headers_sent) {\nforeach(headers; string name; string value) {\nwrite(sprintf("%s: %s\\r\\n", name, value));\n}\nwrite("\\r\\n");\nheaders_sent = 1;\n}\nif (buffer->length()) {\nwrite(buffer->get());\nbuffer = StringBuilder();\n}\n}\n}\n6. Connection pooling helper\nclass ConnectionPool {\nint max_connections;\narray(object) pool;\nint created = 0;\nvoid create(int max) {\nmax_connections = max;\npool = ({});\n}\nobject|zero acquire() {\nif (sizeof(pool)) return pop(pool);\nif (created set_header("X-Cache", "HIT");\nout->write(cached);\nout->flush();\nreturn;\n}\n// Build response efficiently\nout->set_header("X-Cache", "MISS");\nStringBuilder sb = StringBuilder();\nsb->append(header_template);\nsb->appendf("Efficient CGI Page", "Efficient CGI Page");\n// Add dynamic content\nsb->append("Page generated at: ");\nsb->append(ctime(time()));\nsb->append("\\n");\nsb->append(footer_template);\nstring response = sb->get();\n// Cache the response for GET requests\nif (getenv("REQUEST_METHOD") == "GET") {\ncache_set(cache_key, response);\n}\nout->write(response);\nout->flush();\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"executing-commands-without-shell-escapes",children:"Executing Commands Without Shell Escapes"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'#pragma strict_types\n#pragma no_clone\nSafely execute external commands without shell interpolation\nNEVER use system() or popen() with user input - always use Process.spawn()\nimport Process;\nWRONG - DANGEROUS - allows shell injection\n// string input = getenv("QUERY_STRING");\n// system("ls " + input);  // DON\'T DO THIS!\nRIGHT - SAFE - direct execution without shell\nstring safe_exec(string... args) {\nProcess.Process p = Process.spawn(args, ([\n"stdout": Process.PIPE,\n"stderr": Process.PIPE,\n"stdin": Process.PIPE\n]));\nstring output = p->stdout()->read();\nstring errors = p->stderr()->read();\nint status = p->wait();\nif (status != 0) {\nreturn "Error: " + errors;\n}\nreturn output;\n}\nValidate filename to prevent path traversal\nint is_safe_filename(string name) {\n// Reject empty names\nif (!name || sizeof(name) == 0) return 0;\n// Reject path separators\nif (has_value(name, "/") || has_value(name, "\\\\")) return 0;\n// Reject path traversal attempts\nif (has_value(name, "..")) return 0;\n// Only allow alphanumeric, underscore, dash, and dot\nint safe_chars = 0;\nfor (int i = 0; i = "a" && c = "A" && c = "0" && c stdout()->read();\nstring stderr = p->stderr()->read();\nint exit_code = p->wait();\nreturn ([\n"stdout": stdout,\n"stderr": stderr,\n"exit_code": (string)exit_code,\n"status": exit_code == 0 ? "success" : "error"\n]);\n}\nWrapper for handling file operations safely\nstring safe_file_info(string filename) {\nif (!is_safe_filename(filename)) {\nreturn "Error: Invalid filename";\n}\n// Use Process.spawn instead of system()\nreturn safe_exec("/usr/bin/file", "/safe/uploads/" + filename);\n}\nExample CGI handler for safe command execution\nvoid main() {\nwrite("Content-Type: text/plain; charset=utf-8\\r\\n\\r\\n");\n// Example: Safe directory listing\narray(string) args = ({ "/bin/ls", "-la", "/safe" });\nmapping(string:string) result = safe_command(args[0], args[1..]);\nwrite("Command Result:\\n");\nwrite("Status: " + result["status"] + "\\n");\nwrite("Exit code: " + result["exit_code"] + "\\n");\nwrite("\\nOutput:\\n" + result["stdout"]);\nif (result["stderr"]) {\nwrite("\\nErrors:\\n" + result["stderr"]);\n}\n}\nAlso available: Process.popen() for reading command output\nBut always validate arguments before passing!\nstring safe_popen(string program, array(string) args) {\nstring output = "";\nProcess.Process p = Process.spawn(args, ([\n"stdout": Process.PIPE\n]));\noutput = p->stdout()->read();\np->wait();\nreturn output;\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"formatting-lists-and-tables-with-html-shortcuts",children:"Formatting Lists and Tables with HTML Shortcuts"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'#pragma strict_types\n#pragma no_clone\nHTML helper functions for generating common UI elements\nHTML tag builder helper\nstring tag(string name, string|void content, mapping(string:string)|void attrs) {\nstring attr_str = "";\nif (attrs) {\nforeach(attrs; string k; string v) {\nattr_str += " " + k + "=\\"" + v + "\\"";\n}\n}\nif (content) {\nreturn sprintf("%s", name, attr_str, content, name);\n}\nreturn sprintf("", name, attr_str);\n}\nHTML escape function\nstring h(string s) {\nreturn replace(replace(replace(replace(s, "&", "&"),\n"", ">"),\n"\\"", """);\n}\nUnordered list generator\nstring ul(array(string) items, mapping(string:string)|void attrs) {\narray(string) lis = ({});\nforeach(items; string item) {\nlis += ({ "  " + h(item) + "" });\n}\nreturn "\\n" +\nlis * "\\n" + "\\n";\n}\nOrdered list generator\nstring ol(array(string) items, int|void start) {\narray(string) lis = ({});\nforeach(items; string item) {\nlis += ({ "  " + h(item) + "" });\n}\nstring start_attr = start ? sprintf(" start=\\"%d\\"", start) : "";\nreturn "\\n" + (lis * "\\n") + "\\n";\n}\nDefinition list generator\nstring dl(mapping(string:string) items) {\narray(string) pairs = ({});\nforeach(items; string term; string definition) {\npairs += ({ "  " + h(term) + "",\n"  " + h(definition) + "" });\n}\nreturn "\\n" + (pairs * "\\n") + "\\n";\n}\nTable generator from array of arrays\nstring table(array(array(string)) rows,\narray(string)|void headers,\nmapping(string:string)|void attrs) {\nstring attr_str = "";\nif (attrs) {\nforeach(attrs; string k; string v) {\nattr_str += " " + k + "=\\"" + v + "\\"";\n}\n}\nstring html = "\\n";\n// Add header row if provided\nif (headers) {\nhtml += "  \\n    \\n";\nforeach(headers; string h) {\nhtml += sprintf("      %s\\n", h(h));\n}\nhtml += "    \\n  \\n";\n}\n// Add data rows\nhtml += "  \\n";\nforeach(rows; array(string) row; int row_idx) {\nhtml += sprintf("    \\n",\nrow_idx % 2 ? "odd" : "even");\nforeach(row; string cell) {\nhtml += sprintf("      %s\\n", h(cell));\n}\nhtml += "    \\n";\n}\nhtml += "  \\n";\nhtml += "";\nreturn html;\n}\nTable from mapping (key-value pairs)\nstring kv_table(mapping(string:string) data,\nstring|void key_header,\nstring|void value_header) {\narray(array(string)) rows = ({});\nforeach(data; string k; string v) {\nrows += ({ ({ k, v }) });\n}\narray(string) headers = ((key_header && value_header) ? ({key_header, value_header}) : UNDEFINED);\nreturn table(rows, headers);\n}\nForm generator\nstring form(string action,\nstring|void method,\nstring|void content,\nmapping(string:string)|void attrs) {\nif (!method) method = "POST";\nreturn sprintf("%s",\naction, method,\nattrs ? " enctype=\\"multipart/form-data\\"" : "",\ncontent || "");\n}\nSelect dropdown generator\nstring select(string name,\narray(string) options,\nstring|void selected) {\nstring html = sprintf("\\n", name);\nforeach(options; string opt) {\nstring sel = (opt == selected) ? " selected" : "";\nhtml += sprintf("  %s\\n",\nh(opt), sel, h(opt));\n}\nhtml += "";\nreturn html;\n}\nCheckbox generator\nstring checkbox(string name, string value, int|void checked) {\nstring chk = checked ? " checked" : "";\nreturn sprintf("",\nname, h(value), chk);\n}\nPagination links generator\nstring pagination(int current, int total, int per_page) {\nint pages = (total + per_page - 1) / per_page;\nstring html = "\\n";\nif (current > 1) {\nhtml += sprintf("  Prev\\n", current - 1);\n}\nfor (int i = 1; i %d\\n", i, cls, i);\n}\nif (current Next\\n", current + 1);\n}\nhtml += "";\nreturn html;\n}\nExample usage in CGI\nvoid main() {\nwrite("Content-Type: text/html; charset=utf-8\\r\\n\\r\\n");\n// Sample data\narray(string) fruits = ({"Apple", "Banana", "Cherry", "Date"});\narray(array(string)) users = ({\n({"Alice", "alice@example.com", "Admin"}),\n({"Bob", "bob@example.com", "User"}),\n({"Carol", "carol@example.com", "User"})\n});\narray(string) headers = ({"Name", "Email", "Role"});\nwrite(#\nHTML Helpers Demo\nbody { font-family: Arial, sans-serif; margin: 40px; }\ntable { border-collapse: collapse; width: 100%; }\nth, td { border: 1px solid #ddd; padding: 8px; text-align: left; }\nth { background: #4CAF50; color: white; }\n.even { background: #f2f2f2; }\nul, ol { margin: 20px 0; }\nHTML Helpers Demo\nUnordered List");\nwrite(ul(fruits));\nwrite("\nOrdered List");\nwrite(ol(fruits, 5));\nwrite("\nDefinition List");\nwrite(dl((["Pike": "A dynamic programming language",\n"CGI": "Common Gateway Interface"])));\nwrite("\nData Table");\nwrite(table(users, headers, (["class": "data-table"])));\nwrite("\nPagination");\nwrite(pagination(2, 45, 10));\nwrite("\\n");\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"redirecting-to-a-different-location",children:"Redirecting to a Different Location"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'#pragma strict_types\n#pragma no_clone\nHTTP redirects for CGI applications\nSimple 301 Moved Permanently redirect\nvoid redirect_permanent(string url) {\nwrite("Status: 301 Moved Permanently\\r\\n");\nwrite(sprintf("Location: %s\\r\\n", url));\nwrite("Content-Type: text/html\\r\\n");\nwrite("\\r\\n");\nwrite(sprintf(#\nMoved\n301 Moved Permanently\nThis resource has moved to %s.\n", url, url));\n}\nTemporary 302 Found redirect (common for POST-Redirect-GET pattern)\nvoid redirect_temporary(string url) {\nwrite("Status: 302 Found\\r\\n");\nwrite(sprintf("Location: %s\\r\\n", url));\nwrite("Content-Type: text/html\\r\\n");\nwrite("\\r\\n");\nwrite(sprintf(#\nRedirect\n302 Found\nRedirecting to %s...\nwindow.location="%s";\n", url, url, url));\n}\n303 See Other redirect (after POST to prevent resubmission)\nvoid redirect_after_post(string url) {\nwrite("Status: 303 See Other\\r\\n");\nwrite(sprintf("Location: %s\\r\\n", url));\nwrite("\\r\\n");\n}\n307 Temporary Redirect (preserves method)\nvoid redirect_temp_preserve(string url) {\nwrite("Status: 307 Temporary Redirect\\r\\n");\nwrite(sprintf("Location: %s\\r\\n", url));\nwrite("\\r\\n");\n}\nSafe redirect with validation (prevent open redirect attacks)\nint is_safe_url(string url) {\n// Reject empty URLs\nif (!url) return 0;\n// Allow relative URLs starting with /\nif (has_prefix(url, "/")) return 1;\n// Allow absolute URLs only from whitelist\nstring host = getenv("HTTP_HOST") || "localhost";\narray(string) allowed_hosts = ({ host, "www." + host });\nforeach(allowed_hosts; string allowed) {\nif (has_prefix(url, "http://" + allowed) ||\nhas_prefix(url, "https://" + allowed)) {\nreturn 1;\n}\n}\nreturn 0;\n}\nvoid safe_redirect(string|void url) {\n// Default to home if URL is invalid\nif (!url || !is_safe_url(url)) {\nurl = "/";\n}\nredirect_temporary(url);\n}\nBuild URL with query string\nstring build_url(string base, mapping(string:string) params) {\narray(string) pairs = ({});\nforeach(params; string key; string value) {\nstring encoded_key = Protocols.HTTP.http_encode_url(key);\nstring encoded_value = Protocols.HTTP.http_encode_url(value);\npairs += ({ encoded_key + "=" + encoded_value });\n}\nstring separator = has_value(base, "?") ? "&" : "?";\nreturn base + separator + pairs * "&";\n}\nRefresh meta redirect (client-side fallback)\nvoid meta_redirect(string url, int|void delay) {\nif (!delay) delay = 0;\nwrite("Content-Type: text/html; charset=utf-8\\r\\n\\r\\n");\nwrite(sprintf(#\nRedirecting...\nbody{font-family:Arial,sans-serif;text-align:center;margin-top:100px;}\nRedirecting...\nPlease wait while we redirect you to %s.\nsetTimeout(function(){window.location="%s";},%d*1000);\n", delay, url, url,\ndelay == 0 ? " style=\\"display:none\\"" : "",\nurl, url, delay));\n}\nExample: POST-Redirect-GET pattern to prevent form resubmission\nvoid handle_form_post() {\n// Process the form data...\n// Store success message in session or cookie\nset_cookie("flash_message", "Form submitted successfully!");\n// Redirect to GET page\nredirect_after_post("/thank-you");\n}\nSimple cookie setting helper\nvoid set_cookie(string name, string value,\nint|void lifetime,\nstring|void path,\nstring|void domain) {\nif (!path) path = "/";\nif (!lifetime) lifetime = 3600;  // 1 hour default\nint expiry = time() + lifetime;\nstring date = Calendar.Second(expiry)->format_http();\nstring cookie = sprintf("%s=%s; Expires=%s; Path=%s",\nname, value, date, path);\nif (domain) cookie += "; Domain=" + domain;\n// Set cookie via Set-Cookie header\nwrite(sprintf("Set-Cookie: %s\\r\\n", cookie));\n}\nExample usage\nvoid main() {\nstring redirect_target = getenv("QUERY_STRING");\nif (redirect_target) {\n// Parse the target parameter\nmapping(string:string) params = ([]);\nforeach(redirect_target / "&"; string pair) {\narray(string) parts = pair / "=";\nif (sizeof(parts) == 2) {\nparams[parts[0]] = Protocols.HTTP.http_decode_url(parts[1]);\n}\n}\n// Safely redirect to target (prevents open redirect attacks)\nsafe_redirect(params->url);\n} else {\n// Show a page with redirect examples\nwrite("Content-Type: text/html; charset=utf-8\\r\\n\\r\\n");\nwrite(#\nRedirect Examples\nHTTP Redirect Examples\nTemporary redirect (302)\nSafe redirect\nDefault redirect\n");\n}\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"debugging-the-raw-http-exchange",children:"Debugging the Raw HTTP Exchange"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'#pragma strict_types\n#pragma no_clone\nHTTP debugging tools for CGI applications\nimport Protocols.HTTP;\nLog file for HTTP debugging\nconstant DEBUG_LOG = "/tmp/http_debug.log";\nWrite debug information to log file\nvoid debug_log(string message) {\nstring timestamp = Calendar.now()->format_time();\nStdio.File f = Stdio.File();\nif (f->open(DEBUG_LOG, "wac")) {\nf->write(sprintf("[%s] %s\\n", timestamp, message));\nf->close();\n}\n}\nDump all HTTP headers received\nstring dump_request_headers() {\nstring output = "=== HTTP Request Headers ===\\n";\n// Standard CGI environment variables that represent headers\narray(string) http_vars = ({\n"HTTP_ACCEPT", "HTTP_ACCEPT_CHARSET", "HTTP_ACCEPT_ENCODING",\n"HTTP_ACCEPT_LANGUAGE", "HTTP_AUTHORIZATION", "HTTP_CONNECTION",\n"HTTP_COOKIE", "HTTP_HOST", "HTTP_REFERER",\n"HTTP_USER_AGENT", "HTTP_X_FORWARDED_FOR"\n});\nforeach(http_vars; string var) {\nstring value = getenv(var);\nif (value) {\n// Convert HTTP_XXX to readable header name\nstring header_name = replace(var->substring(5), "_", "-");\noutput += sprintf("%s: %s\\n", header_name, value);\n}\n}\nreturn output;\n}\nDump all CGI environment variables\nstring dump_cgi_environment() {\nstring output = "=== CGI Environment ===\\n";\narray(string) cgi_vars = ({\n"REQUEST_METHOD", "REQUEST_URI", "QUERY_STRING",\n"CONTENT_TYPE", "CONTENT_LENGTH",\n"SCRIPT_NAME", "PATH_INFO", "PATH_TRANSLATED",\n"SERVER_NAME", "SERVER_PORT", "SERVER_PROTOCOL",\n"REMOTE_ADDR", "REMOTE_HOST", "REMOTE_USER",\n"AUTH_TYPE", "DOCUMENT_ROOT"\n});\nforeach(cgi_vars; string var) {\nstring value = getenv(var);\noutput += sprintf("%s: %s\\n", var, value || "(not set)");\n}\nreturn output;\n}\nRead and dump raw POST data\nstring dump_post_data() {\nstring output = "=== POST Data ===\\n";\nstring method = getenv("REQUEST_METHOD") || "GET";\nstring content_type = getenv("CONTENT_TYPE") || "";\noutput += sprintf("Method: %s\\n", method);\noutput += sprintf("Content-Type: %s\\n", content_type);\nif (method == "POST") {\nstring length = getenv("CONTENT_LENGTH") || "0";\noutput += sprintf("Content-Length: %s\\n", length);\nint len = (int)length;\nif (len > 0 && len = 2) {\noutput += sprintf("%s: %s\\n", parts[0], parts[1] * "=");\n}\n}\n}\nreturn output;\n}\nGenerate full HTTP request dump\nstring dump_full_request() {\nstring output = "";\noutput += dump_cgi_environment();\noutput += "\\n";\noutput += dump_request_headers();\noutput += "\\n";\noutput += dump_cookies();\noutput += "\\n";\noutput += dump_post_data();\nreturn output;\n}\nSave request info to debug log\nvoid log_request() {\nstring remote = getenv("REMOTE_ADDR") || "unknown";\nstring method = getenv("REQUEST_METHOD") || "UNKNOWN";\nstring uri = getenv("REQUEST_URI") || "/";\ndebug_log(sprintf("%s %s from %s", method, uri, remote));\n}\nPretty HTML output for debugging\nstring html_debug_output() {\nstring output = dump_full_request();\n// Escape HTML and wrap in  tags\noutput = replace(replace(replace(output, "", ">"),\n"\\n", "\\n");\nreturn sprintf(#\nHTTP Debug Info\nbody { font-family: monospace; margin: 20px; background: #1e1e1e; color: #d4d4d4; }\nh1 { color: #4ec9b0; }\n.section { color: #569cd6; font-weight: bold; margin-top: 20px; }\npre { background: #252526; padding: 15px; border-radius: 5px; }\nHTTP Request Debug Information\n%s\nTimestamp: %s\n",\noutput, ctime(time()));\n}\nMain debug CGI handler\nvoid main() {\n// Always log requests\nlog_request();\n// Check if debugging is enabled\nstring debug = getenv("DEBUG_HTTP") || getenv("QUERY_STRING") || "";\nif (debug == "1" || debug == "debug") {\nwrite("Content-Type: text/html; charset=utf-8\\r\\n\\r\\n");\nwrite(html_debug_output());\n} else {\n// Normal request handling\nwrite("Content-Type: text/html; charset=utf-8\\r\\n\\r\\n");\nwrite(#\nHTTP Debug Tool\nbody{font-family:Arial,sans-serif;margin:40px;text-align:center;}\nHTTP Debug Tool\nAdd ?debug to URL to see full HTTP request dump.\nAll requests are logged to: /tmp/http_debug.log\n");\n}\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"managing-cookies",children:"Managing Cookies"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'#pragma strict_types\n#pragma no_clone\nCookie management for CGI applications\nParse Cookie header into mapping\nmapping(string:string) parse_cookies() {\nmapping(string:string) cookies = ([]);\nstring cookie_header = getenv("HTTP_COOKIE") || "";\nif (cookie_header != "") {\nforeach(cookie_header / ";"; string cookie) {\nstring trimmed = String.trim_all(cookie);\nint pos = search(trimmed, "=");\nif (pos > 0) {\nstring name = trimmed[0..pos-1];\nstring value = trimmed[pos+1..];\ncookies[name] = value;\n}\n}\n}\nreturn cookies;\n}\nCookie attributes\nclass CookieAttributes {\nstring value;\nint|void max_age;\nint|void expires;\nstring|void domain;\nstring|void path;\nint|void secure;\nint|void http_only;\nstring|void same_site;  // "Strict", "Lax", or "None"\nvoid create(string _value,\nmapping(string:mixed)|void attrs) {\nvalue = _value;\nif (attrs) {\nmax_age = attrs["max_age"];\nexpires = attrs["expires"];\ndomain = attrs["domain"];\npath = attrs["path"];\nsecure = attrs["secure"];\nhttp_only = attrs["http_only"];\nsame_site = attrs["same_site"];\n}\n}\nstring format() {\nstring result = value;\nif (max_age) {\nresult += sprintf("; Max-Age=%d", max_age);\n}\nif (expires) {\nstring date = Calendar.Second(expires)->format_http();\nresult += "; Expires=" + date;\n}\nif (path) {\nresult += "; Path=" + path;\n}\nif (domain) {\nresult += "; Domain=" + domain;\n}\nif (secure) {\nresult += "; Secure";\n}\nif (http_only) {\nresult += "; HttpOnly";\n}\nif (same_site) {\nresult += "; SameSite=" + same_site;\n}\nreturn result;\n}\n}\nSet a cookie with full attribute support\nvoid set_cookie(string name,\nstring|CookieAttributes value_or_attrs,\nmapping(string:mixed)|void attrs) {\nCookieAttributes cookie_attrs;\nif (objectp(value_or_attrs)) {\ncookie_attrs = value_or_attrs;\n} else {\ncookie_attrs = CookieAttributes(value_or_attrs, attrs);\n}\nstring cookie = sprintf("%s=%s", name, cookie_attrs->format());\nwrite(sprintf("Set-Cookie: %s\\r\\n", cookie));\n}\nDelete a cookie by setting max-age=0\nvoid delete_cookie(string name, string|void path) {\nif (!path) path = "/";\nset_cookie(name, "", ([\n"max_age": 0,\n"path": path,\n"expires": 1  // Unix timestamp 1 = past\n]));\n}\nSession management using cookies\nclass Session {\nstring session_id;\nmapping(string:mixed) data = ([]);\nint created;\nint last_activity;\nint timeout = 1800;  // 30 minutes\nvoid create(string|void id) {\ncreated = time();\nlast_activity = created;\nif (id) {\nsession_id = id;\n} else {\nsession_id = generate_session_id();\n}\n}\nstring generate_session_id() {\nstring data = sprintf("%d.%s.%d",\ntime(),\nString.string2hex(Crypto.Random.random_string(16)),\ngetpid());\nreturn String.hash2(data, "SHA256");\n}\nint is_expired() {\nreturn (time() - last_activity) > timeout;\n}\nvoid touch() {\nlast_activity = time();\n}\nmixed get(string key) {\nreturn data[key];\n}\nvoid set(string key, mixed value) {\ndata[key] = value;\ntouch();\n}\n}\nIn-memory session store (for production, use database)\nmapping(string:Session) sessions = ([]);\nSession|zero get_session(string|void session_id) {\n// Clean up expired sessions first\nforeach (indices(sessions); string id) {\nif (sessions[id]->is_expired()) {\nm_delete(sessions, id);\n}\n}\nif (session_id && sessions[session_id]) {\nSession s = sessions[session_id];\ns->touch();\nreturn s;\n}\n// Create new session\nSession new_session = Session();\nsessions[new_session->session_id] = new_session;\nreturn new_session;\n}\nSend session cookie\nvoid send_session_cookie(Session session) {\nset_cookie("session_id", session->session_id, ([\n"http_only": 1,\n"same_site": "Lax",\n"path": "/",\n"max_age": 3600\n]));\n}\nExample usage: Counter with session persistence\nvoid main() {\n// Get session from cookie\nmapping(string:string) cookies = parse_cookies();\nSession session = get_session(cookies["session_id"]);\n// Handle actions\nstring action = getenv("QUERY_STRING") || "";\nif (action == "increment") {\nint count = (int)(session->get("count") || "0");\nsession->set("count", (string)(count + 1));\n} else if (action == "reset") {\nsession->set("count", "0");\n}\n// Ensure session cookie is set\nsend_session_cookie(session);\n// Send response\nwrite("Content-Type: text/html; charset=utf-8\\r\\n\\r\\n");\nint count = (int)(session->get("count") || "0");\nwrite(sprintf(#\nSession Counter\nbody { font-family: Arial, sans-serif; margin: 40px; text-align: center; }\n.counter { font-size: 48px; margin: 20px 0; }\nbutton { padding: 10px 20px; font-size: 16px; cursor: pointer; }\nSession Counter\nSession ID: %s\n%d\nIncrement\nReset\nRefresh to persist. Close browser to end session.\n",\nsession->session_id, count));\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"creating-sticky-widgets",children:"Creating Sticky Widgets"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'#pragma strict_types\n#pragma no_clone\nSticky widgets preserve user input across form submissions\nHTML escape function\nstring h(string s) {\nreturn replace(replace(replace(replace(s, "&", "&"),\n"", ">"),\n"\\"", """);\n}\nParse form data from GET or POST\nmapping(string:string) parse_form() {\nmapping(string:string) form = ([]);\nstring data;\nstring method = getenv("REQUEST_METHOD") || "GET";\nif (method == "POST") {\nstring length = getenv("CONTENT_LENGTH") || "0";\nif ((int)length > 0) {\ndata = Stdio.File(stdin).read((int)length);\n}\n} else {\ndata = getenv("QUERY_STRING") || "";\n}\nif (data) {\nforeach(data / "&"; string pair) {\narray(string) parts = pair / "=";\nif (sizeof(parts) == 2) {\nform[parts[0]] = Protocols.HTTP.http_decode_url(parts[1]);\n}\n}\n}\nreturn form;\n}\nSticky text input\nstring sticky_input(string name,\nstring|void value,\nmapping(string:string)|void attrs,\nmapping(string:string) form) {\n// Use submitted value or default\nstring display_value = form[name] || value || "";\nstring attr_str = sprintf("name=\\"%s\\" value=\\"%s\\"", name, h(display_value));\nif (attrs) {\nforeach(attrs; string k; string v) {\nattr_str += sprintf(" %s=\\"%s\\"", k, h(v));\n}\n}\nreturn "";\n}\nSticky textarea\nstring sticky_textarea(string name,\nstring|void value,\nmapping(string:string)|void attrs,\nmapping(string:string) form) {\nstring display_value = form[name] || value || "";\nstring attr_str = sprintf("name=\\"%s\\"", name);\nif (attrs) {\nforeach(attrs; string k; string v) {\nattr_str += sprintf(" %s=\\"%s\\"", k, h(v));\n}\n}\nreturn sprintf("%s",\nattr_str, h(display_value));\n}\nSticky checkbox\nstring sticky_checkbox(string name,\nstring value,\nint|void default_checked,\nmapping(string:string)|void attrs,\nmapping(string:string) form) {\n// Check if this checkbox was submitted\nint checked = default_checked || 0;\nif (form[name] == value) {\nchecked = 1;\n} else if (indices(form) [name] && form[name] != value) {\n// Checkbox exists in form but has different value = unchecked\nchecked = 0;\n}\nstring attr_str = sprintf("type=\\"checkbox\\" name=\\"%s\\" value=\\"%s\\"",\nname, h(value));\nif (checked) attr_str += " checked";\nif (attrs) {\nforeach(attrs; string k; string v) {\nattr_str += sprintf(" %s=\\"%s\\"", k, h(v));\n}\n}\nreturn "";\n}\nSticky radio button group\nstring sticky_radio(string name,\narray(array(string)) options,  // ({({value, label}), ...})\nstring|void selected,\nmapping(string:string) form) {\nstring current = form[name] || selected || "";\nstring html = "";\nforeach(options; array(string) option) {\nstring value = option[0];\nstring label = option[1];\nstring sel = (value == current) ? " checked" : "";\nhtml += sprintf(" %s\\n",\nname, h(value), sel, h(label));\n}\nreturn html;\n}\nSticky select dropdown\nstring sticky_select(string name,\narray(array(string)) options,\nstring|void selected,\nint|void multiple,\nmapping(string:string) form) {\nstring current = form[name] || selected || "";\nstring html = sprintf("\\n",\nname, multiple ? " multiple" : "");\nforeach(options; array(string) option) {\nstring value = option[0];\nstring label = option[1];\nstring sel = (value == current) ? " selected" : "";\nhtml += sprintf("  %s\\n",\nh(value), sel, h(label));\n}\nhtml += "";\nreturn html;\n}\nSticky multiselect (returns array of values)\nstring sticky_multiselect(string name,\narray(array(string)) options,\narray(string)|void selected,\nmapping(string:string) form) {\n// Parse multiple values from form (e.g., "name=val1&name=val2")\narray(string) current = selected || ({});\n// Collect all submitted values for this name\n// (In a real implementation, you\'d parse all values for the same key)\nif (form[name] && form[name] != "") {\ncurrent = ({ form[name] });\n}\nstring html = sprintf("\\n", name);\nforeach(options; array(string) option) {\nstring value = option[0];\nstring label = option[1];\nstring sel = has_value(current, value) ? " selected" : "";\nhtml += sprintf("  %s\\n",\nh(value), sel, h(label));\n}\nhtml += "";\nreturn html;\n}\nComplete sticky form example\nvoid main() {\nmapping(string:string) form = parse_form();\nwrite("Content-Type: text/html; charset=utf-8\\r\\n\\r\\n");\nwrite(#\nSticky Form Demo\nbody { font-family: Arial, sans-serif; margin: 40px; }\nfieldset { border: 1px solid #ddd; padding: 20px; margin-bottom: 20px; border-radius: 8px; }\nlegend { font-weight: bold; padding: 0 10px; }\nlabel { display: block; margin: 10px 0 5px; }\ninput[type="text"], textarea, select { width: 300px; padding: 8px; }\ntextarea { height: 80px; }\nbutton { padding: 10px 20px; cursor: pointer; }\n.result { background: #e8f5e9; padding: 15px; border-radius: 5px; margin: 20px 0; }\nSticky Form Widgets Demo\nSubmit the form - your values will be preserved!");\n// Show submitted values\nif (sizeof(form)) {\nwrite("Submitted values:\\n");\nforeach(form; string k; string v) {\nwrite(sprintf("%s: %s\\n", k, h(v)));\n}\nwrite("\\n");\n}\n// Generate sticky form\nwrite("\\n");\nwrite("  \\n");\nwrite("    Personal Information\\n");\nwrite("    Name:\\n");\nwrite("    " + sticky_input("name", "Enter your name", (["placeholder": "John Doe"]), form) + "\\n");\nwrite("    Email:\\n");\nwrite("    " + sticky_input("email", "", (["type": "email", "placeholder": "john@example.com"]), form) + "\\n");\nwrite("  \\n");\nwrite("  \\n");\nwrite("    Preferences\\n");\nwrite("    Favorite Color:\\n");\nwrite("    " + sticky_select("color", ({\n({"red", "Red"}), ({"green", "Green"}), ({"blue", "Blue"}), ({"purple", "Purple"})\n}), "blue", 0, form) + "\\n");\nwrite("    "\\n");\nwrite("  \\n");\nwrite("    Options\\n");\nwrite("    "\\n");\nwrite("      " + sticky_checkbox("subscribe", "yes", 1, ([]), form) + " Subscribe to newsletter\\n");\nwrite("    \\n");\nwrite("  \\n");\nwrite("  \\n");\nwrite("    Message\\n");\nwrite("    "Your message:\\n");\nwrite("    " + sticky_textarea("message", "Type here...", (["rows": "4"]), form) + "\\n");\nwrite("  \\n");\nwrite("  Submit\\n");\nwrite("  Reset\\n");\nwrite("\\n");\nwrite("\\n");\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"writing-a-multiscreen-cgi-script",children:"Writing a Multiscreen CGI Script"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'#pragma strict_types\n#pragma no_clone\nMultiscreen/state-driven CGI application with navigation\nHTML escape function\nstring h(string s) {\nreturn replace(replace(replace(replace(s, "&", "&"),\n"", ">"),\n"\\"", """);\n}\nParse form data\nmapping(string:string) parse_form() {\nmapping(string:string) form = ([]);\nstring data = getenv("QUERY_STRING") || "";\nstring method = getenv("REQUEST_METHOD") || "GET";\nif (method == "POST") {\nstring length = getenv("CONTENT_LENGTH") || "0";\nif ((int)length > 0) {\ndata = Stdio.File(stdin).read((int)length);\n}\n}\nif (data) {\nforeach(data / "&"; string pair) {\narray(string) parts = pair / "=";\nif (sizeof(parts) == 2) {\nform[parts[0]] = Protocols.HTTP.http_decode_url(parts[1]);\n}\n}\n}\nreturn form;\n}\nApplication state (session data)\nclass AppState {\nstring current_screen;\nmapping(string:string) data = ([]);\narray(string) errors = ({});\narray(string) messages = ({});\nvoid create(string starting_screen) {\ncurrent_screen = starting_screen;\n}\nvoid set_screen(string screen) {\ncurrent_screen = screen;\n}\nvoid set_data(string key, string value) {\ndata[key] = value;\n}\nstring|zero get_data(string key) {\nreturn data[key];\n}\nvoid add_error(string error) {\nerrors += ({ error });\n}\nvoid add_message(string message) {\nmessages += ({ message });\n}\n}\nNavigation helper\nstring nav_link(string screen, string label) {\nreturn sprintf("%s", screen, label);\n}\nRender common header\nstring render_header(AppState state) {\nreturn sprintf(#\nMulti-Screen App - %s\nbody { font-family: Arial, sans-serif; margin: 0; padding: 0; background: #f5f5f5; }\nnav { background: #333; padding: 15px 20px; }\nnav a { color: white; text-decoration: none; margin-right: 20px; }\nnav a:hover { text-decoration: underline; }\nnav a.active { font-weight: bold; color: #4CAF50; }\n.container { max-width: 800px; margin: 30px auto; padding: 30px; background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }\n.error { background: #ffebee; color: #c62828; padding: 10px; border-radius: 4px; margin: 10px 0; }\n.message { background: #e8f5e9; color: #2e7d32; padding: 10px; border-radius: 4px; margin: 10px 0; }\nh1 { margin-top: 0; color: #333; }\nlabel { display: block; margin: 15px 0 5px; font-weight: bold; }\ninput, select, textarea { width: 100%%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box; }\nbutton { background: #4CAF50; color: white; border: none; padding: 12px 24px; border-radius: 4px; cursor: pointer; }\nbutton:hover { background: #45a049; }\n%s\n",\nString.capitalize(state->current_screen),\nnav_link("home", "Home") + " " +\nnav_link("form", "Form") + " " +\nnav_link("confirm", "Confirm") + " " +\nnav_link("result", "Result")\n);\n}\nRender common footer\nstring render_footer() {\nreturn "\n";\n}\nScreen: Home\nstring screen_home(AppState state) {\nreturn render_header(state) + sprintf(#\nWelcome to the Multi-Screen Application\nThis is a demonstration of a state-driven CGI application in Pike.\nNavigate through the screens using the menu above:\nHome - This page\nForm - Enter your information\nConfirm - Review before submitting\nResult - See the final output\nGet Started\n") + render_footer();\n}\nScreen: Form\nstring screen_form(AppState state, mapping(string:string) form) {\nstring name = form["name"] || state->get_data("name") || "";\nstring email = form["email"] || state->get_data("email") || "";\nstring interest = form["interest"] || state->get_data("interest") || "coding";\nreturn render_header(state) + sprintf(#\nEnter Your Information\nName:\nEmail:\nArea of Interest:\nProgramming\nDesign\nBusiness\nOther\nContinue to Confirm\n",\nh(name), h(email),\ninterest == "coding" ? " selected" : "",\ninterest == "design" ? " selected" : "",\ninterest == "business" ? " selected" : "",\ninterest == "other" ? " selected" : ""\n) + render_footer();\n}\nScreen: Confirm\nstring screen_confirm(AppState state, mapping(string:string) form) {\n// Save form data to state\nif (form["name"]) state->set_data("name", form["name"]);\nif (form["email"]) state->set_data("email", form["email"]);\nif (form["interest"]) state->set_data("interest", form["interest"]);\nstring name = state->get_data("name") || "";\nstring email = state->get_data("email") || "";\nstring interest = state->get_data("interest") || "";\nstring interest_label = ([\n"coding": "Programming",\n"design": "Design",\n"business": "Business",\n"other": "Other"\n])[interest] || interest;\nreturn render_header(state) + sprintf(#\nConfirm Your Information\nPlease review the information below before submitting:\nName:%s\nEmail:%s\nInterest:%s\nConfirm & Submit\nGo Back\n",\nh(name), h(email), h(interest_label)\n) + render_footer();\n}\nScreen: Result\nstring screen_result(AppState state) {\nstring name = state->get_data("name") || "Guest";\nstring ref_num = "REF-" + String.string2hex(Crypto.Random.random_string(4))[0..7];\nreturn render_header(state) + sprintf(#\nThank You!\nSubmission Successful\nYour information has been recorded.\nName: %s\nReference Number: %s\nWe\'ve sent a confirmation email to your address.\nReturn Home\n",\nh(name), ref_num\n) + render_footer();\n}\nMain application router\nvoid main() {\nmapping(string:string) form = parse_form();\nstring screen = form["screen"] || "home";\n// Valid screens\narray(string) valid_screens = ({"home", "form", "confirm", "result"});\nif (search(valid_screens, screen) == -1) {\nscreen = "home";\n}\n// Create application state\nAppState state = AppState(screen);\n// Route to appropriate screen\nstring output;\nswitch (screen) {\ncase "home":\noutput = screen_home(state);\nbreak;\ncase "form":\noutput = screen_form(state, form);\nbreak;\ncase "confirm":\noutput = screen_confirm(state, form);\nbreak;\ncase "result":\noutput = screen_result(state);\nbreak;\ndefault:\noutput = screen_home(state);\nbreak;\n}\n// Send response\nwrite("Content-Type: text/html; charset=utf-8\\r\\n\\r\\n");\nwrite(output);\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"saving-a-form-to-a-file-or-mail-pipe",children:"Saving a Form to a File or Mail Pipe"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike"})}),"\n",(0,i.jsx)(e.h3,{id:"program-chemiserie",children:"Program: chemiserie"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike"})})]})}function p(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},8453(n,e,t){t.d(e,{R:()=>a,x:()=>o});var r=t(6540);const i={},s=r.createContext(i);function a(n){const e=r.useContext(s);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:a(n.components),r.createElement(s.Provider,{value:e},n.children)}}}]);