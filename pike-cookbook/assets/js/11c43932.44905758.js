"use strict";(self.webpackChunkpike_cookbook=self.webpackChunkpike_cookbook||[]).push([[43],{8259(n,e,r){r.r(e),r.d(e,{assets:()=>c,contentTitle:()=>a,default:()=>g,frontMatter:()=>s,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"network/sockets","title":"Sockets","description":"Introduction","source":"@site/docs/network/sockets.md","sourceDirName":"network","slug":"/network/sockets","permalink":"/pike-cookbook/docs/network/sockets","draft":false,"unlisted":false,"editUrl":"https://github.com/smuks/pike-cookbook/tree/main/docs/network/sockets.md","tags":[],"version":"current","frontMatter":{"id":"sockets","title":"Sockets","sidebar_label":"Sockets"},"sidebar":"tutorialSidebar","previous":{"title":"CGI Programming","permalink":"/pike-cookbook/docs/network/cgi-programming"},"next":{"title":"Web Automation","permalink":"/pike-cookbook/docs/network/web-automation"}}');var i=r(4848),o=r(8453);const s={id:"sockets",title:"Sockets",sidebar_label:"Sockets"},a="17. Sockets",c={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Writing a TCP Client",id:"writing-a-tcp-client",level:2},{value:"Writing a TCP Server",id:"writing-a-tcp-server",level:2},{value:"Communicating over TCP",id:"communicating-over-tcp",level:2},{value:"Setting Up a UDP Client",id:"setting-up-a-udp-client",level:2},{value:"Setting Up a UDP Server",id:"setting-up-a-udp-server",level:2},{value:"Using UNIX Domain Sockets",id:"using-unix-domain-sockets",level:2},{value:"UNIX Domain Socket Server",id:"unix-domain-socket-server",level:2},{value:"Identifying the Other End of a Socket",id:"identifying-the-other-end-of-a-socket",level:2},{value:"Finding Your Own Name and Address",id:"finding-your-own-name-and-address",level:2},{value:"SSL/TLS Sockets",id:"ssltls-sockets",level:2},{value:"SSL/TLS Server",id:"ssltls-server",level:2},{value:"Closing a Socket After Forking",id:"closing-a-socket-after-forking",level:2},{value:"Writing Bidirectional Clients",id:"writing-bidirectional-clients",level:2},{value:"Non-Blocking I/O with select()",id:"non-blocking-io-with-select",level:2},{value:"Forking Servers",id:"forking-servers",level:2},{value:"Socket Options and Configuration",id:"socket-options-and-configuration",level:2},{value:"Modern Async with Concurrent.Future",id:"modern-async-with-concurrentfuture",level:2},{value:"Pre-Forking Servers",id:"pre-forking-servers",level:2},{value:"Non-Forking Servers",id:"non-forking-servers",level:2},{value:"Writing a Multi-Homed Server",id:"writing-a-multi-homed-server",level:2},{value:"Making a Daemon Server",id:"making-a-daemon-server",level:2},{value:"Restarting a Server on Demand",id:"restarting-a-server-on-demand",level:2},{value:"Program: backsniff",id:"program-backsniff",level:2},{value:"Program: fwdport",id:"program-fwdport",level:2}];function l(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",pre:"pre",...(0,o.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"17-sockets",children:"17. Sockets"})}),"\n",(0,i.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n//Pike doesn\'t normally use packed IP addresses. Strings such as "204.148.40.9" are used literally.\n//\n//-----------------------------\n//DNS lookups can be done with gethostbyname() and gethostbyaddr()\n[string host,array ip,array alias] = gethostbyname("www.example.com");\n//ip[0] is a string "192.0.32.10"\n//\n//-----------------------------\n'})}),"\n",(0,i.jsx)(e.h2,{id:"writing-a-tcp-client",children:"Writing a TCP Client"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\nStdio.File sock=Stdio.File();\nif (!sock->connect(remote_host,remote_port)) //Connection failed. Error code is in sock->errno().\n{\n    werror("Couldn\'t connect to %s:%d: %s\\n",remote_host,remote_port,strerror(sock->errno()));\n    return 1;\n}\nsock->write("Hello, world!"); //Send something to the socket\nstring answer=sock->read(); //Read until the remote side disconnects. Use sock->read(1024,1) to read only some (up to 1KB here).\nsock->close(); //Not necessary if the sock object goes out of scope here.\n//\n//-----------------------------\n'})}),"\n",(0,i.jsx)(e.h2,{id:"writing-a-tcp-server",children:"Writing a TCP Server"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:"//-----------------------------\nStdio.Port mainsock=Stdio.Port();\nif (!mainsock->bind(server_port))\n{\n    werror(\"Couldn't be a tcp server on port %d: %s\\n\",server_port,strerror(mainsock->errno()));\n    return 1;\n}\nwhile (1)\n{\n    Stdio.File sock=mainsock->accept();\n    if (!sock) break;\n    //sock is the new connection\n    //if you don't do anything and just let sock expire, the client connection will be closed\n}\n//\n//-----------------------------\n"})}),"\n",(0,i.jsx)(e.h2,{id:"communicating-over-tcp",children:"Communicating over TCP"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\nsock->write("What is your name?\\n");\nstring response=sock->read(1024,1); //Reads up to 1KB or whatever is available (minimum 1 byte).\n//Buffered reads:\nStdio.FILE sock2=Stdio.FILE(); sock2->assign(sock);\nstring response=sock2->gets();\n//\n//-----------------------------\n'})}),"\n",(0,i.jsx)(e.h2,{id:"setting-up-a-udp-client",children:"Setting Up a UDP Client"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// UDP Client (Pike 8)\n//-----------------------------\n#pragma strict_types\n#require constant(Stdio.UDP)\n\nint main(int argc, array(string) argv)\n{\n    if (argc < 3) {\n        werror("Usage: %s host port [message]\\n", argv[0]);\n        return 1;\n    }\n\n    string host = argv[1];\n    int port = (int)argv[2];\n    string msg = argc > 3 ? argv[3] : "Hello, UDP!";\n\n    //Create UDP socket\n    Stdio.UDP udp = Stdio.UDP();\n    if (!udp) {\n        werror("Failed to create UDP socket: %s\\n", strerror(errno()));\n        return 1;\n    }\n\n    //Send datagram\n    udp->send(host, port, msg);\n    write("Sent \'%s\' to %s:%d\\n", msg, host, port);\n\n    //Wait for response (with timeout)\n    mixed response = udp->read(1024, ".", 5.0);\n    if (response) {\n        string data = response[0];\n        string from = response[1];\n        write("Received \'%s\' from %s\\n", data, from);\n    } else {\n        write("No response (timeout)\\n");\n    }\n\n    udp->close();\n    return 0;\n}\n//\n//-----------------------------\n'})}),"\n",(0,i.jsx)(e.h2,{id:"setting-up-a-udp-server",children:"Setting Up a UDP Server"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// UDP Server (Pike 8)\n//-----------------------------\n#pragma strict_types\n#require constant(Stdio.UDP)\n\nint main(int argc, array(string) argv)\n{\n    int port = argc > 1 ? (int)argv[1] : 8080;\n\n    //Create and bind UDP socket\n    Stdio.UDP udp = Stdio.UDP();\n    if (!udp->bind(port)) {\n        werror("Failed to bind to port %d: %s\\n", port, strerror(udp->errno()));\n        return 1;\n    }\n\n    write("UDP server listening on port %d\\n", port);\n\n    //Enable broadcast\n    udp->set_option(Stdio.PORT_BROADCAST, 1);\n\n    while (1) {\n        //Read datagram\n        mixed data = udp->read();\n        if (!data) {\n            werror("Read error: %s\\n", strerror(udp->errno()));\n            continue;\n        }\n\n        string msg = data[0];\n        string from = data[1];\n        write("Received \'%s\' from %s\\n", msg, from);\n\n        //Send echo response\n        array addr = from / " ";\n        udp->send(addr[0], (int)addr[1], "Echo: " + msg);\n    }\n\n    udp->close();\n    return 0;\n}\n//\n//-----------------------------\n'})}),"\n",(0,i.jsx)(e.h2,{id:"using-unix-domain-sockets",children:"Using UNIX Domain Sockets"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// UNIX Domain Socket Client (Pike 8)\n//-----------------------------\n#pragma strict_types\n#require constant(Stdio.File)\n\nint main(int argc, array(string) argv)\n{\n    string socket_path = argc > 1 ? argv[1] : "/tmp/mysocket";\n\n    Stdio.File sock = Stdio.File();\n    if (!sock->connect(socket_path)) {\n        werror("Couldn\'t connect to %s: %s\\n",\n              socket_path, strerror(sock->errno()));\n        return 1;\n    }\n\n    sock->write("Hello via UNIX socket!\\n");\n    string response = sock->read();\n    write("Server response: %s\\n", response);\n\n    sock->close();\n    return 0;\n}\n//\n//-----------------------------\n'})}),"\n",(0,i.jsx)(e.h2,{id:"unix-domain-socket-server",children:"UNIX Domain Socket Server"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// UNIX Domain Socket Server (Pike 8)\n//-----------------------------\n#pragma strict_types\n#require constant(Stdio.Port)\n\nint main(int argc, array(string) argv)\n{\n    string socket_path = argc > 1 ? argv[1] : "/tmp/mysocket";\n\n    //Remove old socket file if exists\n    if (file_stat(socket_path)) {\n        rm(socket_path);\n    }\n\n    Stdio.Port port = Stdio.Port();\n    if (!port->bind(socket_path)) {\n        werror("Couldn\'t bind to %s: %s\\n",\n              socket_path, strerror(port->errno()));\n        return 1;\n    }\n\n    write("UNIX domain socket server listening on %s\\n", socket_path);\n\n    while (1) {\n        Stdio.File sock = port->accept();\n        if (!sock) continue;\n\n        string data = sock->read(1024, 1);\n        if (data) {\n            write("Received: %s\\n", data);\n            sock->write("Acknowledged\\n");\n        }\n        sock->close();\n    }\n\n    //Cleanup\n    port->close();\n    rm(socket_path);\n    return 0;\n}\n//\n//-----------------------------\n'})}),"\n",(0,i.jsx)(e.h2,{id:"identifying-the-other-end-of-a-socket",children:"Identifying the Other End of a Socket"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\nstring other_end=sock->query_address(); //eg "10.1.1.1 123"\n//\n//-----------------------------\n'})}),"\n",(0,i.jsx)(e.h2,{id:"finding-your-own-name-and-address",children:"Finding Your Own Name and Address"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Finding Your Own Address (Pike 8)\n//-----------------------------\n#pragma strict_types\n\n//Get local address of a socket\nstring local_addr = sock->query_address(1);\nwrite("Local address: %s\\n", local_addr);\n\n//Get hostname and local IP addresses\nstring hostname = gethostname();\nwrite("Hostname: %s\\n", hostname);\n\n[string host, array ips, array aliases] = gethostbyname(hostname);\nforeach(ips, string ip) {\n    write("Local IP: %s\\n", ip);\n}\n//\n//-----------------------------\n'})}),"\n",(0,i.jsx)(e.h2,{id:"ssltls-sockets",children:"SSL/TLS Sockets"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// SSL/TLS Client (Pike 8)\n//-----------------------------\n#pragma strict_types\n#require constant(SSL.File)\n#require constant(SSL.Context)\n\nint main(int argc, array(string) argv)\n{\n    if (argc < 3) {\n        werror("Usage: %s host port\\n", argv[0]);\n        return 1;\n    }\n\n    string host = argv[1];\n    int port = (int)argv[2];\n\n    //Create SSL context\n    SSL.Context ctx = SSL.Context();\n\n    //Connect to server\n    Stdio.File sock = Stdio.File();\n    if (!sock->connect(host, port)) {\n        werror("Connection failed: %s\\n", strerror(sock->errno()));\n        return 1;\n    }\n\n    //Create SSL connection\n    SSL.File ssl = SSL.File(sock, ctx);\n    int result = ssl->connect();\n    if (result < 0) {\n        werror("SSL handshake failed\\n");\n        return 1;\n    }\n\n    //Send HTTPS request\n    ssl->write("GET / HTTP/1.0\\r\\nHost: " + host + "\\r\\n\\r\\n");\n\n    //Read response\n    string response = ssl->read();\n    write("%s\\n", response);\n\n    ssl->close();\n    return 0;\n}\n//\n//-----------------------------\n'})}),"\n",(0,i.jsx)(e.h2,{id:"ssltls-server",children:"SSL/TLS Server"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// SSL/TLS Server (Pike 8)\n//-----------------------------\n#pragma strict_types\n#require constant(SSL.Port)\n#require constant(SSL.Context)\n\nvoid handle_ssl_client(SSL.File ssl)\n{\n    string data = ssl->read(4096, 1);\n    if (data) {\n        write("Received: %s\\n", data);\n        ssl->write("HTTP/1.0 200 OK\\r\\n\\r\\nSSL Connection Successful!\\n");\n    }\n    ssl->close();\n}\n\nint main(int argc, array(string) argv)\n{\n    int port = argc > 1 ? (int)argv[1] : 8443;\n    string cert_file = "server.pem";\n    string key_file = "server.key";\n\n    //Create SSL context with certificates\n    SSL.Context ctx = SSL.Context();\n    if (file_stat(cert_file)) {\n        ctx->certificates = (([{\n            "cert_file": cert_file,\n            "key_file": key_file\n        }]));\n    }\n\n    //Create SSL port\n    SSL.Port ssl_port = SSL.Port(ctx);\n    if (!ssl_port->bind(port, handle_ssl_client)) {\n        werror("Failed to bind SSL port: %s\\n", strerror(ssl_port->errno()));\n        return 1;\n    }\n\n    write("SSL server listening on port %d\\n", port);\n\n    //Keep server running\n    while (1) {\n        sleep(1);\n    }\n\n    return 0;\n}\n//\n//-----------------------------\n'})}),"\n",(0,i.jsx)(e.h2,{id:"closing-a-socket-after-forking",children:"Closing a Socket After Forking"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\nsock->close("r");   //Close the read direction\nsock->close("w");   //Close the write direction\nsock->close("rw");  //Shut down both directions\nsock->close();      //Close completely\n//\n//-----------------------------\n'})}),"\n",(0,i.jsx)(e.h2,{id:"writing-bidirectional-clients",children:"Writing Bidirectional Clients"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Bidirectional Client (Pike 8)\n//-----------------------------\n#pragma strict_types\n#require constant(Stdio.File)\n\nvoid read_from_server(Stdio.File sock)\n{\n    while (1) {\n        string data = sock->read(1024, 1);\n        if (!data || !sizeof(data)) break;\n        write("Server: %s\\n", data);\n    }\n    sock->close("r");\n}\n\nint main(int argc, array(string) argv)\n{\n    if (argc < 3) {\n        werror("Usage: %s host port\\n", argv[0]);\n        return 1;\n    }\n\n    Stdio.File sock = Stdio.File();\n    if (!sock->connect(argv[1], (int)argv[2])) {\n        werror("Connection failed\\n");\n        return 1;\n    }\n\n    //Start thread to read from server\n    Thread.Thread create_thread = Thread.Thread(read_from_server, sock);\n\n    //Read from stdin and send to server\n    while (string line = Stdio.stdin->gets()) {\n        sock->write(line + "\\n");\n    }\n\n    sock->close("w");\n    create_thread->wait();\n    return 0;\n}\n//\n//-----------------------------\n'})}),"\n",(0,i.jsx)(e.h2,{id:"non-blocking-io-with-select",children:"Non-Blocking I/O with select()"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Non-blocking I/O with select() (Pike 8)\n//-----------------------------\n#pragma strict_types\n#require constant(Stdio.File)\n\nint main(int argc, array(string) argv)\n{\n    int port = argc > 1 ? (int)argv[1] : 8080;\n\n    Stdio.Port listen_sock = Stdio.Port();\n    if (!listen_sock->bind(port)) {\n        werror("Bind failed: %s\\n", strerror(listen_sock->errno()));\n        return 1;\n    }\n\n    array(Stdio.File) clients = (({}));\n    write("Multiplexed server on port %d\\n", port);\n\n    while (1) {\n        //Build read set\n        array read_fds = clients + (({listen_sock}));\n\n        //Wait for activity\n        mixed ready = Stdio.select(read_fds);\n        if (!ready || !sizeof(ready[0])) continue;\n\n        //Check for new connections\n        if (has_value(ready[0], listen_sock)) {\n            Stdio.File new_client = listen_sock->accept();\n            if (new_client) {\n                clients += (({new_client}));\n                write("New client: %s\\n", new_client->query_address());\n            }\n        }\n\n        //Check clients for data\n        foreach(clients, int i, Stdio.File client) {\n            if (has_value(ready[0], client)) {\n                string data = client->read(1024, 1);\n                if (!data || !sizeof(data)) {\n                    //Client disconnected\n                    write("Client disconnected\\n");\n                    client->close();\n                    clients = clients[..i-1] + clients[i+1..];\n                } else {\n                    write("Received: %s\\n", data);\n                    client->write("Echo: " + data);\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n//\n//-----------------------------\n'})}),"\n",(0,i.jsx)(e.h2,{id:"forking-servers",children:"Forking Servers"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:"//-----------------------------\n\n//Forking is generally unnecessary in Pike, as the driver works more efficiently with other models.\n//\n//-----------------------------\n"})}),"\n",(0,i.jsx)(e.h2,{id:"socket-options-and-configuration",children:"Socket Options and Configuration"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Socket Options and Configuration (Pike 8)\n//-----------------------------\n#pragma strict_types\n\n//Creating a socket with options\nStdio.Port port = Stdio.Port();\n\n//Set SO_REUSEADDR to allow quick restart\nport->set_option(Stdio.PORT_REUSE_ADDRESS, 1);\n\n//Set SO_KEEPALIVE for connection monitoring\nStdio.File sock = Stdio.File();\nsock->set_option(Stdio.KEEPALIVE, 1);\n\n//Set TCP_NODELAY to disable Nagle\'s algorithm (for real-time apps)\nsock->set_option(Stdio.NO_DELAY, 1);\n\n//Set socket buffer sizes\nsock->set_buffer(65536, 65536); //read_buf, write_buf\n\n//Set socket timeout\nsock->set_nonblocking(1, 0, 0); //nonblocking mode\n\n//Enable broadcast for UDP\nStdio.UDP udp = Stdio.UDP();\nudp->set_option(Stdio.PORT_BROADCAST, 1);\nudp->set_option(Stdio.MULTICAST, 1);\n\n//Bind to specific interface\nport->bind(8080, 0, "127.0.0.1");\n\n//\n//-----------------------------\n'})}),"\n",(0,i.jsx)(e.h2,{id:"modern-async-with-concurrentfuture",children:"Modern Async with Concurrent.Future"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Modern async socket I/O with Concurrent.Future (Pike 8)\n//-----------------------------\n#pragma strict_types\n#require constant(Concurrent.Future)\n#require constant(Stdio.File)\n\n//Async HTTP GET using Future\nConcurrent.Future async_http_get(string host, int port)\n{\n    Concurrent.Promise result = Concurrent.Promise();\n\n    thread_create(lambda() {\n        Stdio.File sock = Stdio.File();\n        if (!sock->connect(host, port)) {\n            result->failure(([{"error": "Connection failed"}]));\n            return;\n        }\n\n        sock->write("GET / HTTP/1.0\\r\\nHost: " + host + "\\r\\n\\r\\n");\n        string response = sock->read();\n        sock->close();\n\n        result->success(response);\n    });\n\n    return result->future();\n}\n\nint main()\n{\n    //Use the future\n    Concurrent.Future f = async_http_get("example.com", 80);\n\n    f->on_success(lambda(string response) {\n        write("Got response of %d bytes\\n", sizeof(response));\n    });\n\n    f->on_failure(lambda(mapping err) {\n        werror("Request failed: %s\\n", err->error);\n    });\n\n    //Wait for completion\n    mixed result = f->wait();\n    return 0;\n}\n//\n//-----------------------------\n'})}),"\n",(0,i.jsx)(e.h2,{id:"pre-forking-servers",children:"Pre-Forking Servers"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:"//-----------------------------\n// Connection Pool (Pike 8)\n//-----------------------------\n#pragma strict_types\n#require constant(Stdio.File)\n#require constant(Thread.Mutex)\n\nclass ConnectionPool {\n    private string host;\n    private int port;\n    private array(Stdio.File) connections = (({}));\n    private int max_size;\n    private Thread.Mutex lock = Thread.Mutex();\n\n    void create(string _host, int _port, int _max_size)\n    {\n        host = _host;\n        port = _port;\n        max_size = _max_size;\n    }\n\n    Stdio.File acquire()\n    {\n        mixed key = lock->lock();\n        Stdio.File sock;\n\n        if (sizeof(connections)) {\n            sock = connections[0];\n            connections = connections[1..];\n        } else {\n            sock = Stdio.File();\n            if (!sock->connect(host, port)) {\n                lock->unlock();\n                return 0;\n            }\n        }\n\n        lock->unlock();\n        return sock;\n    }\n\n    void release(Stdio.File sock)\n    {\n        mixed key = lock->lock();\n\n        if (sizeof(connections) < max_size) {\n            connections += (({sock}));\n        } else {\n            sock->close();\n        }\n\n        lock->unlock();\n    }\n}\n//\n//-----------------------------\n"})}),"\n",(0,i.jsx)(e.h2,{id:"non-forking-servers",children:"Non-Forking Servers"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:"//-----------------------------\n\n//Incomplete. There's multiple ways to do this, including:\n//1) Threaded server (works like forking but clients can share global state if desired)\n//2) Multiplexing using select()\n//3) Callback mode (puts the sockets under the control of a Backend which uses select())\n//\n//-----------------------------\n"})}),"\n",(0,i.jsx)(e.h2,{id:"writing-a-multi-homed-server",children:"Writing a Multi-Homed Server"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\nStdio.Port mainsock=Stdio.Port();\nif (!mainsock->bind(server_port))\n{\n    werror("Couldn\'t be a tcp server on port %d: %s\\n",server_port,strerror(mainsock->errno()));\n    return 1;\n}\nwhile (1)\n{\n    Stdio.File sock=mainsock->accept();\n    if (!sock) break;\n    string localaddr=sock->query_address(1); //Is the IP address and port connected to.\n    //The IP will be that of one of your interfaces, and the port should be equal to server_port\n}\n//\n//-----------------------------\n'})}),"\n",(0,i.jsx)(e.h2,{id:"making-a-daemon-server",children:"Making a Daemon Server"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\nif (!System.chroot("/var/daemon")) werror("Unable to chroot to /var/daemon: %s\\n",strerror(errno()));\n//Incomplete (I don\'t fork in Pike). See predef::fork() and Process.create_process() for details.\n//\n//-----------------------------\n'})}),"\n",(0,i.jsx)(e.h2,{id:"restarting-a-server-on-demand",children:"Restarting a Server on Demand"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:"//-----------------------------\n//The best way to restart the server is to adopt a microkernel concept and restart only the parts of\n//the server that need updating. However, if you must reload, see Process.exec()\n//\n//-----------------------------\n"})}),"\n",(0,i.jsx)(e.h2,{id:"program-backsniff",children:"Program: backsniff"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// backsniff - Simple port scanner detector (Pike 8)\n//-----------------------------\n#pragma strict_types\n#require constant(Stdio.Port)\n\nint main(int argc, array(string) argv)\n{\n    int port = argc > 1 ? (int)argv[1] : 8080;\n\n    Stdio.Port listen = Stdio.Port();\n    if (!listen->bind(port)) {\n        werror("Bind failed\\n");\n        return 1;\n    }\n\n    write("backsniff listening on port %d\\n", port);\n\n    while (1) {\n        Stdio.File sock = listen->accept();\n        if (!sock) continue;\n\n        string remote = sock->query_address();\n        write("Connection from: %s at %s\\n", remote, ctime(time()));\n\n        //Log and close\n        sock->close();\n    }\n\n    return 0;\n}\n//\n//-----------------------------\n'})}),"\n",(0,i.jsx)(e.h2,{id:"program-fwdport",children:"Program: fwdport"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// fwdport - TCP port forwarder (Pike 8)\n//-----------------------------\n#pragma strict_types\n#require constant(Stdio.Port)\n#require constant(Stdio.File)\n\nvoid forward_data(Stdio.File client, Stdio.File target)\n{\n    string data = client->read(8192, 1);\n    while (data && sizeof(data)) {\n        target->write(data);\n        data = client->read(8192, 1);\n    }\n    target->close("w");\n}\n\nvoid handle_client(Stdio.File client, string target_host, int target_port)\n{\n    Stdio.File target = Stdio.File();\n    if (!target->connect(target_host, target_port)) {\n        werror("Failed to connect to target\\n");\n        client->close();\n        return;\n    }\n\n    //Create threads for bidirectional forwarding\n    Thread.Thread t1 = Thread.Thread(forward_data, client, target);\n    ;\n    Thread.Thread t2 = Thread.Thread(forward_data, target, client);\n    ;\n\n    t1->wait();\n    t2->wait();\n\n    client->close();\n    target->close();\n}\n\nint main(int argc, array(string) argv)\n{\n    if (argc < 4) {\n        werror("Usage: %s listen_port target_host target_port\\n", argv[0]);\n        return 1;\n    }\n\n    int listen_port = (int)argv[1];\n    string target_host = argv[2];\n    int target_port = (int)argv[3];\n\n    Stdio.Port listen = Stdio.Port();\n    if (!listen->bind(listen_port)) {\n        werror("Bind failed on port %d\\n", listen_port);\n        return 1;\n    }\n\n    write("Forwarding %d -> %s:%d\\n", listen_port, target_host, target_port);\n\n    while (1) {\n        Stdio.File client = listen->accept();\n        if (!client) continue;\n\n        //Handle client in thread\n        Thread.Thread(handle_client, client, target_host, target_port);\n    }\n\n    return 0;\n}\n//\n//-----------------------------\n'})})]})}function g(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(l,{...n})}):l(n)}},8453(n,e,r){r.d(e,{R:()=>s,x:()=>a});var t=r(6540);const i={},o=t.createContext(i);function s(n){const e=t.useContext(o);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:s(n.components),t.createElement(o.Provider,{value:e},n.children)}}}]);