"use strict";(self.webpackChunkpike_cookbook=self.webpackChunkpike_cookbook||[]).push([[851],{5173(e,n,r){r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>s,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"basics/arrays","title":"Arrays","description":"Introduction","source":"@site/docs/basics/arrays.md","sourceDirName":"basics","slug":"/basics/arrays","permalink":"/pike-cookbook/docs/basics/arrays","draft":false,"unlisted":false,"editUrl":"https://github.com/smuks/pike-cookbook/tree/main/docs/basics/arrays.md","tags":[],"version":"current","frontMatter":{"id":"arrays","title":"Arrays","sidebar_label":"Arrays"},"sidebar":"tutorialSidebar","previous":{"title":"Numbers","permalink":"/pike-cookbook/docs/basics/numbers"},"next":{"title":"Hashes","permalink":"/pike-cookbook/docs/basics/hashes"}}');var i=r(4848),t=r(8453);const s={id:"arrays",title:"Arrays",sidebar_label:"Arrays"},o=void 0,l={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Specifying a List In Your Program",id:"specifying-a-list-in-your-program",level:2},{value:"Printing a List with Commas",id:"printing-a-list-with-commas",level:2},{value:"Changing Array Size",id:"changing-array-size",level:2},{value:"Doing Something with Every Element in a List",id:"doing-something-with-every-element-in-a-list",level:2},{value:"Iterating Over an Array by Reference",id:"iterating-over-an-array-by-reference",level:2},{value:"Extracting Unique Elements from a List",id:"extracting-unique-elements-from-a-list",level:2},{value:"Finding Elements in One Array but Not Another",id:"finding-elements-in-one-array-but-not-another",level:2},{value:"Computing Union, Intersection, or Difference of Unique Lists",id:"computing-union-intersection-or-difference-of-unique-lists",level:2},{value:"Appending One Array to Another",id:"appending-one-array-to-another",level:2},{value:"Reversing an Array",id:"reversing-an-array",level:2},{value:"Processing Multiple Elements of an Array",id:"processing-multiple-elements-of-an-array",level:2},{value:"Finding the First List Element That Passes a Test",id:"finding-the-first-list-element-that-passes-a-test",level:2},{value:"Finding All Elements in an Array Matching Certain Criteria",id:"finding-all-elements-in-an-array-matching-certain-criteria",level:2},{value:"Sorting an Array Numerically",id:"sorting-an-array-numerically",level:2},{value:"Sorting a List by Computable Field",id:"sorting-a-list-by-computable-field",level:2},{value:"Implementing a Circular List",id:"implementing-a-circular-list",level:2},{value:"Randomizing an Array",id:"randomizing-an-array",level:2},{value:"Program: words",id:"program-words",level:2},{value:"Program: permute",id:"program-permute",level:2}];function m(e){const n={code:"code",h2:"h2",pre:"pre",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-pike",children:'// nested arrays are supported\narray flat = ({ "this", "that", "the", "other" });\narray nested = ({ "this", "that", ({ "the", "other" }) });\narray tune = ({ "The", "Star-Spangled", "Banner" });\ntune[0];\n// Result: "The"\ntune[1];\n// Result: "Star-Spangled"\n// the typing may be more specific\n// only strings allowed in the array (thus no nesting!)\narray(string) flat = ({ "this", "that", "the", "other" });\n// allow one level of nesting\narray(string|array(string)) admit1 = ({ "this", "that", ({ "the", "other" }) });\n// the first level may only contain arrays, other levels may contain anything\narray(array) require1 ({ ({ "this", "that" }), ({ "the", "other" }) });\n'})}),"\n",(0,i.jsx)(n.h2,{id:"specifying-a-list-in-your-program",children:"Specifying a List In Your Program"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-pike",children:'// list\narray(string) a = ({ "quick", "brown", "fox" });\n// words\narray(string) a = "Why are you teasing me?"/" ";\n// lines\narray(string) lines = #"The boy stood on the burning deck,\nIt was as hot as glass."/"\\n";\n// file\narray(string) bigarray = Stdio.read_file("mydatafile")/"\\n";\n// the quoting issues do not apply.\narray(string) ships = "Ni\xf1a Pinta Santa Mar\xeda"/" ";         // wrong\narray(string) ships = ({ "Ni\xf1a", "Pinta", "Santa Mar\xeda" }); // right\n'})}),"\n",(0,i.jsx)(n.h2,{id:"printing-a-list-with-commas",children:"Printing a List with Commas"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-pike",children:'// download the following standalone program\n#!/usr/bin/pike\n// chapter 4.2\n// commify_series - show proper comma insertion in list output\narray(array(string)) lists =\n({\n({ "just one thing" }),\n({ "Mutt", "Jeff" }),\n({ "Peter", "Paul", "Mary" }),\n({ "To our parents", "Mother Theresa", "God" }),\n({ "pastrami", "ham and cheese", "peanut butter and jelly", "tuna" }),\n({ "recycle tired, old phrases", "ponder big, happy thoughts" }),\n({ "recycle tired, old phrases",\n"ponder big, happy thoughts",\n"sleep and dream peacefully" }),\n});\nvoid main()\n{\nwrite("The list is: %s.\\n", commify_list(lists[*])[*]);\n}\nstring commify_list(array(string) list)\n{\nswitch(sizeof(list))\n{\ncase 1: return list[0];\ncase 2: return sprintf("%s and %s", @list);\ndefault:\nstring seperator=",";\nint count;\nwhile(count<sizeof(list) && search(list[count], seperator)==-1)\ncount++;\nif(count<sizeof(list))\nseperator=";";\nreturn sprintf("%{%s"+seperator+" %}and %s",\nlist[..sizeof(list)-2], list[-1]);\n}\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"changing-array-size",children:"Changing Array Size"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-pike",children:'void what_about_that_array(array list)\n{\nwrite("The array now has %d elements.\\n", sizeof(list));\nwrite("The index of the last element is %d.\\n", sizeof(list)-1);\nwrite("Element #3 is %O.\\n", list[3]);\n}\narray people = ({ "Crosby", "Stills", "Nash", "Young" });\nwhat_about_that_array(people);\n// The array now has 4 elements.\n// The index of the last element is 3.\n// Element #3 is "Young".\npeople=people[..sizeof(people)-2];\nwhat_about_that_array(people);\n// The array now has 3 elements.\n// The index of the last element is 2.\n// Index 3 is out of array range -3..2.\npeople+=allocate(10001-sizeof(people));\nwhat_about_that_array(people);\n// The array now has 10001 elements.\n// The index of the last element is 10000.\n// Element #3 is 0.\narray people = ({ "Crosby", "Stills", "Nash", "Young" }); // resetting the array\npeople[10000]=0;\n// Index 10000 is out of array range -4..3.\n// accessing a nonexisting index is always an error.\n// arrays can not be enlarged this way.\n'})}),"\n",(0,i.jsx)(n.h2,{id:"doing-something-with-every-element-in-a-list",children:"Doing Something with Every Element in a List"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-pike",children:'foreach(list; int index; mixed item)\n{\n// do something with item (and possibly index)\n}\nforeach(bad_users;; object user)\n{\ncomplain(user);\n}\n// for such simple cases pike provides a convenient automap feature:\ncomplain(bad_users[*]);\n// will do the same as the foreach above.\nforeach(sort(indices(getenv()));; string var)\n{\nwrite("%s=%s\\n", var, getenv(var));\n}\n// if you don\'t need an assurance that the indices are sorted (they most likely\n// are sorted anyways) you may use:\nforeach(getenv(); string var; string value)\n{\nwrite("%s=%s\\n", var, value);\n}\nforeach(all_users;; string user)\n{\nint disk_space = get_usage(user);\nif(disk_space > MAX_QUOTA)\ncomplain(user);\n}\n// continue; to jump to the next\n// break; to stop the loop\n// redo can be done by doing a loop with the proper checks in the block\nobject pipe=Stdio.File();\nProcess.create_process(({ "who" }), ([ "stdout":pipe->pipe() ]));\nforeach(pipe->line_iterator();; string line)\n{\nif(search(line, "tchrist")>-1)\nwrite(line+"\\n");\n}\nobject fh=Stdio.File("somefile");\nforeach(fh->line_iterator(); int linenr; string line)\n{\nforeach(Process.split_quoted_string(line);; string word)//split on whitespace\n{\nwrite(reverse(word));\n}\n}\narray(int) list = ({ 1,2,3 });\nforeach(list;; int item)\n{\nitem--;\n}\nwrite("%{%d %}\\n", list);\n// Result: 1 2 3\n// we can still use foreach instead of for,\n// because foreach gives us the index as well:\nforeach(list; int index;)\n{\nlist[index]--;\n}\nwrite("%{%d %}\\n", list);\n// Result: 0 1 2\narray a = ({ 0.5, 3 });\narray b = ({ 0, 1 });\n// foreach handles only one array so there is nothing to gain here.\n// better use automap:\narray a_ = a[*]*7;\narray b_ = b[*]*7;\nwrite("%{%O %}\\n", a_+b_);\n// 3.500000 21 0 7\nstring scalar = " abc ";\narray(string) list = ({ " a ", " b " });\nmapping(mixed:string) hash = ([ "a":" a ", "b":" b " ]);\nscalar = String.trim_whites(scalar);\nlist = String.trim_whites(list[*]);\nforeach(hash; int key;)\n{\nhash[key]=String.trim_whites(hash[key]);\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"iterating-over-an-array-by-reference",children:"Iterating Over an Array by Reference"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-pike",children:"// pike does not distinguish between arrays and array references\n// (they are all references anyways) so this section does not apply\n"})}),"\n",(0,i.jsx)(n.h2,{id:"extracting-unique-elements-from-a-list",children:"Extracting Unique Elements from a List"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-pike",children:'mapping seen = ([]);\narray   uniq = ({});\nforeach(list;; mixed item)\n{\nif(!seen[item])\nseen[item] = 1;\nelse\nuniq += ({ item });\n}\nmapping seen = ([]);\narray   uniq = ({});\nforeach(list;; mixed item)\n{\nif(!seen[item]++)\nuniq += ({ item });\n}\nmapping seen = ([]);\narray   uniq = ({});\nforeach(list;; mixed item)\n{\nif(!seen[item]++)\nsome_func(item);\n}\n// the following is probably the most natural for pike\nmapping seen = ([]);\narray   uniq = ({});\nforeach(list;; mixed item)\n{\nseen[item]++;\n}\nuniq = indices(seen);\n// not necessarily faster but shorter:\narray uniq = indices(({ list[*],1 }));\n// also short, and preserving the originaal order:\narray uniq = list&indices(({ list[*],1 }));\nobject pipe = Stdio.File();\nProcess.create_process(({ "who" }), ([ "stdout":pipe->pipe() ]));\nmapping ucnt = ([]);\nforeach(pipe->line_iterator();; string line)\n{\nucnt[(line/" ")[0]]++;\n}\narray users = sort(indices(ucnt));\nwrite("users logged in: %s\\n", users*" ");\n'})}),"\n",(0,i.jsx)(n.h2,{id:"finding-elements-in-one-array-but-not-another",children:"Finding Elements in One Array but Not Another"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-pike",children:"// one of pikes strenghts are operators.\n// the following are the only idiomatic solutions to the problem\narray A = ({ 1, 2, 3 });\narray B = ({ 2, 3, 4 });\narray aonly = A-B;\n// Result: ({ 1 });\n"})}),"\n",(0,i.jsx)(n.h2,{id:"computing-union-intersection-or-difference-of-unique-lists",children:"Computing Union, Intersection, or Difference of Unique Lists"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-pike",children:"array a = ({ 1, 3, 5, 6, 7, 8 });\narray b = ({ 2, 3, 5, 7, 9 });\n// union:\narray union = a|b;\n// ({ 1, 3, 5, 6, 7, 8, 2, 9 })\n// intersection\narray intersection = a&b;\n// ({ 3, 5, 7 })\n// difference\narray difference = a-b;\n// ({ 1, 6, 8 })\n// symetric difference\narray symdiff= a^b;\n// ({ 1, 6, 8, 2, 9 })\n"})}),"\n",(0,i.jsx)(n.h2,{id:"appending-one-array-to-another",children:"Appending One Array to Another"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-pike",children:'// join arrays\n// appending to an array will always create a new array and pike is designed to\n// handle this efficiently.\narray members = ({ "Time", "Flies" });\narray initiates = ({ "An", "Arrow" });\nmembers += initiates;\n// members is now ({ "Time", "Flies", "An", "Arrow" })\nmembers = members[..1]+({ "Like" })+members[2..];\nwrite("%s\\n", members*" ");\nmembers[0] = "Fruit";\nmembers = members[..sizeof(members)-3]+({ "A", "Banana" });\nwrite("%s\\n", members*" ");\n// Time Flies Like An Arrow\n// Fruit Flies Like A Banana\n'})}),"\n",(0,i.jsx)(n.h2,{id:"reversing-an-array",children:"Reversing an Array"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-pike",children:"// almost any operation you do on the elements will add more overhead than\n// reversing the array, if there is any possible optimization, pike will do it\n// for you.\narray reversed = reverse(arr);\n// unless you were going to use for anyways then foreach(reverse( ...)) is\n// preferable.\nforeach(reverse(arr);; mixed item)\n{\n// do something with item\n}\nfor(int i=sizeof(arr)-1; i<=0; i--)\n{\n// so something with arr[i]\n}\narray ascending = sort(users);\narray descending = reverse(sort(users));\n// reverse(sort()) is faster by a magnitude\narray descending = Array.sort_array(users, lambda(mixed a, mixed b)\n{\nreturn a<b;\n}\n);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"processing-multiple-elements-of-an-array",children:"Processing Multiple Elements of an Array"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-pike",children:'array arr = ({ 0,1,2,3,4,5,6,7,8,9 });\nint n=3;\narray front = arr[..n-1];\narr = arr[n..];\narray back = arr[sizeof(arr)-n..];\narr = arr[..sizeof(arr)-(n+1)];\n// since new arrays are created if elements are added or removed\n// shift and pop are not usefull here.\n// if you need shift and pop capabilities use the ADT classes:\narray shift2(ADT.Queue queue)\n{\nreturn ({ queue->read(), queue->read() });\n}\nADT.Queue friends = ADT.Queue("Peter", "Paul", "Mary", "Jim", "Tim");\nstring this, that;\n[this, that] = shift2(friends);\n// this contains Peter, that has Paul, and\n// friends has Mary, Jim, and Tim\nADT.Stack beverages = ADT.Stack();\nbeverages->set_stack(({ "Dew", "Jolt", "Cola", "Sprite", "Fresca" }));\narray pair = beverages->pop(2); // implementing pop2 would gain nothing here\n// pair[0] contains Sprite, pair[1] has Fresca,\n// and beverages has (Dew, Jolt, Cola)\n// to be able to shift and pop on the same list use the following:\narray shift2(ADT.CircularList list)\n{\nreturn ({ list->pop_front(), list->pop_front() });\n}\narray pop2(ADT.CircularList list)\n{\nreturn reverse( ({ list->pop_back(), list->pop_back() }) );\n}\nADT.CircularList friends = ADT.CircularList( ({"Peter", "Paul", "Mary", "Jim", "Tim"}) );\nstring this, that;\n[this, that] = shift2(friends);\n// this contains Peter, that has Paul, and\n// friends has Mary, Jim, and Tim\nADT.CircularList beverages = ADT.CircularList( ({ "Dew", "Jolt", "Cola", "Sprite", "Fresca" }) );\narray pair = pop2(beverates);\n// pair[0] contains Sprite, pair[1] has Fresca,\n// and beverages has (Dew, Jolt, Cola)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"finding-the-first-list-element-that-passes-a-test",children:"Finding the First List Element That Passes a Test"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-pike",children:"mixed match = search(arr, element);\nint test(mixed element)\n{\nif(sizeof(element)==5)\nreturn 1;\nelse\nreturn 0;\n}\nmixed match = Array.search_array(arr, test);\nif(match != -1)\n{\n// do something with arr[match]\n}\nelse\n{\n// do something else\n}\n// another convenient way if you do many tests on the same list,\n// and you do not care for the position is:\nif( (multiset)arr[element] )\n{\n// found\n}\nelse\n{\n// not found\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"finding-all-elements-in-an-array-matching-certain-criteria",children:"Finding All Elements in an Array Matching Certain Criteria"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-pike",children:"array matching=({});\nforeach(list;; mixed element)\n{\nif(test(element))\nmatching+=({ element });\n}\narray matching = map(list, test)-({ 0 });\narray matching = test(list[*])-({ 0 });\n// apply test() on each element in list, collect the results, and remove\n// results that are 0.\n"})}),"\n",(0,i.jsx)(n.h2,{id:"sorting-an-array-numerically",children:"Sorting an Array Numerically"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-pike",children:'// since pike has different types for strings and numbers, ints and floats are\n// of course sorted numerically\n// (sort() is destructive, the original array is changed)\narray(int) unsorted = ...;\narray(int) sorted = sort(unsorted);\n// but suppose you want to sort an array of strings by their numeric value then\n// things get a bit more interresting:\narray(string) unsorted = ({ "123asdf", "3poiu", "23qwert", "3ayxcv" });\nsort((array(int))unsorted, unsorted);\n// unsorted is now sorted.\n'})}),"\n",(0,i.jsx)(n.h2,{id:"sorting-a-list-by-computable-field",children:"Sorting a List by Computable Field"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-pike",children:'array unordered;\nint compare(mixed a, mixed b)\n{\n// return comparison of a and b\n}\narray ordered = Array.sort_array(unordered, compare);\n//-------------------------------------------------------------\nint compute(mixed element)\n{\n// return computation from element\n}\narray precomputed = map(unordered, compute);\nsort(precomputed, unordered); // will destructively sort unordered in the same\narray ordered = unordered;    // manner as precomputed.\n//-------------------------------------------------------------\nsort(map(unordered, compute), unordered); // without a temp variable\nsort(compute(unordered[*]), unordered);   // using the automap operator\n// both get compiled to the same code\n//-------------------------------------------------------------\narray ordered = sort(employees, lambda(mixed a, mixed b)\n{\nreturn a->name > b->name;\n}\n);\n//-------------------------------------------------------------\nforeach(Array.sort_array(employees,\nlambda(mixed a, mixed b){ return a->name > b->name; })\n;; mixed employee)\n{\nwrite("%s earns $%d\\n", employee->name, employee->salary);\n}\n//-------------------------------------------------------------\narray ordered_employees =\nArray.sort_array(employees,\nlambda(mixed a, mixed b){ return a->name > b->name; });\nforeach(ordered_employees;; mixed employee)\n{\nwrite("%s earns $%d\\n", employee->name, employee->salary);\n}\nmapping bonus;\nforeach(ordered_employees;; mixed employee)\n{\n// you are not supposed to use the social security number as an id\nif(bonus[employee->id])\nwrite("%s got a bonus!\\n", employee->name);\n}\n//-------------------------------------------------------------\narray sorted = Array.sort_array(employees,\nlambda(mixed a, mixed b)\n{\nif(a->name!=b->name)\nreturn (a->name < b->name)\nreturn (b->age < a->age);\n}\n);\n//-------------------------------------------------------------\narray(array) users = System.get_all_users();\nsort(users);\n// System.get_all_users() returns an array of arrays, with the name as the\n// first element in each inner array, sort handles multidimensional arrays, so\n// we can skip creating our own sort function.\n// if we wanted to sort on something else one could rearrange the array:\narray user;\nwhile(user=System.getpwent())\n{\nusers += ({ user[2], user });\n}\nSystem.endpwent();\nsort(users);  // now we are sorting by uid.\n// alternative:\narray(array) users = System.get_all_users();\nsort(users[*][2], users);\nwrite(users[*][0]*"\\n");\nwrite("\\n");\n//-------------------------------------------------------------\narray names;\narray sorted = Array.sort_array(names, lambda(mixed a, mixed b)\n{\nreturn a[1] < b[1];\n}\n);\n// faster:\nsort(names[*][1], names);\nsorted=names;\n//-------------------------------------------------------------\narray strings;\narray sorted = Array.sort_array(strings, lambda(mixed a, mixed b)\n{\nreturn sizeof(a) < sizeof(b);\n}\n);\n// faster:\nsort(sizeof(strings[*]), strings);\nsorted=strings;\n//-------------------------------------------------------------\narray strings;\narray temp = map(strings, sizeof);\nsort(temp, strings);\narray sorted = strings;\n//-------------------------------------------------------------\narray strings;\nsort(map(strings, sizeof), strings);   // pick one\nsort(sizeof(strings[*]), strings);\nsorted=strings;\n//-------------------------------------------------------------\narray fields;\narray temp = map(fields, array_sscanf, "%*s%d%*s");\nsort(temp, fields);\narray sorted_fields=fields;\n//-------------------------------------------------------------\nsort(array_sscanf(fields[*], "%*s%d%*s"), fields);\narray sorted_fields=fields;\n//-------------------------------------------------------------\narray passwd_lines = (Stdio.read_file("/etc/passwd")/"\\n")-({""});\narray(array) passwd = passwd_lines[*]/":";\nint compare(mixed a, mixed b)\n{\nif(a[3]!=b[3])\nreturn (int)a[3]<(int)b[3];\nif(a[2]!=b[2])\nreturn (int)a[2]<(int)b[2];\nreturn a[0]<b[0];\n}\narray sorted_passwd = Array.sort_array(passwd, compare);\n// alternatively the following uses the builtin sort\nsort( passwd[*][0], passwd);\nsort( ((array(int))passwd[*][2]), passwd);\nsort( ((array(int))passwd[*][3]), passwd);\n'})}),"\n",(0,i.jsx)(n.h2,{id:"implementing-a-circular-list",children:"Implementing a Circular List"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-pike",children:'ADT.CircularList circular;\ncircular->push_front(circular->pop_back());\ncircular->push_back(circular->pop_front());\n//-------------------------------------------------------------\nmixed grab_and_rotate(ADT.CircularList list)\n{\nmixed element = list->pop_front();\nlist->push_back(element);\nreturn element;\n}\nADT.CircularList processes = ADT.CircularList( ({ 1, 2, 3, 4, 5 }) );\nwhile(1)\n{\nint process = grab_and_rotate(processes);\nwrite("Handling process %d\\n", process);\nsleep(1);\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"randomizing-an-array",children:"Randomizing an Array"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-pike",children:'array arr;\nArray.shuffle(arr);  // this uses the fisher-yates shuffle\n//-------------------------------------------------------------\n// being creative with the algorithm, this is not as memory efficient,\n// but it shows the utility of multisets.\narray set_shuffle(array list)\n{\nmultiset elements=(multiset)list;\nlist=({});                     // reset the list\nwhile(sizeof(elements))        // while we still have elements left\n{\nmixed pick=random(elements); // pick a random element\nlist+=({ pick });            // add it to the new list\nelements[pick]--;            // remove the element we picked\n}\nreturn list;\n}\narray list;\nlist=set_shuffle(list);\n//-------------------------------------------------------------\ninherit "mjd_permute";\nint permutations = factorial(sizeof(list));\narray shuffle = list[n2perm(random(permutations)+1, sizeof(list))[*]];\n//-------------------------------------------------------------\nvoid naive_shuffle(array list)\n{\nfor(int i=0; i<sizeof(list); i++)\n{\nint j=random(sizeof(list)-1);\n[ list[i], list[j] ] = ({ list[j], list[i] });\n}\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"program-words",children:"Program: words"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-pike",children:'// download the following standalone program\n#!/usr/bin/pike\n// section 4.18 example 4.2\n// words - gather lines, present in columns\nvoid main()\n{\narray words=Stdio.stdin.read()/"\\n";   // get all input\nint maxlen=sort(sizeof(words[*]))[-1]; // sort by size and pick the largest\nmaxlen++;                              // add space\n// get boundaries, this should be portable\nint cols = Stdio.stdout->tcgetattr()->columns/maxlen;\nint rows = (sizeof(words)/cols) + 1;\nstring mask="%{%-"+maxlen+"s%}\\n";     // compute format\nwords=Array.transpose(words/rows);     // split into groups as large as the\n// number of rows and then transpose\nwrite(mask, words[*]);                 // apply mask to each group\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"program-permute",children:"Program: permute"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-pike",children:'int factorial(int n)\n{\nint s=1;\nwhile(n)\ns*=n--;\nreturn s;\n}\nwrite("%d\\n", factorial(500));\n// Using Array.permute() to generate all permutations\n// -------------------------------------------------------------\n// Example: Generate all permutations of an array using Array.permute()\n// Note: Array.permute() returns all possible orderings of array elements\nimport Array;\n// Simple permutation example\narray(string) fruits = ({"apple", "banana", "cherry"});\narray(array(string)) perms = permute(fruits);\nforeach(perms, array(string) p)\n{\nwrite("%s\\n", p*", ");\n}\n// Output:\n// apple, banana, cherry\n// apple, cherry, banana\n// banana, apple, cherry\n// banana, cherry, apple\n// cherry, apple, banana\n// cherry, banana, apple\n//-------------------------------------------------------------\n// download the following standalone program\n#!/usr/bin/pike\nvoid main()\n{\nstring line;\nwhile(line=Stdio.stdin->gets())\n{\npermute(line/" ");\n}\n}\nvoid permute(array items, array|void perms)\n{\nif(!perms)\nperms=({});\nif(!sizeof(items))\nwrite((perms*" ")+"\\n");\nelse\n{\nforeach(items; int i;)\n{\narray newitems=items[..i-1]+items[i+1..];\narray newperms=items[i..i]+perms;\npermute(newitems, newperms);\n}\n}\n}\n//-------------------------------------------------------------\n// download the following standalone program\n#!/usr/bin/pike\nmapping fact=([ 1:1 ]);\nint factorial(int n)\n{\nif(!fact[n])\nfact[n]=n*factorial(n-1);\nreturn fact[n];\n}\narray n2pat(int N, int len)\n{\nint i=1;\narray pat=({});\nwhile(i <= len)\n{\npat += ({ N%i });\nN/=i;\ni++;\n}\nreturn pat;\n}\narray pat2perm(array pat)\n{\narray source=indices(pat);\narray perm=({});\nwhile(sizeof(pat))\n{\nperm += ({ source[pat[-1]] });\nsource = source[..pat[-1]-1]+source[pat[-1]+1..];\npat=pat[..sizeof(pat)-2];\n}\nreturn perm;\n}\narray n2perm(int N, int len)\n{\nreturn pat2perm(n2pat(N, len));\n}\nvoid main()\n{\narray data;\nwhile(data=Stdio.stdin->gets()/" ")\n{\nint num_permutations = factorial(sizeof(data));\nfor(int i; i<num_permutations; i++)\n{\narray permutation = data[n2perm(i, sizeof(data))[*]];\nwrite(permutation*" "+"\\n");\n}\n}\n}\n'})})]})}function c(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(m,{...e})}):m(e)}},8453(e,n,r){r.d(n,{R:()=>s,x:()=>o});var a=r(6540);const i={},t=a.createContext(i);function s(e){const n=a.useContext(t);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(t.Provider,{value:n},e.children)}}}]);