"use strict";(self.webpackChunkpike_cookbook=self.webpackChunkpike_cookbook||[]).push([[359],{3681(n,e,i){i.r(e),i.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"advanced/user-interfaces","title":"User Interfaces","description":"Introduction","source":"@site/docs/advanced/user-interfaces.md","sourceDirName":"advanced","slug":"/advanced/user-interfaces","permalink":"/pike-cookbook/docs/advanced/user-interfaces","draft":false,"unlisted":false,"editUrl":"https://github.com/TheSmuks/pike-cookbook/tree/main/docs/advanced/user-interfaces.md","tags":[],"version":"current","frontMatter":{"id":"user-interfaces","title":"User Interfaces","sidebar_label":"User Interfaces"},"sidebar":"tutorialSidebar","previous":{"title":"Process Management","permalink":"/pike-cookbook/docs/advanced/processes"}}');var r=i(4848),s=i(8453);const a={id:"user-interfaces",title:"User Interfaces",sidebar_label:"User Interfaces"},o="User Interfaces",c={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Parsing Program Arguments",id:"parsing-program-arguments",level:2},{value:"Testing Whether a Program Is Running Interactively",id:"testing-whether-a-program-is-running-interactively",level:2},{value:"Clearing the Screen",id:"clearing-the-screen",level:2},{value:"Determining Terminal or Window Size",id:"determining-terminal-or-window-size",level:2},{value:"Changing Text Color",id:"changing-text-color",level:2},{value:"Reading from the Keyboard",id:"reading-from-the-keyboard",level:2},{value:"Reading Passwords",id:"reading-passwords",level:2},{value:"Using POSIX termios",id:"using-posix-termios",level:2},{value:"Checking for Waiting Input",id:"checking-for-waiting-input",level:2},{value:"Editing Input",id:"editing-input",level:2},{value:"Managing the Screen",id:"managing-the-screen",level:2},{value:"Creating GUI Applications with GTK2",id:"creating-gui-applications-with-gtk2",level:2},{value:"Event-Driven Programming",id:"event-driven-programming",level:2},{value:"Program: Interactive Menu System",id:"program-interactive-menu-system",level:2},{value:"See Also",id:"see-also",level:2}];function d(n){const e={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"user-interfaces",children:"User Interfaces"})}),"\n",(0,r.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"What this covers"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Terminal/console programming with Readline"}),"\n",(0,r.jsx)(e.li,{children:"Command-line argument parsing with Getopt"}),"\n",(0,r.jsx)(e.li,{children:"ANSI escape codes for colors and formatting"}),"\n",(0,r.jsx)(e.li,{children:"Interactive terminal UIs with keyboard navigation"}),"\n",(0,r.jsx)(e.li,{children:"Password input and terminal control with termios"}),"\n",(0,r.jsx)(e.li,{children:"GTK2/GTK3 graphical user interfaces"}),"\n",(0,r.jsx)(e.li,{children:"Event-driven programming patterns"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Why use it"}),"\nUser interfaces are how users interact with your programs. Pike 8 provides excellent support for both text-based terminal interfaces and graphical applications. This guide covers everything from simple command-line tools to interactive terminal menus and GUI applications."]}),"\n",(0,r.jsx)(e.admonition,{title:"Key Concept",type:"tip",children:(0,r.jsxs)(e.p,{children:["Pike's ",(0,r.jsx)(e.code,{children:"Stdio.Readline"})," provides powerful interactive input with history, editing, and completion. For GUI applications, Pike supports GTK2/GTK3 through optional modules. Always check for interactive terminals with ",(0,r.jsx)(e.code,{children:"isatty()"})," before using ANSI codes."]})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-pike",children:'// User Interfaces in Pike 8\n// Demonstrating terminal, console, and GUI programming\n\nimport Stdio;\n\nvoid check_ui_modules() {\n    // Check terminal capabilities\n    if (isatty(STDOUT->fd())) {\n        write("Running in terminal mode\\n");\n    } else {\n        write("Running in non-interactive mode\\n");\n    }\n\n    // Check for optional modules\n#ifdef __GTK2__\n    write("GTK2 support available\\n");\n#else\n    write("GTK2 not available\\n");\n#endif\n\n#ifdef __NCURSES__\n    write("NCurses support available\\n");\n#else\n    write("NCurses not available\\n");\n#endif\n}\n'})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"parsing-program-arguments",children:"Parsing Program Arguments"}),"\n",(0,r.jsxs)(e.p,{children:["Pike 8 provides the ",(0,r.jsx)(e.code,{children:"Getopt"})," module for sophisticated command-line argument parsing. This modern approach handles short options, long options, and arguments with type safety."]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Parse command-line arguments\n//-----------------------------\nimport Getopt;\n\nint verbose;\nstring output_file;\nint number;\n\n// Define all options\nforeach (find_all_options(argv, ({\n    ({"help", NO_ARG, ({ "-h", "--help" })}),\n    ({"verbose", NO_ARG, ({ "-v", "--verbose" })}),\n    ({"output", HAS_ARG, ({ "-o", "--output" })}),\n    ({"number", HAS_ARG, ({ "-n", "--number" })}),\n}), array(string) opt) {\n    switch(opt[0]) {\n        case "help":\n            usage();\n            return 0;\n        case "verbose":\n            verbose;\n            break;\n        case "output":\n            output_file;\n            break;\n        case "number":\n            number;\n            break;\n    }\n}\n\n// Get remaining arguments\narray(string) args;\nargs;\n'})}),"\n",(0,r.jsx)(e.admonition,{type:"tip",children:(0,r.jsxs)(e.p,{children:["Use ",(0,r.jsx)(e.code,{children:"find_all_options()"})," from the Getopt module for clean, maintainable argument parsing. It automatically generates help text and handles both short (",(0,r.jsx)(e.code,{children:"-v"}),") and long (",(0,r.jsx)(e.code,{children:"--verbose"}),") option formats."]})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"testing-whether-a-program-is-running-interactively",children:"Testing Whether a Program Is Running Interactively"}),"\n",(0,r.jsxs)(e.p,{children:["Use ",(0,r.jsx)(e.code,{children:"Stdio.isatty()"})," to detect if your program is running in an interactive terminal or being piped/redirected. This is crucial for deciding whether to use colors, progress indicators, or fancy terminal output."]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Detect interactive terminal\n//-----------------------------\n\nint is_interactive() {\n    return isatty(STDOUT->fd());\n}\n\nvoid smart_output(string msg) {\n    if (is_interactive()) {\n        // Use colors and fancy output\n        write("\\033[1;32m%s\\033[0m\\n", msg);\n    } else {\n        // Plain text for pipes/redirection\n        write("%s\\n", msg);\n    }\n}\n'})}),"\n",(0,r.jsxs)(e.p,{children:["Checking ",(0,r.jsx)(e.code,{children:"isatty()"})," before using ANSI escape codes or terminal-specific features ensures your program works correctly when output is redirected to files or piped to other programs."]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"clearing-the-screen",children:"Clearing the Screen"}),"\n",(0,r.jsx)(e.p,{children:"Use ANSI escape sequences for screen clearing and cursor positioning. Always check if you're in a terminal first."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Clear screen and position cursor\n//-----------------------------\n\nconstant ANSI_CLEAR = "\\033[2J";\nconstant ANSI_HOME = "\\033[H";\nconstant ANSI_RESET = "\\033[0m";\n\nvoid clear_screen() {\n    if (isatty(STDOUT->fd())) {\n        write(ANSI_CLEAR);\n        write(ANSI_HOME);\n    }\n}\n\n// ANSI color codes\nconstant COLORS = ([\n    "black": "\\033[30m",\n    "red": "\\033[31m",\n    "green": "\\033[32m",\n    "yellow": "\\033[33m",\n    "blue": "\\033[34m",\n    "magenta": "\\033[35m",\n    "cyan": "\\033[36m",\n    "white": "\\033[37m",\n]);\n\nvoid colored_write(string color, string msg) {\n    if (isatty(STDOUT->fd())) {\n        write(COLORS[color]);\n        write(msg);\n        write(ANSI_RESET);\n    } else {\n        write(msg);\n    }\n}\n'})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"determining-terminal-or-window-size",children:"Determining Terminal or Window Size"}),"\n",(0,r.jsxs)(e.p,{children:["Use ",(0,r.jsx)(e.code,{children:"Stdio.get_terminal_size()"})," to get terminal dimensions for proper text layout and UI sizing."]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Get terminal dimensions\n//-----------------------------\n\nmapping(string:int) size;\nsize;\n\nif (size) {\n    int cols = size["xsize"];\n    int rows = size["ysize"];\n    write("Terminal: %dx%d\\n", cols, rows);\n}\n\n// Responsive text wrapping\nstring wrap_text(string text, int width) {\n    array(string) words = text / " ";\n    array(string) lines = ({});\n    string current = "";\n\n    foreach (words, string word) {\n        if (sizeof(current) + sizeof(word) + 1 > width) {\n            lines += ({current});\n            current = word;\n        } else {\n            if (current != "") current += " ";\n            current += word;\n        }\n    }\n    if (current) lines += ({current});\n\n    return lines * "\\n";\n}\n'})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"changing-text-color",children:"Changing Text Color"}),"\n",(0,r.jsxs)(e.p,{children:["ANSI color codes provide colored terminal output. Always wrap with ",(0,r.jsx)(e.code,{children:"isatty()"})," checks."]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Add colors to terminal output\n//-----------------------------\n\nconstant COLORS = ([\n    "black": "\\033[30m",\n    "red": "\\033[31m",\n    "green": "\\033[32m",\n    "yellow": "\\033[33m",\n    "blue": "\\033[34m",\n    "magenta": "\\033[35m",\n    "cyan": "\\033[36m",\n    "white": "\\033[37m",\n]);\n\nconstant BG_COLORS = ([\n    "black": "\\033[40m",\n    "red": "\\033[41m",\n    "green": "\\033[42m",\n    "yellow": "\\033[43m",\n    "blue": "\\033[44m",\n    "magenta": "\\033[45m",\n    "cyan": "\\033[46m",\n    "white": "\\033[47m",\n]);\n\n// Text styling\nconstant BOLD = "\\033[1m";\nconstant DIM = "\\033[2m";\nconstant UNDERLINE = "\\033[4m";\nconstant BLINK = "\\033[5m";\nconstant REVERSE = "\\033[7m";\n\n// Colored write function\nvoid cwrite(string fg, string msg) {\n    if (isatty(STDOUT->fd())) {\n        write(COLORS[fg]);\n        write(msg);\n        write("\\033[0m");\n    } else {\n        write(msg);\n    }\n}\n\n// Progress bar example\nvoid progress_bar(int percent) {\n    int width = 50;\n    int filled = (percent * width) / 100;\n\n    write("\\r[");\n    write("\\033[42m");  // Green background\n    write(" " * filled);\n    write("\\033[0m");\n    write("%s] %3d%%", " " * (width - filled), percent);\n}\n'})}),"\n",(0,r.jsx)(e.admonition,{type:"tip",children:(0,r.jsxs)(e.p,{children:["Always test for interactive terminal with ",(0,r.jsx)(e.code,{children:"isatty()"})," before using ANSI codes. This prevents escape sequences from appearing in log files or when output is piped to other programs."]})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"reading-from-the-keyboard",children:"Reading from the Keyboard"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"Stdio.Readline"})," provides interactive input with history, editing, and completion support - perfect for command-line applications."]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Interactive input with Readline\n//-----------------------------\n\nclass ReadlineUI {\n    inherit Stdio.Readline;\n\n    void create(string|void prompt) {\n        ::create();\n        set_prompt(prompt || "> ");\n    }\n\n    // Get a single line\n    string get_line() {\n        return read();\n    }\n\n    // Confirm y/n\n    int confirm(string question) {\n        string old_prompt = get_prompt();\n        set_prompt(question + " [y/N]: ");\n        string answer = read();\n        set_prompt(old_prompt);\n        return lower_case(answer) == "y";\n    }\n\n    // Menu selection\n    int menu(string title, array(string) options) {\n        write("\\n%s\\n", title);\n        for (int i = 0; i < sizeof(options); i++) {\n            write("  %d. %s\\n", i + 1, options[i]);\n        }\n\n        while (1) {\n            set_prompt("Choose: ");\n            string input = read();\n            int choice = (int)input;\n\n            if (choice > 0 && choice <= sizeof(options)) {\n                return choice - 1;\n            }\n            write("Invalid choice\\n");\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"reading-passwords",children:"Reading Passwords"}),"\n",(0,r.jsxs)(e.p,{children:["For password input, disable terminal echo using ",(0,r.jsx)(e.code,{children:"tcsetattr()"})," to prevent characters from being displayed."]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Secure password input\n//-----------------------------\n\nstring get_password(string|void prompt) {\n    string p = prompt || "Password: ";\n    write(p);\n\n    // Disable echo using modern Pike 8 syntax\n    STDIN->tcsetattr(([ "ECHO": 0 ]));\n\n    string password = read();\n\n    // Restore echo\n    STDIN->tcsetattr(([ "ECHO": 1 ]));\n\n    write("\\n");\n    return password || "";\n}\n\n// Password confirmation\nint confirm_password(string prompt) {\n    string pass1 = get_password(prompt);\n    string pass2 = get_password("Confirm password: ");\n\n    if (pass1 == pass2 && sizeof(pass1) > 0) {\n        return 1;\n    }\n    write("Passwords don\'t match\\n");\n    return 0;\n}\n'})}),"\n",(0,r.jsx)(e.admonition,{type:"warning",children:(0,r.jsxs)(e.p,{children:["Always restore terminal echo after reading passwords. Use ",(0,r.jsx)(e.code,{children:"catch"})," blocks or ensure the restore code runs even if errors occur to prevent leaving the terminal in a bad state."]})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"using-posix-termios",children:"Using POSIX termios"}),"\n",(0,r.jsxs)(e.p,{children:["Pike's ",(0,r.jsx)(e.code,{children:"Stdio.File.tcsetattr()"})," provides direct access to POSIX termios for fine-grained terminal control."]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-pike",children:"//-----------------------------\n// Recipe: Terminal control with termios\n//-----------------------------\n\n// Save current settings\nmapping old_settings = Stdio.File(STDIN)->tcgetattr();\n\n// Create new settings (no echo, raw mode)\nmapping new_settings = old_settings + ([]);\nnew_settings->c_lflag &= ~Constants.System.ECHO;\nnew_settings->c_lflag &= ~Constants.System.ICANON;\n\n// Apply settings\nSTDIN->tcsetattr(new_settings);\n\n// Read single character (non-blocking)\nint ch;\nwhile (ch == -1) {\n    ch = (int)STDIN->read(1);\n    // Do other work while waiting\n}\n\n// Restore original settings\nSTDIN->tcsetattr(old_settings);\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"checking-for-waiting-input",children:"Checking for Waiting Input"}),"\n",(0,r.jsxs)(e.p,{children:["Use ",(0,r.jsx)(e.code,{children:"Stdio.File.peek()"})," or ",(0,r.jsx)(e.code,{children:"select()"})," to check for available input without blocking."]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Non-blocking input check\n//-----------------------------\n\n// Check if input is available\nint has_input() {\n    return STDIN->peek() != "";\n}\n\n// Wait for input with timeout\nint wait_for_input(float timeout) {\n    return select(({ STDIN }), ({}), ({}), timeout)[0];\n}\n\n// Read with timeout\nstring|zero read_with_timeout(float timeout) {\n    if (!wait_for_input(timeout)) {\n        return 0;\n    }\n    return STDIN->gets();\n}\n'})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"editing-input",children:"Editing Input"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"Stdio.Readline"})," automatically provides line editing (arrow keys, backspace, delete, home/end) and command history."]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Readline with history and editing\n//-----------------------------\n\nclass InteractiveShell {\n    inherit Stdio.Readline;\n\n    void create() {\n        ::create();\n        set_prompt("shell> ");\n\n        // Enable history\n        enable_history(100);\n\n        // Load/save history\n        read_history(".pike_history");\n    }\n\n    void run() {\n        while (string line = read()) {\n            if (sizeof(line)) {\n                add_history(line);\n                execute_command(line);\n            }\n        }\n\n        write_history(".pike_history");\n    }\n\n    void execute_command(string cmd) {\n        // Process command\n        write("Executed: %s\\n", cmd);\n    }\n}\n'})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"managing-the-screen",children:"Managing the Screen"}),"\n",(0,r.jsx)(e.p,{children:"For complex terminal UIs, use NCurses or create your own screen management with ANSI codes and positioning."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Simple screen management\n//-----------------------------\n\nclass Screen {\n    array(array(string)) buffer;\n    int width;\n    int height;\n\n    void create(int w, int h) {\n        width = w;\n        height = h;\n        buffer = allocate(height, allocate(width, " "));\n    }\n\n    void clear() {\n        buffer = allocate(height, allocate(width, " "));\n    }\n\n    void write(int x, int y, string text) {\n        if (y >= 0 && y < height && x >= 0 && x < width) {\n            buffer[y][x..x+sizeof(text)-1] = text;\n        }\n    }\n\n    void refresh() {\n        write("\\033[2J\\033[H");  // Clear and home\n        foreach (buffer, array(string) line; int y) {\n            write("\\033[%d;0H%s\\n", y+1, line * "");\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"creating-gui-applications-with-gtk2",children:"Creating GUI Applications with GTK2"}),"\n",(0,r.jsx)(e.p,{children:"GTK2 provides full-featured GUI development with Pike. Use lambda functions for callbacks and modern Pike 8 syntax."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Basic GTK2 window\n//-----------------------------\n#ifdef __GTK2__\nimport GTK2;\n\nclass SimpleWindow {\n    inherit Window;\n\n    void create(string title) {\n        ::create(GTK2_WINDOW_TOPLEVEL);\n        set_title(title);\n        set_default_size(400, 300);\n\n        // Connect signals with lambda functions\n        signal_connect("destroy", lambda() {\n            write("Exiting...\\n");\n            GTK2.main_quit();\n        });\n\n        setup_widgets();\n    }\n\n    void setup_widgets() {\n        VBox vbox = VBox();\n        add(vbox);\n\n        // Add button\n        Button btn = Button("Click Me");\n        btn->signal_connect("clicked", lambda(mixed self) {\n            write("Button clicked!\\n");\n        });\n        vbox->pack_start(btn, 0, 0, 5);\n\n        // Add text entry\n        Entry entry = Entry();\n        vbox->pack_start(entry, 0, 0, 5);\n    }\n\n    void run() {\n        show();\n        GTK2.main();\n    }\n}\n\nint main(int argc, array(string) argv) {\n    GTK2.setup_gtk(argc, argv);\n    SimpleWindow app = SimpleWindow("Pike GTK2 Demo");\n    app->run();\n    return 0;\n}\n#else\nint main() {\n    write("GTK2 not available\\n");\n    return 1;\n}\n#endif\n'})}),"\n",(0,r.jsx)(e.admonition,{type:"tip",children:(0,r.jsxs)(e.p,{children:["GTK2 support is optional in Pike. Always wrap GTK2 code in ",(0,r.jsx)(e.code,{children:"#ifdef __GTK2__"})," preprocessor directives and provide fallback behavior for systems without GTK2."]})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"event-driven-programming",children:"Event-Driven Programming"}),"\n",(0,r.jsx)(e.p,{children:"Pike's backend provides an event loop for timers, I/O events, and asynchronous operations."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-pike",children:"//-----------------------------\n// Recipe: Event loop and async I/O\n//-----------------------------\n\nclass EventApplication {\n    int running = 1;\n\n    // Add timer event\n    int add_timer(float delay, function callback) {\n        return Pike.Backend()->call_out(callback, delay);\n    }\n\n    // Monitor file descriptor\n    void add_io(Stdio.File file, function callback) {\n        file->set_callback(callback);\n        file->set_nonblocking(1, 0, Pike.POLLIN);\n    }\n\n    // Run event loop\n    void run() {\n        while (running) {\n            Pike.Backend()->wait(1.0);\n        }\n    }\n\n    void stop() {\n        running = 0;\n    }\n}\n\n// Example: Async HTTP client\nclass AsyncClient {\n    inherit EventApplication;\n\n    Protocols.HTTP.Query query;\n\n    void fetch(string url, function cb) {\n        query = Protocols.HTTP.Query();\n        add_timer(30.0, lambda() {\n            query->async_fetch(cb);\n        });\n    }\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"program-interactive-menu-system",children:"Program: Interactive Menu System"}),"\n",(0,r.jsx)(e.p,{children:"Complete terminal-based menu system with keyboard navigation, using Readline and ANSI codes."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Program: Full-Featured Terminal Menu System\n//-----------------------------\n\nclass MenuSystem {\n    inherit Stdio.Readline;\n\n    array(string) items;\n    int selected = 0;\n\n    void create(array(string) opts) {\n        ::create();\n        items = opts;\n        selected = 0;\n    }\n\n    void display() {\n        write("\\033[2J\\033[H");  // Clear screen\n        write("\\033[1;36m=== Pike Menu ===\\033[0m\\n\\n");\n\n        foreach (items, string item; int i) {\n            if (i == selected) {\n                write("\\033[7m");  // Reverse video\n                write(">%2d. %s\\033[0m\\n", i+1, item);\n            } else {\n                write("  %d. %s\\n", i+1, item);\n            }\n        }\n\n        write("\\nUse arrow keys, Enter to select, Q to quit\\n");\n    }\n\n    int|zero navigate() {\n        STDIN->tcsetattr(([ "ECHO": 0, "ICANON": 0 ]));\n\n        while (1) {\n            display();\n\n            string input = read();\n            int ch = (int)input[0];\n\n            switch(ch) {\n                case \'A\':  // Up arrow\n                    selected = (selected - 1 + sizeof(items)) % sizeof(items);\n                    break;\n                case \'B\':  // Down arrow\n                    selected = (selected + 1) % sizeof(items);\n                    break;\n                case \'\\r\':  // Enter\n                    STDIN->tcsetattr(([ "ECHO": 1, "ICANON": 1 ]));\n                    return selected;\n                case \'q\':\n                case \'Q\':\n                    STDIN->tcsetattr(([ "ECHO": 1, "ICANON": 1 ]));\n                    return -1;\n            }\n        }\n    }\n}\n\nint main() {\n    array(string) menu_items = ({\n        "File Operations",\n        "Database Management",\n        "Network Tools",\n        "System Configuration",\n        "Help",\n        "Exit"\n    });\n\n    MenuSystem menu = MenuSystem(menu_items);\n    int|zero choice = menu->navigate();\n\n    if (choice >= 0) {\n        write("\\nYou selected: %s\\n", menu->items[choice]);\n    }\n\n    return 0;\n}\n'})}),"\n",(0,r.jsx)(e.admonition,{type:"tip",children:(0,r.jsx)(e.p,{children:"This complete menu system demonstrates combining Readline, ANSI escape codes, and termios control for professional terminal UIs in Pike 8. The reverse video highlighting and arrow key navigation create an intuitive user experience."})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"see-also",children:"See Also"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"/docs/advanced/processes",children:"Process Management"})," - Inter-process communication"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"/docs/files/file-access",children:"File Access"})," - File I/O operations"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"/docs/network/sockets",children:"Network Programming"})," - Socket-based UIs"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"/docs/advanced/classes",children:"Classes"})," - Object-oriented UI frameworks"]}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},8453(n,e,i){i.d(e,{R:()=>a,x:()=>o});var t=i(6540);const r={},s=t.createContext(r);function a(n){const e=t.useContext(s);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:a(n.components),t.createElement(s.Provider,{value:e},n.children)}}}]);