"use strict";(self.webpackChunkpike_cookbook=self.webpackChunkpike_cookbook||[]).push([[43],{8259(n,e,r){r.r(e),r.d(e,{assets:()=>a,contentTitle:()=>c,default:()=>p,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"network/sockets","title":"Sockets","description":"Introduction","source":"@site/docs/network/sockets.md","sourceDirName":"network","slug":"/network/sockets","permalink":"/pike-cookbook/docs/network/sockets","draft":false,"unlisted":false,"editUrl":"https://github.com/TheSmuks/pike-cookbook/tree/main/docs/network/sockets.md","tags":[],"version":"current","frontMatter":{"id":"sockets","title":"Sockets","sidebar_label":"Sockets"},"sidebar":"tutorialSidebar","previous":{"title":"CGI Programming","permalink":"/pike-cookbook/docs/network/cgi-programming"},"next":{"title":"Web Automation","permalink":"/pike-cookbook/docs/network/web-automation"}}');var i=r(4848),s=r(8453);const o={id:"sockets",title:"Sockets",sidebar_label:"Sockets"},c="Sockets",a={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Writing a TCP Client",id:"writing-a-tcp-client",level:2},{value:"Basic TCP Connection",id:"basic-tcp-connection",level:3},{value:"Writing a TCP Server",id:"writing-a-tcp-server",level:2},{value:"Basic TCP Server",id:"basic-tcp-server",level:3},{value:"Communicating over TCP",id:"communicating-over-tcp",level:2},{value:"Bidirectional Communication",id:"bidirectional-communication",level:3},{value:"Setting Up a UDP Client",id:"setting-up-a-udp-client",level:2},{value:"UDP Communication",id:"udp-communication",level:3},{value:"Setting Up a UDP Server",id:"setting-up-a-udp-server",level:2},{value:"UDP Server Implementation",id:"udp-server-implementation",level:3},{value:"Using UNIX Domain Sockets",id:"using-unix-domain-sockets",level:2},{value:"UNIX Domain Socket Client",id:"unix-domain-socket-client",level:3},{value:"UNIX Domain Socket Server",id:"unix-domain-socket-server",level:2},{value:"UNIX Socket Server",id:"unix-socket-server",level:3},{value:"SSL/TLS Sockets",id:"ssltls-sockets",level:2},{value:"SSL Client",id:"ssl-client",level:3},{value:"SSL/TLS Server",id:"ssltls-server",level:2},{value:"SSL Server Implementation",id:"ssl-server-implementation",level:3},{value:"Identifying the Other End of a Socket",id:"identifying-the-other-end-of-a-socket",level:2},{value:"Get Peer Address",id:"get-peer-address",level:3},{value:"Finding Your Own Name and Address",id:"finding-your-own-name-and-address",level:2},{value:"Local Address Information",id:"local-address-information",level:3},{value:"Non-Blocking I/O with select()",id:"non-blocking-io-with-select",level:2},{value:"Multiplexed Server",id:"multiplexed-server",level:3},{value:"Modern Async with Concurrent.Future",id:"modern-async-with-concurrentfuture",level:2},{value:"Async Socket I/O",id:"async-socket-io",level:3},{value:"Socket Options and Configuration",id:"socket-options-and-configuration",level:2},{value:"Socket Options",id:"socket-options",level:3},{value:"See Also",id:"see-also",level:2}];function l(n){const e={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"sockets",children:"Sockets"})}),"\n",(0,i.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsxs)(e.p,{children:["Socket programming enables network communication between applications. Pike 8 provides comprehensive support for TCP, UDP, UNIX domain sockets, and SSL/TLS through the ",(0,i.jsx)(e.code,{children:"Stdio.Port"}),", ",(0,i.jsx)(e.code,{children:"Stdio.File"}),", and ",(0,i.jsx)(e.code,{children:"SSL"})," modules."]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"What this covers:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"TCP/UDP client and server programming"}),"\n",(0,i.jsx)(e.li,{children:"UNIX domain sockets for local IPC"}),"\n",(0,i.jsx)(e.li,{children:"SSL/TLS secure communication"}),"\n",(0,i.jsx)(e.li,{children:"Non-blocking I/O and async operations"}),"\n",(0,i.jsx)(e.li,{children:"Socket options and configuration"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Why use it:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Build networked applications and services"}),"\n",(0,i.jsx)(e.li,{children:"Implement custom protocols"}),"\n",(0,i.jsx)(e.li,{children:"Create real-time communication systems"}),"\n",(0,i.jsx)(e.li,{children:"Develop client-server architectures"}),"\n"]}),"\n",(0,i.jsx)(e.admonition,{type:"tip",children:(0,i.jsx)(e.p,{children:"Pike's socket API provides both synchronous and asynchronous modes, making it easy to choose the right approach for your application."})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"writing-a-tcp-client",children:"Writing a TCP Client"}),"\n",(0,i.jsx)(e.h3,{id:"basic-tcp-connection",children:"Basic TCP Connection"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Connect to TCP server\n//-----------------------------\n\nStdio.File sock = Stdio.File();\nstring remote_host = "example.com";\nint remote_port = 80;\n\nif (!sock->connect(remote_host, remote_port)) {\n    werror("Couldn\'t connect to %s:%d: %s\\n",\n          remote_host, remote_port, strerror(sock->errno()));\n    exit(1);\n}\n\n// Send request\nsock->write("GET / HTTP/1.0\\r\\nHost: " + remote_host + "\\r\\n\\r\\n");\n\n// Read response\nstring answer = sock->read();\nwrite("Received %d bytes\\n", sizeof(answer));\n\nsock->close();\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"writing-a-tcp-server",children:"Writing a TCP Server"}),"\n",(0,i.jsx)(e.h3,{id:"basic-tcp-server",children:"Basic TCP Server"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Create TCP server\n//-----------------------------\n\nint server_port = 8080;\nStdio.Port mainsock = Stdio.Port();\n\nif (!mainsock->bind(server_port)) {\n    werror("Couldn\'t be a tcp server on port %d: %s\\n",\n          server_port, strerror(mainsock->errno()));\n    exit(1);\n}\n\nwrite("Server listening on port %d\\n", server_port);\n\nwhile (1) {\n    Stdio.File sock = mainsock->accept();\n    if (!sock) break;\n\n    // Handle connection\n    string data = sock->read(1024, 1);\n    if (data) {\n        write("Received: %s\\n", data);\n        sock->write("Acknowledged\\n");\n    }\n\n    sock->close();\n}\n'})}),"\n",(0,i.jsx)(e.admonition,{type:"tip",children:(0,i.jsxs)(e.p,{children:["Set ",(0,i.jsx)(e.code,{children:"Stdio.PORT_REUSE_ADDRESS"})," option to allow quick server restarts."]})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"communicating-over-tcp",children:"Communicating over TCP"}),"\n",(0,i.jsx)(e.h3,{id:"bidirectional-communication",children:"Bidirectional Communication"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Send and receive data\n//-----------------------------\n\nStdio.File sock = Stdio.File();\nif (!sock->connect("example.com", 80)) {\n    werror("Connection failed\\n");\n    exit(1);\n}\n\n// Send data\nsock->write("What is your name?\\n");\n\n// Read response (up to 1KB or whatever is available)\nstring response = sock->read(1024, 1);\nwrite("Response: %s\\n", response);\n\n// Buffered reads with Stdio.FILE\nStdio.FILE sock2 = Stdio.FILE();\nsock2->assign(sock);\nresponse = sock2->gets();\nwrite("Line: %s\\n", response);\n\nsock->close();\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"setting-up-a-udp-client",children:"Setting Up a UDP Client"}),"\n",(0,i.jsx)(e.h3,{id:"udp-communication",children:"UDP Communication"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: UDP Client (Pike 8)\n//-----------------------------\n\n#pragma strict_types\n#require constant(Stdio.UDP)\n\nint main(int argc, array(string) argv)\n{\n    if (argc < 3) {\n        werror("Usage: %s host port [message]\\n", argv[0]);\n        return 1;\n    }\n\n    string host = argv[1];\n    int port = (int)argv[2];\n    string msg = argc > 3 ? argv[3] : "Hello, UDP!";\n\n    // Create UDP socket\n    Stdio.UDP udp = Stdio.UDP();\n    if (!udp) {\n        werror("Failed to create UDP socket: %s\\n", strerror(errno()));\n        return 1;\n    }\n\n    // Send datagram\n    udp->send(host, port, msg);\n    write("Sent \'%s\' to %s:%d\\n", msg, host, port);\n\n    // Wait for response (with timeout)\n    mixed response = udp->read(1024, ".", 5.0);\n    if (response) {\n        string data = response[0];\n        string from = response[1];\n        write("Received \'%s\' from %s\\n", data, from);\n    } else {\n        write("No response (timeout)\\n");\n    }\n\n    udp->close();\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"setting-up-a-udp-server",children:"Setting Up a UDP Server"}),"\n",(0,i.jsx)(e.h3,{id:"udp-server-implementation",children:"UDP Server Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: UDP Server (Pike 8)\n//-----------------------------\n\n#pragma strict_types\n#require constant(Stdio.UDP)\n\nint main(int argc, array(string) argv)\n{\n    int port = argc > 1 ? (int)argv[1] : 8080;\n\n    // Create and bind UDP socket\n    Stdio.UDP udp = Stdio.UDP();\n    if (!udp->bind(port)) {\n        werror("Failed to bind to port %d: %s\\n", port, strerror(udp->errno()));\n        return 1;\n    }\n\n    write("UDP server listening on port %d\\n", port);\n\n    // Enable broadcast\n    udp->set_option(Stdio.PORT_BROADCAST, 1);\n\n    while (1) {\n        // Read datagram\n        mixed data = udp->read();\n        if (!data) {\n            werror("Read error: %s\\n", strerror(udp->errno()));\n            continue;\n        }\n\n        string msg = data[0];\n        string from = data[1];\n        write("Received \'%s\' from %s\\n", msg, from);\n\n        // Send echo response\n        array addr = from / " ";\n        udp->send(addr[0], (int)addr[1], "Echo: " + msg);\n    }\n\n    udp->close();\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"using-unix-domain-sockets",children:"Using UNIX Domain Sockets"}),"\n",(0,i.jsx)(e.h3,{id:"unix-domain-socket-client",children:"UNIX Domain Socket Client"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: UNIX Domain Socket Client (Pike 8)\n//-----------------------------\n\n#pragma strict_types\n#require constant(Stdio.File)\n\nint main(int argc, array(string) argv)\n{\n    string socket_path = argc > 1 ? argv[1] : "/tmp/mysocket";\n\n    Stdio.File sock = Stdio.File();\n    if (!sock->connect(socket_path)) {\n        werror("Couldn\'t connect to %s: %s\\n",\n              socket_path, strerror(sock->errno()));\n        return 1;\n    }\n\n    sock->write("Hello via UNIX socket!\\n");\n    string response = sock->read();\n    write("Server response: %s\\n", response);\n\n    sock->close();\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"unix-domain-socket-server",children:"UNIX Domain Socket Server"}),"\n",(0,i.jsx)(e.h3,{id:"unix-socket-server",children:"UNIX Socket Server"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: UNIX Domain Socket Server (Pike 8)\n//-----------------------------\n\n#pragma strict_types\n#require constant(Stdio.Port)\n\nint main(int argc, array(string) argv)\n{\n    string socket_path = argc > 1 ? argv[1] : "/tmp/mysocket";\n\n    // Remove old socket file if exists\n    if (file_stat(socket_path)) {\n        rm(socket_path);\n    }\n\n    Stdio.Port port = Stdio.Port();\n    if (!port->bind(socket_path)) {\n        werror("Couldn\'t bind to %s: %s\\n",\n              socket_path, strerror(port->errno()));\n        return 1;\n    }\n\n    write("UNIX domain socket server listening on %s\\n", socket_path);\n\n    while (1) {\n        Stdio.File sock = port->accept();\n        if (!sock) continue;\n\n        string data = sock->read(1024, 1);\n        if (data) {\n            write("Received: %s\\n", data);\n            sock->write("Acknowledged\\n");\n        }\n        sock->close();\n    }\n\n    // Cleanup\n    port->close();\n    rm(socket_path);\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"ssltls-sockets",children:"SSL/TLS Sockets"}),"\n",(0,i.jsx)(e.h3,{id:"ssl-client",children:"SSL Client"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: SSL/TLS Client (Pike 8)\n//-----------------------------\n\n#pragma strict_types\n#require constant(SSL.File)\n#require constant(SSL.Context)\n\nint main(int argc, array(string) argv)\n{\n    if (argc < 3) {\n        werror("Usage: %s host port\\n", argv[0]);\n        return 1;\n    }\n\n    string host = argv[1];\n    int port = (int)argv[2];\n\n    // Create SSL context\n    SSL.Context ctx = SSL.Context();\n\n    // Connect to server\n    Stdio.File sock = Stdio.File();\n    if (!sock->connect(host, port)) {\n        werror("Connection failed: %s\\n", strerror(sock->errno()));\n        return 1;\n    }\n\n    // Create SSL connection\n    SSL.File ssl = SSL.File(sock, ctx);\n    int result = ssl->connect();\n    if (result < 0) {\n        werror("SSL handshake failed\\n");\n        return 1;\n    }\n\n    // Send HTTPS request\n    ssl->write("GET / HTTP/1.0\\r\\nHost: " + host + "\\r\\n\\r\\n");\n\n    // Read response\n    string response = ssl->read();\n    write("%s\\n", response);\n\n    ssl->close();\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"ssltls-server",children:"SSL/TLS Server"}),"\n",(0,i.jsx)(e.h3,{id:"ssl-server-implementation",children:"SSL Server Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: SSL/TLS Server (Pike 8)\n//-----------------------------\n\n#pragma strict_types\n#require constant(SSL.Port)\n#require constant(SSL.Context)\n\nvoid handle_ssl_client(SSL.File ssl)\n{\n    string data = ssl->read(4096, 1);\n    if (data) {\n        write("Received: %s\\n", data);\n        ssl->write("HTTP/1.0 200 OK\\r\\n\\r\\nSSL Connection Successful!\\n");\n    }\n    ssl->close();\n}\n\nint main(int argc, array(string) argv)\n{\n    int port = argc > 1 ? (int)argv[1] : 8443;\n    string cert_file = "server.pem";\n    string key_file = "server.key";\n\n    // Create SSL context with certificates\n    SSL.Context ctx = SSL.Context();\n    if (file_stat(cert_file)) {\n        ctx->certificates = (([{\n            "cert_file": cert_file,\n            "key_file": key_file\n        }]));\n    }\n\n    // Create SSL port\n    SSL.Port ssl_port = SSL.Port(ctx);\n    if (!ssl_port->bind(port, handle_ssl_client)) {\n        werror("Failed to bind SSL port: %s\\n", strerror(ssl_port->errno()));\n        return 1;\n    }\n\n    write("SSL server listening on port %d\\n", port);\n\n    // Keep server running\n    while (1) {\n        sleep(1);\n    }\n\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.admonition,{type:"warning",children:(0,i.jsx)(e.p,{children:"Always use proper SSL certificates in production. Self-signed certificates are only for testing."})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"identifying-the-other-end-of-a-socket",children:"Identifying the Other End of a Socket"}),"\n",(0,i.jsx)(e.h3,{id:"get-peer-address",children:"Get Peer Address"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Get remote socket address\n//-----------------------------\n\nStdio.File sock = Stdio.File();\nif (sock->connect("example.com", 80)) {\n    // Get remote address\n    string other_end = sock->query_address();\n    write("Connected to: %s\\n", other_end);\n\n    sock->close();\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"finding-your-own-name-and-address",children:"Finding Your Own Name and Address"}),"\n",(0,i.jsx)(e.h3,{id:"local-address-information",children:"Local Address Information"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Get local address (Pike 8)\n//-----------------------------\n\n#pragma strict_types\n\n// Get local address of a socket\nstring local_addr = sock->query_address(1);\nwrite("Local address: %s\\n", local_addr);\n\n// Get hostname and local IP addresses\nstring hostname = gethostname();\nwrite("Hostname: %s\\n", hostname);\n\n[string host, array ips, array aliases] = gethostbyname(hostname);\nforeach(ips; string ip) {\n    write("Local IP: %s\\n", ip);\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"non-blocking-io-with-select",children:"Non-Blocking I/O with select()"}),"\n",(0,i.jsx)(e.h3,{id:"multiplexed-server",children:"Multiplexed Server"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Non-blocking I/O with select() (Pike 8)\n//-----------------------------\n\n#pragma strict_types\n#require constant(Stdio.File)\n\nint main(int argc, array(string) argv)\n{\n    int port = argc > 1 ? (int)argv[1] : 8080;\n\n    Stdio.Port listen_sock = Stdio.Port();\n    if (!listen_sock->bind(port)) {\n        werror("Bind failed: %s\\n", strerror(listen_sock->errno()));\n        return 1;\n    }\n\n    array(Stdio.File) clients = (({}));\n    write("Multiplexed server on port %d\\n", port);\n\n    while (1) {\n        // Build read set\n        array read_fds = clients + (({listen_sock}));\n\n        // Wait for activity\n        mixed ready = Stdio.select(read_fds);\n        if (!ready || !sizeof(ready[0])) continue;\n\n        // Check for new connections\n        if (has_value(ready[0], listen_sock)) {\n            Stdio.File new_client = listen_sock->accept();\n            if (new_client) {\n                clients += (({new_client}));\n                write("New client: %s\\n", new_client->query_address());\n            }\n        }\n\n        // Check clients for data\n        foreach(clients, int i, Stdio.File client) {\n            if (has_value(ready[0], client)) {\n                string data = client->read(1024, 1);\n                if (!data || !sizeof(data)) {\n                    // Client disconnected\n                    write("Client disconnected\\n");\n                    client->close();\n                    clients = clients[..i-1] + clients[i+1..];\n                } else {\n                    write("Received: %s\\n", data);\n                    client->write("Echo: " + data);\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"modern-async-with-concurrentfuture",children:"Modern Async with Concurrent.Future"}),"\n",(0,i.jsx)(e.h3,{id:"async-socket-io",children:"Async Socket I/O"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Modern async socket I/O with Concurrent.Future (Pike 8)\n//-----------------------------\n\n#pragma strict_types\n#require constant(Concurrent.Future)\n#require constant(Stdio.File)\n\n// Async HTTP GET using Future\nConcurrent.Future async_http_get(string host, int port)\n{\n    Concurrent.Promise result = Concurrent.Promise();\n\n    thread_create(lambda() {\n        Stdio.File sock = Stdio.File();\n        if (!sock->connect(host, port)) {\n            result->failure(([{"error": "Connection failed"}]));\n            return;\n        }\n\n        sock->write("GET / HTTP/1.0\\r\\nHost: " + host + "\\r\\n\\r\\n");\n        string response = sock->read();\n        sock->close();\n\n        result->success(response);\n    });\n\n    return result->future();\n}\n\nint main()\n{\n    // Use the future\n    Concurrent.Future f = async_http_get("example.com", 80);\n\n    f->on_success(lambda(string response) {\n        write("Got response of %d bytes\\n", sizeof(response));\n    });\n\n    f->on_failure(lambda(mapping err) {\n        werror("Request failed: %s\\n", err->error);\n    });\n\n    // Wait for completion\n    mixed result = f->wait();\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"socket-options-and-configuration",children:"Socket Options and Configuration"}),"\n",(0,i.jsx)(e.h3,{id:"socket-options",children:"Socket Options"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Socket options and configuration (Pike 8)\n//-----------------------------\n\n#pragma strict_types\n\n// Creating a socket with options\nStdio.Port port = Stdio.Port();\n\n// Set SO_REUSEADDR to allow quick restart\nport->set_option(Stdio.PORT_REUSE_ADDRESS, 1);\n\n// Set SO_KEEPALIVE for connection monitoring\nStdio.File sock = Stdio.File();\nsock->set_option(Stdio.KEEPALIVE, 1);\n\n// Set TCP_NODELAY to disable Nagle\'s algorithm (for real-time apps)\nsock->set_option(Stdio.NO_DELAY, 1);\n\n// Set socket buffer sizes\nsock->set_buffer(65536, 65536); // read_buf, write_buf\n\n// Set socket timeout\nsock->set_nonblocking(1, 0, 0); // nonblocking mode\n\n// Enable broadcast for UDP\nStdio.UDP udp = Stdio.UDP();\nudp->set_option(Stdio.PORT_BROADCAST, 1);\nudp->set_option(Stdio.MULTICAST, 1);\n\n// Bind to specific interface\nport->bind(8080, 0, "127.0.0.1");\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"see-also",children:"See Also"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.a,{href:"/docs/network/web-automation",children:"Web Automation"})," - HTTP clients and web scraping"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.a,{href:"/docs/network/cgi-programming",children:"CGI Programming"})," - Web scripting"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.a,{href:"/docs/network/internet-services",children:"Internet Services"})," - Email, FTP, DNS"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.a,{href:"/docs/advanced/processes",children:"Process Management"})," - Inter-process communication"]}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(l,{...n})}):l(n)}},8453(n,e,r){r.d(e,{R:()=>o,x:()=>c});var t=r(6540);const i={},s=t.createContext(i);function o(n){const e=t.useContext(s);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:o(n.components),t.createElement(s.Provider,{value:e},n.children)}}}]);