"use strict";(self.webpackChunkpike_cookbook=self.webpackChunkpike_cookbook||[]).push([[851],{5173(e,n,r){r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>m,frontMatter:()=>t,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"basics/arrays","title":"Arrays","description":"Introduction","source":"@site/docs/basics/arrays.md","sourceDirName":"basics","slug":"/basics/arrays","permalink":"/pike-cookbook/docs/basics/arrays","draft":false,"unlisted":false,"editUrl":"https://github.com/TheSmuks/pike-cookbook/tree/main/docs/basics/arrays.md","tags":[],"version":"current","frontMatter":{"id":"arrays","title":"Arrays","sidebar_label":"Arrays"},"sidebar":"tutorialSidebar","previous":{"title":"Numbers","permalink":"/pike-cookbook/docs/basics/numbers"},"next":{"title":"Hashes","permalink":"/pike-cookbook/docs/basics/hashes"}}');var a=r(4848),s=r(8453);const t={id:"arrays",title:"Arrays",sidebar_label:"Arrays"},l="Arrays",o={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Creating Arrays",id:"creating-arrays",level:3},{value:"Accessing Array Elements",id:"accessing-array-elements",level:3},{value:"Type-Safe Arrays",id:"type-safe-arrays",level:3},{value:"Specifying a List in Your Program",id:"specifying-a-list-in-your-program",level:2},{value:"Creating Arrays from Different Sources",id:"creating-arrays-from-different-sources",level:3},{value:"Practical Example: Word Processing",id:"practical-example-word-processing",level:3},{value:"Printing a List with Commas",id:"printing-a-list-with-commas",level:2},{value:"The Problem",id:"the-problem",level:3},{value:"The Solution",id:"the-solution",level:3},{value:"Changing Array Size",id:"changing-array-size",level:2},{value:"Understanding Array Operations",id:"understanding-array-operations",level:3},{value:"Adding and Removing Elements",id:"adding-and-removing-elements",level:3},{value:"Using ADT for Queue/Stack Operations",id:"using-adt-for-queuestack-operations",level:3},{value:"Doing Something with Every Element in a List",id:"doing-something-with-every-element-in-a-list",level:2},{value:"Iterating with foreach",id:"iterating-with-foreach",level:3},{value:"Practical Examples",id:"practical-examples",level:3},{value:"Using Automap for Concise Code",id:"using-automap-for-concise-code",level:3},{value:"Modifying Elements In-Place",id:"modifying-elements-in-place",level:3},{value:"Extracting Unique Elements from a List",id:"extracting-unique-elements-from-a-list",level:2},{value:"Finding Unique Values",id:"finding-unique-values",level:3},{value:"Practical Example: Count User Logins",id:"practical-example-count-user-logins",level:3},{value:"Finding Elements in One Array but Not Another",id:"finding-elements-in-one-array-but-not-another",level:2},{value:"Set Difference",id:"set-difference",level:3},{value:"Practical Example: Missing Files",id:"practical-example-missing-files",level:3},{value:"Computing Union, Intersection, or Difference of Unique Lists",id:"computing-union-intersection-or-difference-of-unique-lists",level:2},{value:"Set Operations",id:"set-operations",level:3},{value:"Practical Example: Tag Management",id:"practical-example-tag-management",level:3},{value:"Appending One Array to Another",id:"appending-one-array-to-another",level:2},{value:"Joining Arrays",id:"joining-arrays",level:3},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Reversing an Array",id:"reversing-an-array",level:2},{value:"Reversing Arrays",id:"reversing-arrays",level:3},{value:"Practical Examples",id:"practical-examples-1",level:3},{value:"Iterating in Reverse",id:"iterating-in-reverse",level:3},{value:"Processing Multiple Elements of an Array",id:"processing-multiple-elements-of-an-array",level:2},{value:"Working with Array Slices",id:"working-with-array-slices",level:3},{value:"Using ADT for Queue Operations",id:"using-adt-for-queue-operations",level:3},{value:"Circular List Rotation",id:"circular-list-rotation",level:3},{value:"Finding the First List Element That Passes a Test",id:"finding-the-first-list-element-that-passes-a-test",level:2},{value:"Searching Arrays",id:"searching-arrays",level:3},{value:"Practical Example: User Lookup",id:"practical-example-user-lookup",level:3},{value:"Finding All Elements in an Array Matching Certain Criteria",id:"finding-all-elements-in-an-array-matching-certain-criteria",level:2},{value:"Filtering Arrays",id:"filtering-arrays",level:3},{value:"Complex Filtering",id:"complex-filtering",level:3},{value:"Sorting an Array Numerically",id:"sorting-an-array-numerically",level:2},{value:"Sorting Numbers",id:"sorting-numbers",level:3},{value:"Sorting Strings by Numeric Value",id:"sorting-strings-by-numeric-value",level:3},{value:"Sorting a List by Computable Field",id:"sorting-a-list-by-computable-field",level:2},{value:"Custom Sorting",id:"custom-sorting",level:3},{value:"Practical Example: Multi-Field Sort",id:"practical-example-multi-field-sort",level:3},{value:"Implementing a Circular List",id:"implementing-a-circular-list",level:2},{value:"Using ADT.CircularList",id:"using-adtcircularlist",level:3},{value:"Randomizing an Array",id:"randomizing-an-array",level:2},{value:"Shuffling Arrays",id:"shuffling-arrays",level:3},{value:"Program: Words",id:"program-words",level:2},{value:"Columnated Output",id:"columnated-output",level:3},{value:"Program: Permute",id:"program-permute",level:2},{value:"Generate Permutations",id:"generate-permutations",level:3},{value:"See Also",id:"see-also",level:2},{value:"Specifying a List In Your Program",id:"specifying-a-list-in-your-program-1",level:2},{value:"Printing a List with Commas",id:"printing-a-list-with-commas-1",level:2},{value:"Changing Array Size",id:"changing-array-size-1",level:2},{value:"Doing Something with Every Element in a List",id:"doing-something-with-every-element-in-a-list-1",level:2},{value:"Iterating Over an Array by Reference",id:"iterating-over-an-array-by-reference",level:2},{value:"Extracting Unique Elements from a List",id:"extracting-unique-elements-from-a-list-1",level:2},{value:"Finding Elements in One Array but Not Another",id:"finding-elements-in-one-array-but-not-another-1",level:2},{value:"Computing Union, Intersection, or Difference of Unique Lists",id:"computing-union-intersection-or-difference-of-unique-lists-1",level:2},{value:"Appending One Array to Another",id:"appending-one-array-to-another-1",level:2},{value:"Reversing an Array",id:"reversing-an-array-1",level:2},{value:"Processing Multiple Elements of an Array",id:"processing-multiple-elements-of-an-array-1",level:2},{value:"Finding the First List Element That Passes a Test",id:"finding-the-first-list-element-that-passes-a-test-1",level:2},{value:"Finding All Elements in an Array Matching Certain Criteria",id:"finding-all-elements-in-an-array-matching-certain-criteria-1",level:2},{value:"Sorting an Array Numerically",id:"sorting-an-array-numerically-1",level:2},{value:"Sorting a List by Computable Field",id:"sorting-a-list-by-computable-field-1",level:2},{value:"Implementing a Circular List",id:"implementing-a-circular-list-1",level:2},{value:"Randomizing an Array",id:"randomizing-an-array-1",level:2},{value:"Program: words",id:"program-words-1",level:2},{value:"Program: permute",id:"program-permute-1",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"arrays",children:"Arrays"})}),"\n",(0,a.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(n.p,{children:"Arrays in Pike are ordered collections of values. They're one of the most fundamental and frequently used data structures in Pike programming."}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["Pike arrays are ",(0,a.jsx)(n.strong,{children:"dynamic"})," - they can grow and shrink as needed. Unlike C arrays, you don't need to declare the size upfront."]})}),"\n",(0,a.jsx)(n.h3,{id:"creating-arrays",children:"Creating Arrays"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Basic array syntax\n//-----------------------------\n\n// Simple array of strings\narray(string) fruits = ({"apple", "banana", "cherry"});\n\n// Array of integers\narray(int) numbers = ({1, 2, 3, 4, 5});\n\n// Mixed types (using \'mixed\' type)\narray(mixed) mixed = ({"text", 42, 3.14, true});\n\n// Nested arrays (arrays within arrays)\narray(string|array(string)) nested = ({\n    "first",\n    "second",\n    ({"nested", "array"})\n});\n'})}),"\n",(0,a.jsx)(n.h3,{id:"accessing-array-elements",children:"Accessing Array Elements"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Array indexing (0-based)\n//-----------------------------\n\narray tune = ({"The", "Star-Spangled", "Banner"});\n\n// Access by index\nwrite("%s\\n", tune[0]);  // "The"\nwrite("%s\\n", tune[1]);  // "Star-Spangled"\nwrite("%s\\n", tune[2]);  // "Banner"\n\n// Negative indices count from the end\nwrite("%s\\n", tune[-1]); // "Banner" (last element)\nwrite("%s\\n", tune[-2]); // "Star-Spangled"\n'})}),"\n",(0,a.jsx)(n.h3,{id:"type-safe-arrays",children:"Type-Safe Arrays"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Using type annotations for safety\n//-----------------------------\n\n// Only strings allowed in this array\narray(string) words = ({"this", "that", "the", "other"});\n\n// Only integers allowed\narray(int) primes = ({2, 3, 5, 7, 11});\n\n// Array that can contain strings OR arrays of strings\narray(string|array(string)) flexible = ({\n    "simple string",\n    ({"nested", "array", "of", "strings"})\n});\n\n// Array where first level only contains arrays\narray(array(int)) matrix = ({\n    ({1, 2, 3}),\n    ({4, 5, 6}),\n    ({7, 8, 9})\n});\n'})}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["Using type annotations like ",(0,a.jsx)(n.code,{children:"array(string)"})," helps catch errors early when using ",(0,a.jsx)(n.code,{children:"#pragma strict_types"}),"."]})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"specifying-a-list-in-your-program",children:"Specifying a List in Your Program"}),"\n",(0,a.jsx)(n.h3,{id:"creating-arrays-from-different-sources",children:"Creating Arrays from Different Sources"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Creating arrays from various sources\n//-----------------------------\n\n// Method 1: Direct literal\narray(string) a = ({"quick", "brown", "fox"});\n\n// Method 2: Split a string into words\narray(string) words = "Why are you teasing me?" / " ";\n// Result: ({"Why", "are", "you", "teasing", "me?"})\n\n// Method 3: Split multiline text into lines\narray(string) lines = #"The boy stood on the burning deck,\nIt was as hot as glass." / "\\n";\n\n// Method 4: Read from file\narray(string) file_lines = Stdio.read_file("data.txt") / "\\n";\n\n// Method 5: Range operator\narray(int) range = ({1, 2, 3, 4, 5});  // Manual\narray(int) auto_range = Array.range(1, 6);  // Using Array module\n\n// Important: Proper Unicode string handling\narray(string) ships = ({"Ni\xf1a", "Pinta", "Santa Mar\xeda"});  // \u2713 Correct\n// NOT: array ships = "Ni\xf1a Pinta Santa Mar\xeda"/" ";        // \u2717 Wrong - splits incorrectly\n'})}),"\n",(0,a.jsx)(n.admonition,{type:"warning",children:(0,a.jsx)(n.p,{children:"When splitting strings with spaces, be careful with Unicode characters. Always use array literals when you have exact values."})}),"\n",(0,a.jsx)(n.h3,{id:"practical-example-word-processing",children:"Practical Example: Word Processing"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Process text word by word\n//-----------------------------\n\nstring text = "The quick brown fox jumps over the lazy dog";\n\n// Split into words\narray(string) words = text / " ";\n\n// Count words\nint word_count = sizeof(words);\nwrite("Word count: %d\\n", word_count);  // 9\n\n// Find words longer than 4 characters\narray(string) long_words = filter(words, lambda(string w) {\n    return sizeof(w) > 4;\n});\n\nwrite("Long words: %s\\n", long_words * ", ");\n// Output: quick, brown, jumps, over, lazy\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"printing-a-list-with-commas",children:"Printing a List with Commas"}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsx)(n.p,{children:"Properly formatting lists for display is a common task. This recipe shows how to handle lists of any size with proper grammar."})}),"\n",(0,a.jsx)(n.h3,{id:"the-problem",children:"The Problem"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Proper comma-separated lists\n//-----------------------------\n\n// Simple join - always uses commas\narray(string) items = ({"apple", "banana", "cherry"});\nwrite("%s\\n", items * ", ");\n// Output: "apple, banana, cherry"\n\n// But what about different list sizes?\n// 1 item: "apple"\n// 2 items: "apple and banana"\n// 3+ items: "apple, banana, and cherry"\n'})}),"\n",(0,a.jsx)(n.h3,{id:"the-solution",children:"The Solution"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Grammatically correct list formatting\n//-----------------------------\n\nstring commify_list(array(string) list) {\n    switch(sizeof(list)) {\n        case 0:\n            return "";\n        case 1:\n            return list[0];\n        case 2:\n            return sprintf("%s and %s", list[0], list[1]);\n        default:\n            // Use semicolons if items contain commas\n            string separator = ",";\n            foreach(list;; string item) {\n                if (search(item, ",") != -1) {\n                    separator = ";";\n                    break;\n                }\n            }\n\n            // Join all but last with separator\n            string all_but_last = list[..sizeof(list)-2] * (separator + " ");\n            return sprintf("%s, and %s", all_but_last, list[-1]);\n    }\n}\n\n// Test it\nwrite("%s\\n", commify_list(({"just one thing"}));\n// Output: "just one thing"\n\nwrite("%s\\n", commify_list(({"Mutt", "Jeff"}));\n// Output: "Mutt and Jeff"\n\nwrite("%s\\n", commify_list(({"Peter", "Paul", "Mary"}));\n// Output: "Peter, Paul, and Mary"\n\nwrite("%s\\n", commify_list(({"recycle tired, old phrases",\n                            "ponder big, happy thoughts"}));\n// Output: "recycle tired, old phrases; and ponder big, happy thoughts"\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"changing-array-size",children:"Changing Array Size"}),"\n",(0,a.jsx)(n.h3,{id:"understanding-array-operations",children:"Understanding Array Operations"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Array size operations\n//-----------------------------\n\nvoid what_about_that_array(array list) {\n    write("The array now has %d elements.\\n", sizeof(list));\n    write("The index of the last element is %d.\\n", sizeof(list)-1);\n    if (sizeof(list) > 3) {\n        write("Element #3 is %O.\\n", list[3]);\n    }\n}\n\narray people = ({"Crosby", "Stills", "Nash", "Young"});\nwhat_about_that_array(people);\n// The array now has 4 elements.\n// The index of the last element is 3.\n// Element #3 is "Young"\n\n// Removing elements (slicing)\npeople = people[..sizeof(people)-2];  // Remove last element\nwhat_about_that_array(people);\n// The array now has 3 elements.\n// The index of the last element is 2.\n\n// Growing arrays\npeople += allocate(10001 - sizeof(people));\nwhat_about_that_array(people);\n// The array now has 10001 elements.\n\n// IMPORTANT: Cannot assign to non-existent index\n// people[10000] = "value";  // ERROR! Index out of range\n'})}),"\n",(0,a.jsx)(n.admonition,{type:"warning",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Gotcha"}),": You cannot assign to an array index that doesn't exist. Arrays don't auto-expand on assignment. Use ",(0,a.jsx)(n.code,{children:"+="})," or array operations to add elements."]})}),"\n",(0,a.jsx)(n.h3,{id:"adding-and-removing-elements",children:"Adding and Removing Elements"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Adding and removing elements\n//-----------------------------\n\narray(string) list = ({"a", "b", "c"});\n\n// Add single element\nlist += ({"d"});\n// Result: ({"a", "b", "c", "d"})\n\n// Add multiple elements\nlist += ({"e", "f", "g"});\n// Result: ({"a", "b", "c", "d", "e", "f", "g"})\n\n// Remove first element\nlist = list[1..];\n// Result: ({"b", "c", "d", "e", "f", "g"})\n\n// Remove last element\nlist = list[..sizeof(list)-2];\n// Result: ({"b", "c", "d", "e", "f"})\n\n// Insert element at position\nlist = list[..1] + ({"X"}) + list[2..];\n// Result: ({"b", "c", "X", "d", "e", "f"})\n'})}),"\n",(0,a.jsx)(n.h3,{id:"using-adt-for-queuestack-operations",children:"Using ADT for Queue/Stack Operations"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Using ADT.Queue for FIFO operations\n//-----------------------------\n\n// ADT.Queue is more efficient for queue operations\nADT.Queue queue = ADT.Queue();\n\n// Add elements\nqueue->write("first");\nqueue->write("second");\nqueue->write("third");\n\n// Remove elements (FIFO)\nmixed item;\nwhile (item = queue->read()) {\n    write("Got: %O\\n", item);\n}\n// Output:\n// Got: "first"\n// Got: "second"\n// Got: "third"\n\n//-----------------------------\n// Recipe: Using ADT.Stack for LIFO operations\n//-----------------------------\n\nADT.Stack stack = ADT.Stack();\n\nstack->push("bottom");\nstack->push("middle");\nstack->push("top");\n\n// Pop elements (LIFO)\nwhile (stack->peek()) {\n    write("Popped: %O\\n", stack->pop());\n}\n// Output:\n// Popped: "top"\n// Popped: "middle"\n// Popped: "bottom"\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"doing-something-with-every-element-in-a-list",children:"Doing Something with Every Element in a List"}),"\n",(0,a.jsx)(n.h3,{id:"iterating-with-foreach",children:"Iterating with foreach"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Iterating over arrays\n//-----------------------------\n\n// Basic iteration\narray(string) users = ({"alice", "bob", "charlie"});\n\nforeach(users;; string user) {\n    write("User: %s\\n", user);\n}\n\n// Iteration with index\nforeach(users; int i; string user) {\n    write("User #%d: %s\\n", i, user);\n}\n\n// Iterating over environment variables\nforeach(sort(indices(getenv()));; string var) {\n    write("%s=%s\\n", var, getenv(var));\n}\n\n// Process file line by line\nStdio.File file = Stdio.File("data.txt", "r");\nforeach(file->line_iterator();; string line) {\n    if (sizeof(String.trim_whites(line))) {\n        write("Processing: %s\\n", line);\n    }\n}\nfile->close();\n'})}),"\n",(0,a.jsx)(n.h3,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Filter and process arrays\n//-----------------------------\n\n// Example 1: Find large files\narray(string) filenames = ({"file1.txt", "file2.log", "file3.dat"});\narray(int) sizes = ({1024, 2048, 512});\n\nforeach(sizes; int i; int size) {\n    if (size > 1024) {\n        write("%s is large (%d bytes)\\n", filenames[i], size);\n    }\n}\n\n// Example 2: Process command output\nobject pipe = Stdio.File();\nProcess.create_process(({"who"}), (["stdout": pipe->pipe()]));\n\nforeach(pipe->line_iterator();; string line) {\n    if (search(line, "root") != -1) {\n        write("Root user logged in: %s\\n", line);\n    }\n}\n\n// Example 3: Transform array elements\narray(int) numbers = ({1, 2, 3, 4, 5});\narray(int) doubled = map(numbers, lambda(int n) { return n * 2; });\nwrite("Doubled: %s\\n", (string)doubled);\n// Output: Doubled: ({2, 4, 6, 8, 10})\n'})}),"\n",(0,a.jsx)(n.h3,{id:"using-automap-for-concise-code",children:"Using Automap for Concise Code"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Pike\'s powerful automap feature\n//-----------------------------\n\n// Automap applies an operation to every element\narray(string) files = ({"file1.txt", "file2.txt", "file3.txt"});\n\n// Call function on each element\nobject stat = files->file_stat();  // Returns array of stat objects\n\n// Get file sizes\narray(int) sizes = map(files, Stdio.file_stat, Stdio.STAT_SIZE);\n\n// Method chaining with automap\narray(string) trimmed = String.trim_whites(files[*]);\n\n// Nested operations\narray(array(string)) matrix = (({({"a", "b"}, {"c", "d"}, {"e", "f"})}));\narray(string) flattened = matrix[*] * "";\n// Result: ({"ab", "cd", "ef"})\n'})}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"[*]"})," syntax (automap) is Pike's way of applying an operation to every element. It's concise and efficient!"]})}),"\n",(0,a.jsx)(n.h3,{id:"modifying-elements-in-place",children:"Modifying Elements In-Place"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Modifying array elements\n//-----------------------------\n\n// WRONG: This doesn\'t modify the array\narray(int) nums = ({1, 2, 3, 4, 5});\nforeach(nums;; int item) {\n    item--;  // This only modifies the local variable\n}\nwrite("%{%d %}\\n", nums);  // Still: 1 2 3 4 5\n\n// RIGHT: Use index to modify\narray(int) nums = ({1, 2, 3, 4, 5});\nforeach(nums; int index;) {\n    nums[index]--;\n}\nwrite("%{%d %}\\n", nums);  // Now: 0 1 2 3 4\n\n// OR: Use map to create new array\narray(int) nums = ({1, 2, 3, 4, 5});\narray(int) decremented = map(nums, lambda(int n) { return n - 1; });\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"extracting-unique-elements-from-a-list",children:"Extracting Unique Elements from a List"}),"\n",(0,a.jsx)(n.h3,{id:"finding-unique-values",children:"Finding Unique Values"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Remove duplicates from array\n//-----------------------------\n\narray(mixed) list = ({"a", "b", "a", "c", "b", "d"});\n\n// Method 1: Using mapping (most efficient)\nmapping seen = ([]);\narray(mixed) uniq = ({});\n\nforeach(list;; mixed item) {\n    if (!seen[item]) {\n        seen[item] = 1;\n        uniq += ({item});\n    }\n}\nwrite("Unique: %s\\n", (string)uniq);\n// Output: ({"a", "b", "c", "d"})\n\n// Method 2: Using indices of multiset\nmapping seen = ([]);\nforeach(list;; mixed item) {\n    seen[item]++;\n}\narray(mixed) uniq = indices(seen);\n\n// Method 3: Using multiset directly\narray(mixed) uniq = indices(({ list[*], 1 }));\n\n// Method 4: Preserving order\narray(mixed) uniq = list & indices(({ list[*], 1 }));\n'})}),"\n",(0,a.jsx)(n.h3,{id:"practical-example-count-user-logins",children:"Practical Example: Count User Logins"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Count unique users from \'who\' output\n//-----------------------------\n\nobject pipe = Stdio.File();\nProcess.create_process(({"who"}), (["stdout": pipe->pipe()]));\n\nmapping(string:int) user_count = ([]);\n\nforeach(pipe->line_iterator();; string line) {\n    // First word is username\n    array(string) parts = line / " ";\n    string user = parts[0];\n    user_count[user]++;\n}\n\narray(string) users = sort(indices(user_count));\nwrite("Unique users logged in: %d\\n", sizeof(users));\nwrite("Users: %s\\n", users * ", ");\n\nforeach(users;; string user) {\n    write("  %s: %d sessions\\n", user, user_count[user]);\n}\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"finding-elements-in-one-array-but-not-another",children:"Finding Elements in One Array but Not Another"}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsx)(n.p,{children:"Pike's set operators make this incredibly easy!"})}),"\n",(0,a.jsx)(n.h3,{id:"set-difference",children:"Set Difference"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Find elements only in first array\n//-----------------------------\n\narray A = ({1, 2, 3, 4, 5});\narray B = ({3, 4, 5, 6, 7});\n\n// Elements in A but not in B\narray a_only = A - B;\nwrite("Only in A: %s\\n", (string)a_only);\n// Output: ({1, 2})\n\n// Elements in B but not in A\narray b_only = B - A;\nwrite("Only in B: %s\\n", (string)b_only);\n// Output: ({6, 7})\n\n// Elements in both\narray both = A & B;\nwrite("In both: %s\\n", (string)both);\n// Output: ({3, 4, 5})\n\n// All unique elements (union)\narray all = A | B;\nwrite("All: %s\\n", (string)all);\n// Output: ({1, 2, 3, 4, 5, 6, 7})\n\n// Elements in either but not both (symmetric difference)\narray xor = A ^ B;\nwrite("XOR: %s\\n", (string)xor);\n// Output: ({1, 2, 6, 7})\n'})}),"\n",(0,a.jsx)(n.h3,{id:"practical-example-missing-files",children:"Practical Example: Missing Files"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Find which required files are missing\n//-----------------------------\n\narray(string) required = ({"config.txt", "data.db", "cache.bin", "index.idx"});\narray(string) existing = ({"config.txt", "cache.bin"});\n\n// Find missing files\narray(string) missing = required - existing;\n\nif (sizeof(missing)) {\n    werror("Missing required files:\\n");\n    foreach(missing;; string file) {\n        werror("  - %s\\n", file);\n    }\n    exit(1);\n}\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"computing-union-intersection-or-difference-of-unique-lists",children:"Computing Union, Intersection, or Difference of Unique Lists"}),"\n",(0,a.jsx)(n.h3,{id:"set-operations",children:"Set Operations"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Mathematical set operations\n//-----------------------------\n\narray(int) a = ({1, 3, 5, 6, 7, 8});\narray(int) b = ({2, 3, 5, 7, 9});\n\n// Union: all elements from both arrays\narray(int) union = a | b;\nwrite("Union: %s\\n", (string)union);\n// Output: ({1, 3, 5, 6, 7, 8, 2, 9})\n\n// Intersection: elements common to both\narray(int) intersection = a & b;\nwrite("Intersection: %s\\n", (string)intersection);\n// Output: ({3, 5, 7})\n\n// Difference: elements in a but not in b\narray(int) difference = a - b;\nwrite("Difference: %s\\n", (string)difference);\n// Output: ({1, 6, 8})\n\n// Symmetric difference: elements in either but not both\narray(int) symdiff = a ^ b;\nwrite("Symmetric difference: %s\\n", (string)symdiff);\n// Output: ({1, 6, 8, 2, 9})\n'})}),"\n",(0,a.jsx)(n.h3,{id:"practical-example-tag-management",children:"Practical Example: Tag Management"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Managing blog post tags\n//-----------------------------\n\n// User\'s current tags\narray(string) user_tags = ({"pike", "programming", "tutorial"});\n\n// Suggested related tags\narray(string) suggested = ({"programming", "web", "pike", "database"});\n\n// Tags user already has (don\'t suggest again)\narray(string) already_has = user_tags & suggested;\nwrite("You already have: %s\\n", (string)already_has);\n// Output: ({"programming", "pike"})\n\n// New tags to suggest\narray(string) new_suggestions = suggested - user_tags;\nwrite("New suggestions: %s\\n", (string)new_suggestions);\n// Output: ({"web", "database"})\n\n// All tags combined\narray(string) all_tags = user_tags | suggested;\nwrite("All related tags: %s\\n", (string)all_tags);\n// Output: ({"pike", "programming", "tutorial", "web", "database"})\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"appending-one-array-to-another",children:"Appending One Array to Another"}),"\n",(0,a.jsx)(n.h3,{id:"joining-arrays",children:"Joining Arrays"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Combining arrays\n//-----------------------------\n\narray(string) members = ({"Time", "Flies"});\narray(string) initiates = ({"An", "Arrow"});\n\n// Append arrays\nmembers += initiates;\nwrite("%s\\n", members * " ");\n// Output: "Time Flies An Arrow"\n\n// Insert at specific position\nmembers = members[..1] + ({"Like"}) + members[2..];\nwrite("%s\\n", members * " ");\n// Output: "Time Flies Like An Arrow"\n\n// Replace elements\nmembers[0] = "Fruit";\nmembers = members[..sizeof(members)-3] + ({"A", "Banana"});\nwrite("%s\\n", members * " ");\n// Output: "Fruit Flies Like A Banana"\n'})}),"\n",(0,a.jsx)(n.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:"//-----------------------------\n// Recipe: Efficient array building\n//-----------------------------\n\n// Method 1: Building array incrementally\n// (Less efficient for large arrays)\narray(int) result = ({});\nfor (int i = 0; i < 1000; i++) {\n    result += ({i});  // Creates new array each time\n}\n\n// Method 2: Pre-allocate when size is known\n// (More efficient)\narray(int) result = allocate(1000);\nfor (int i = 0; i < 1000; i++) {\n    result[i] = i;\n}\n\n// Method 3: Use Array.range for sequences\narray(int) result = Array.range(0, 1000);\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["In Pike, arrays are immutable. Operations like ",(0,a.jsx)(n.code,{children:"+="})," create a new array. For very large arrays, consider using ADT data structures or pre-allocation."]})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"reversing-an-array",children:"Reversing an Array"}),"\n",(0,a.jsx)(n.h3,{id:"reversing-arrays",children:"Reversing Arrays"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Reverse array order\n//-----------------------------\n\narray(string) arr = ({"first", "second", "third", "fourth"});\n\n// Create reversed copy\narray(string) reversed = reverse(arr);\nwrite("Reversed: %s\\n", (string)reversed);\n// Output: ({"fourth", "third", "second", "first"})\n\n// Reverse in-place (modifies original)\narr = reverse(arr);\n'})}),"\n",(0,a.jsx)(n.h3,{id:"practical-examples-1",children:"Practical Examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Useful reversal patterns\n//-----------------------------\n\n// Example 1: Process lines in reverse order\narray(string) lines = Stdio.read_file("log.txt") / "\\n";\nforeach(reverse(lines);; string line) {\n    write("%s\\n", line);\n}\n\n// Example 2: Sort descending\narray(string) users = ({"alice", "bob", "charlie", "david"});\narray(string) descending = reverse(sort(users));\nwrite("Descending: %s\\n", (string)descending);\n// Output: ({"david", "charlie", "bob", "alice"})\n\n// Example 3: Reverse with custom comparison\narray(string) names = ({"Alice", "bob", "Charlie", "david"});\n\n// Case-insensitive descending sort\narray(string) sorted = Array.sort_array(names, lambda(string a, string b) {\n    return lower_case(a) > lower_case(b);\n});\n'})}),"\n",(0,a.jsx)(n.h3,{id:"iterating-in-reverse",children:"Iterating in Reverse"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Iterate array backwards\n//-----------------------------\n\narray(int) numbers = ({1, 2, 3, 4, 5});\n\n// Method 1: foreach with reverse\nforeach(reverse(numbers);; int n) {\n    write("%d\\n", n);\n}\n\n// Method 2: Traditional for loop\nfor (int i = sizeof(numbers) - 1; i >= 0; i--) {\n    write("%d\\n", numbers[i]);\n}\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"processing-multiple-elements-of-an-array",children:"Processing Multiple Elements of an Array"}),"\n",(0,a.jsx)(n.h3,{id:"working-with-array-slices",children:"Working with Array Slices"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Process array chunks\n//-----------------------------\n\narray(int) arr = ({0, 1, 2, 3, 4, 5, 6, 7, 8, 9});\nint n = 3;\n\n// Get first n elements\narray(int) front = arr[..n-1];\nwrite("Front: %s\\n", (string)front);\n// Output: ({0, 1, 2})\n\n// Get elements after first n\narr = arr[n..];\nwrite("Rest: %s\\n", (string)arr);\n// Output: ({3, 4, 5, 6, 7, 8, 9})\n\n// Get last n elements\narray(int) back = arr[sizeof(arr)-n..];\nwrite("Back: %s\\n", (string)back);\n// Output: ({7, 8, 9})\n\n// Remove last n elements\narr = arr[..sizeof(arr)-(n+1)];\nwrite("Remaining: %s\\n", (string)arr);\n// Output: ({3, 4, 5, 6})\n'})}),"\n",(0,a.jsx)(n.h3,{id:"using-adt-for-queue-operations",children:"Using ADT for Queue Operations"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Efficient queue with ADT.CircularList\n//-----------------------------\n\nADT.CircularList list = ADT.CircularList(({"Peter", "Paul", "Mary", "Jim", "Tim"}));\n\n// Shift2: Remove and return first 2 elements\narray shift2(ADT.CircularList list) {\n    return ({list->pop_front(), list->pop_front()});\n}\n\narray(string) first_two = shift2(list);\nwrite("First two: %s\\n", (string)first_two);\n// Output: ({"Peter", "Paul"})\n// Remaining: ({"Mary", "Jim", "Tim"})\n\n// Pop2: Remove and return last 2 elements\narray pop2(ADT.CircularList list) {\n    return reverse(({list->pop_back(), list->pop_back()});\n}\n\narray(string) last_two = pop2(list);\nwrite("Last two: %s\\n", (string)last_two);\n// Output: ({"Jim", "Tim"})\n// Remaining: ({"Mary"})\n'})}),"\n",(0,a.jsx)(n.h3,{id:"circular-list-rotation",children:"Circular List Rotation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Rotate circular list\n//-----------------------------\n\nADT.CircularList processes = ADT.CircularList(({1, 2, 3, 4, 5}));\n\nmixed grab_and_rotate(ADT.CircularList list) {\n    mixed element = list->pop_front();\n    list->push_back(element);  // Move to end\n    return element;\n}\n\n// Round-robin processing\nwhile (1) {\n    int process = grab_and_rotate(processes);\n    write("Handling process %d\\n", process);\n    sleep(1);\n}\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"finding-the-first-list-element-that-passes-a-test",children:"Finding the First List Element That Passes a Test"}),"\n",(0,a.jsx)(n.h3,{id:"searching-arrays",children:"Searching Arrays"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Find elements matching criteria\n//-----------------------------\n\narray(string) arr = ({"apple", "banana", "cherry", "date", "elderberry"});\n\n// Method 1: Using search() for exact match\nint pos = search(arr, "cherry");\nif (pos != -1) {\n    write("Found at index %d: %s\\n", pos, arr[pos]);\n}\n\n// Method 2: Using Array.search_array() with predicate\nstring test(string element) {\n    return sizeof(element) == 5;\n}\n\nint match_pos = Array.search_array(arr, test);\nif (match_pos != -1) {\n    write("First 5-letter word: %s\\n", arr[match_pos]);\n    // Output: "apple"\n}\n\n// Method 3: Using filter() to get all matches\narray(string) long_words = filter(arr, lambda(string word) {\n    return sizeof(word) > 5;\n});\nwrite("Long words: %s\\n", (string)long_words);\n// Output: ({"banana", "cherry", "elderberry"})\n\n// Method 4: Using has_value() for multiset lookup\nif (has_value(arr, "date")) {\n    write("Found \'date\' in array\\n");\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"practical-example-user-lookup",children:"Practical Example: User Lookup"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Find user by property\n//-----------------------------\n\narray(mapping(string:mixed)) users = ({\n    (["name": "Alice", "id": 1, "active": true]),\n    (["name": "Bob", "id": 2, "active": false]),\n    (["name": "Charlie", "id": 3, "active": true])\n});\n\n// Find first active user\nmapping(string:mixed)|zero active_user = Array.search_array(\n    users,\n    lambda(mapping u) { return u->active; }\n);\n\nif (active_user) {\n    write("Found active user: %s (ID: %d)\\n",\n          active_user->name, active_user->id);\n}\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"finding-all-elements-in-an-array-matching-certain-criteria",children:"Finding All Elements in an Array Matching Certain Criteria"}),"\n",(0,a.jsx)(n.h3,{id:"filtering-arrays",children:"Filtering Arrays"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Filter array by condition\n//-----------------------------\n\narray(int) numbers = ({1, 2, 3, 4, 5, 6, 7, 8, 9, 10});\n\n// Method 1: Using filter()\narray(int) evens = filter(numbers, lambda(int n) {\n    return n % 2 == 0;\n});\nwrite("Even numbers: %s\\n", (string)evens);\n// Output: ({2, 4, 6, 8, 10})\n\n// Method 2: Using map and subtract\narray(int) odds = map(numbers, lambda(int n) {\n    return n % 2 ? n : 0;\n}) - ({0});\n\n// Method 3: Manual iteration\narray(int) primes = ({});\nforeach(numbers;; int n) {\n    if (is_prime(n)) {\n        primes += ({n});\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"complex-filtering",children:"Complex Filtering"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Filter with multiple conditions\n//-----------------------------\n\narray(mapping(string:mixed)) products = ({\n    (["name": "Laptop", "price": 999, "stock": 5]),\n    (["name": "Mouse", "price": 29, "stock": 50]),\n    (["name": "Keyboard", "price": 79, "stock": 0]),\n    (["name": "Monitor", "price": 299, "stock": 12])\n});\n\n// Find affordable, in-stock items\narray(mapping) affordable = filter(products, lambda(mapping p) {\n    return p->price < 100 && p->stock > 0;\n});\n\nwrite("Affordable items:\\n");\nforeach(affordable;; mapping item) {\n    write("  - %s: $%d (%d in stock)\\n",\n          item->name, item->price, item->stock);\n}\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"sorting-an-array-numerically",children:"Sorting an Array Numerically"}),"\n",(0,a.jsx)(n.h3,{id:"sorting-numbers",children:"Sorting Numbers"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Sort arrays of numbers\n//-----------------------------\n\n// Integers and floats are sorted numerically by default\narray(int) unsorted = ({42, 7, 13, 99, 1, 23});\narray(int) sorted = sort(unsorted);\nwrite("Sorted: %s\\n", (string)sorted);\n// Output: ({1, 7, 13, 23, 42, 99})\n\n// Note: sort() is destructive - modifies original\narray(int) numbers = ({5, 2, 8, 1, 9});\nsort(numbers);\nwrite("After sort(): %s\\n", (string)numbers);\n// Output: ({1, 2, 5, 8, 9})\n\n// To preserve original, copy first\narray(int) original = ({5, 2, 8, 1, 9});\narray(int) sorted = copy_value(original);\nsort(sorted);\n'})}),"\n",(0,a.jsx)(n.h3,{id:"sorting-strings-by-numeric-value",children:"Sorting Strings by Numeric Value"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Sort strings by embedded numbers\n//-----------------------------\n\narray(string) unsorted = ({"123asdf", "3poiu", "23qwert", "3ayxcv"});\n\n// Extract numbers and sort by them\narray(int) numeric = map(unsorted, lambda(string s) {\n    return (int)array_sscanf(s, "%d")[0];\n});\n\nsort(numeric, unsorted);\nwrite("Sorted numerically: %s\\n", (string)unsorted);\n// Output: ({"3poiu", "3ayxcv", "23qwert", "123asdf"})\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"sorting-a-list-by-computable-field",children:"Sorting a List by Computable Field"}),"\n",(0,a.jsx)(n.h3,{id:"custom-sorting",children:"Custom Sorting"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Sort by computed field\n//-----------------------------\n\n// Method 1: Using Array.sort_array with comparison function\narray(mapping) employees = ({\n    (["name": "Alice", "salary": 50000, "age": 30]),\n    (["name": "Bob", "salary": 60000, "age": 25]),\n    (["name": "Charlie", "salary": 45000, "age": 35])\n});\n\n// Sort by name\narray sorted_by_name = Array.sort_array(\n    employees,\n    lambda(mapping a, mapping b) {\n        return a->name > b->name;\n    }\n);\n\n// Sort by salary (descending)\narray sorted_by_salary = Array.sort_array(\n    employees,\n    lambda(mapping a, mapping b) {\n        return a->salary < b->salary;\n    }\n);\n\n// Method 2: Pre-compute sort keys (more efficient)\narray compute(array items, string field) {\n    return map(items, lambda(mapping m) { return m[field]; });\n}\n\narray keys = compute(employees, "age");\nsort(keys, employees);\nwrite("Sorted by age: %s\\n", employees->name * ", ");\n'})}),"\n",(0,a.jsx)(n.h3,{id:"practical-example-multi-field-sort",children:"Practical Example: Multi-Field Sort"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Sort by multiple fields\n//-----------------------------\n\narray(mapping) users = ({\n    (["name": "Alice", "age": 30]),\n    (["name": "Bob", "age": 25]),\n    (["name": "Alice", "age": 25]),\n    (["name": "Charlie", "age": 30])\n});\n\n// Sort by name first, then age\narray sorted = Array.sort_array(users, lambda(mapping a, mapping b) {\n    if (a->name != b->name)\n        return a->name > b->name;\n    return a->age < b->age;  // If names equal, sort by age\n});\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"implementing-a-circular-list",children:"Implementing a Circular List"}),"\n",(0,a.jsx)(n.h3,{id:"using-adtcircularlist",children:"Using ADT.CircularList"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Rotate through elements\n//-----------------------------\n\nADT.CircularList circular = ADT.CircularList(({"a", "b", "c", "d"}));\n\n// Rotate: move first element to end\ncircular->push_back(circular->pop_front());\n\n// Rotate: move last element to front\ncircular->push_front(circular->pop_back());\n\n// Round-robin processing\nmixed grab_and_rotate(ADT.CircularList list) {\n    mixed element = list->pop_front();\n    list->push_back(element);  // Move to back of queue\n    return element;\n}\n\nADT.CircularList processes = ADT.CircularList(({1, 2, 3, 4, 5}));\nwhile (1) {\n    int process = grab_and_rotate(processes);\n    write("Handling process %d\\n", process);\n    sleep(1);\n}\n'})}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["Use ",(0,a.jsx)(n.code,{children:"ADT.CircularList"})," for round-robin scheduling, buffer management, or any scenario where you need to cycle through elements."]})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"randomizing-an-array",children:"Randomizing an Array"}),"\n",(0,a.jsx)(n.h3,{id:"shuffling-arrays",children:"Shuffling Arrays"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Randomize array order\n//-----------------------------\n\n// Method 1: Using Array.shuffle() (Fisher-Yates)\narray(int) cards = Array.range(1, 53);  // Deck of cards\nArray.shuffle(cards);\nwrite("Shuffled: %s\\n", (string)cards[0..5]);\n\n// Method 2: Manual shuffle (for learning)\nvoid naive_shuffle(array list) {\n    for (int i = 0; i < sizeof(list); i++) {\n        int j = random(sizeof(list));\n        [list[i], list[j]] = ({list[j], list[i]});\n    }\n}\n\n// Method 3: Using multiset\narray set_shuffle(array list) {\n    multiset elements = (multiset)list;\n    array result = ({});\n\n    while (sizeof(elements)) {\n        mixed pick = random(elements);\n        result += ({pick});\n        elements[pick]--;\n    }\n\n    return result;\n}\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"program-words",children:"Program: Words"}),"\n",(0,a.jsx)(n.h3,{id:"columnated-output",children:"Columnated Output"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'#!/usr/bin/env pike\n#pragma strict_types\n\n// words - gather lines, present in columns\n\nint main() {\n    // Read all input\n    array(string) words = Stdio.stdin.read() / "\\n";\n\n    // Find maximum word length\n    int maxlen = sort(sizeof(words[*]))[-1];\n    maxlen++;\n\n    // Calculate columns based on terminal width\n    int cols = Stdio.stdout->tcgetattr()->columns / maxlen;\n    int rows = (sizeof(words) / cols) + 1;\n\n    // Create format string\n    string mask = "%{%-" + maxlen + "s%}\\n";\n\n    // Transpose and display\n    words = Array.transpose(words / rows);\n    write(mask, words[*]);\n\n    return 0;\n}\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"program-permute",children:"Program: Permute"}),"\n",(0,a.jsx)(n.h3,{id:"generate-permutations",children:"Generate Permutations"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'#!/usr/bin/env pike\n#pragma strict_types\n\n// permute - generate all permutations of input\n\nint factorial(int n) {\n    int s = 1;\n    while (n) s *= n--;\n    return s;\n}\n\nvoid permute(array items, array|void perms) {\n    if (!perms) perms = ({});\n    if (!sizeof(items)) {\n        write("%s\\n", perms * " ");\n    } else {\n        foreach(items; int i;) {\n            array newitems = items[..i-1] + items[i+1..];\n            array newperms = items[i..i] + perms;\n            permute(newitems, newperms);\n        }\n    }\n}\n\nint main() {\n    string line;\n    while (line = Stdio.stdin->gets()) {\n        permute(line / " ");\n    }\n    return 0;\n}\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/basics/hashes",children:"Hashes"})," - Key-value data structures"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/basics/strings",children:"Strings"})," - Text processing"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/basics/pattern-matching",children:"Pattern Matching"})," - Finding patterns in data"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/basics/subroutines",children:"Subroutines"})," - Functions and lambdas"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"specifying-a-list-in-your-program-1",children:"Specifying a List In Your Program"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'// list\narray(string) a = ({ "quick", "brown", "fox" });\n// words\narray(string) a = "Why are you teasing me?"/" ";\n// lines\narray(string) lines = #"The boy stood on the burning deck,\nIt was as hot as glass."/"\\n";\n// file\narray(string) bigarray = Stdio.read_file("mydatafile")/"\\n";\n// the quoting issues do not apply.\narray(string) ships = "Ni\xf1a Pinta Santa Mar\xeda"/" ";         // wrong\narray(string) ships = ({ "Ni\xf1a", "Pinta", "Santa Mar\xeda" }); // right\n'})}),"\n",(0,a.jsx)(n.h2,{id:"printing-a-list-with-commas-1",children:"Printing a List with Commas"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'// download the following standalone program\n#!/usr/bin/pike\n// chapter 4.2\n// commify_series - show proper comma insertion in list output\narray(array(string)) lists =\n({\n({ "just one thing" }),\n({ "Mutt", "Jeff" }),\n({ "Peter", "Paul", "Mary" }),\n({ "To our parents", "Mother Theresa", "God" }),\n({ "pastrami", "ham and cheese", "peanut butter and jelly", "tuna" }),\n({ "recycle tired, old phrases", "ponder big, happy thoughts" }),\n({ "recycle tired, old phrases",\n"ponder big, happy thoughts",\n"sleep and dream peacefully" }),\n});\nvoid main()\n{\nwrite("The list is: %s.\\n", commify_list(lists[*])[*]);\n}\nstring commify_list(array(string) list)\n{\nswitch(sizeof(list))\n{\ncase 1: return list[0];\ncase 2: return sprintf("%s and %s", @list);\ndefault:\nstring seperator=",";\nint count;\nwhile(count<sizeof(list) && search(list[count], seperator)==-1)\ncount++;\nif(count<sizeof(list))\nseperator=";";\nreturn sprintf("%{%s"+seperator+" %}and %s",\nlist[..sizeof(list)-2], list[-1]);\n}\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"changing-array-size-1",children:"Changing Array Size"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'void what_about_that_array(array list)\n{\nwrite("The array now has %d elements.\\n", sizeof(list));\nwrite("The index of the last element is %d.\\n", sizeof(list)-1);\nwrite("Element #3 is %O.\\n", list[3]);\n}\narray people = ({ "Crosby", "Stills", "Nash", "Young" });\nwhat_about_that_array(people);\n// The array now has 4 elements.\n// The index of the last element is 3.\n// Element #3 is "Young".\npeople=people[..sizeof(people)-2];\nwhat_about_that_array(people);\n// The array now has 3 elements.\n// The index of the last element is 2.\n// Index 3 is out of array range -3..2.\npeople+=allocate(10001-sizeof(people));\nwhat_about_that_array(people);\n// The array now has 10001 elements.\n// The index of the last element is 10000.\n// Element #3 is 0.\narray people = ({ "Crosby", "Stills", "Nash", "Young" }); // resetting the array\npeople[10000]=0;\n// Index 10000 is out of array range -4..3.\n// accessing a nonexisting index is always an error.\n// arrays can not be enlarged this way.\n'})}),"\n",(0,a.jsx)(n.h2,{id:"doing-something-with-every-element-in-a-list-1",children:"Doing Something with Every Element in a List"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'foreach(list; int index; mixed item)\n{\n// do something with item (and possibly index)\n}\nforeach(bad_users;; object user)\n{\ncomplain(user);\n}\n// for such simple cases pike provides a convenient automap feature:\ncomplain(bad_users[*]);\n// will do the same as the foreach above.\nforeach(sort(indices(getenv()));; string var)\n{\nwrite("%s=%s\\n", var, getenv(var));\n}\n// if you don\'t need an assurance that the indices are sorted (they most likely\n// are sorted anyways) you may use:\nforeach(getenv(); string var; string value)\n{\nwrite("%s=%s\\n", var, value);\n}\nforeach(all_users;; string user)\n{\nint disk_space = get_usage(user);\nif(disk_space > MAX_QUOTA)\ncomplain(user);\n}\n// continue; to jump to the next\n// break; to stop the loop\n// redo can be done by doing a loop with the proper checks in the block\nobject pipe=Stdio.File();\nProcess.create_process(({ "who" }), ([ "stdout":pipe->pipe() ]));\nforeach(pipe->line_iterator();; string line)\n{\nif(search(line, "tchrist")>-1)\nwrite(line+"\\n");\n}\nobject fh=Stdio.File("somefile");\nforeach(fh->line_iterator(); int linenr; string line)\n{\nforeach(Process.split_quoted_string(line);; string word)//split on whitespace\n{\nwrite(reverse(word));\n}\n}\narray(int) list = ({ 1,2,3 });\nforeach(list;; int item)\n{\nitem--;\n}\nwrite("%{%d %}\\n", list);\n// Result: 1 2 3\n// we can still use foreach instead of for,\n// because foreach gives us the index as well:\nforeach(list; int index;)\n{\nlist[index]--;\n}\nwrite("%{%d %}\\n", list);\n// Result: 0 1 2\narray a = ({ 0.5, 3 });\narray b = ({ 0, 1 });\n// foreach handles only one array so there is nothing to gain here.\n// better use automap:\narray a_ = a[*]*7;\narray b_ = b[*]*7;\nwrite("%{%O %}\\n", a_+b_);\n// 3.500000 21 0 7\nstring scalar = " abc ";\narray(string) list = ({ " a ", " b " });\nmapping(mixed:string) hash = ([ "a":" a ", "b":" b " ]);\nscalar = String.trim_whites(scalar);\nlist = String.trim_whites(list[*]);\nforeach(hash; int key;)\n{\nhash[key]=String.trim_whites(hash[key]);\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"iterating-over-an-array-by-reference",children:"Iterating Over an Array by Reference"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:"// pike does not distinguish between arrays and array references\n// (they are all references anyways) so this section does not apply\n"})}),"\n",(0,a.jsx)(n.h2,{id:"extracting-unique-elements-from-a-list-1",children:"Extracting Unique Elements from a List"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'mapping seen = ([]);\narray   uniq = ({});\nforeach(list;; mixed item)\n{\nif(!seen[item])\nseen[item] = 1;\nelse\nuniq += ({ item });\n}\nmapping seen = ([]);\narray   uniq = ({});\nforeach(list;; mixed item)\n{\nif(!seen[item]++)\nuniq += ({ item });\n}\nmapping seen = ([]);\narray   uniq = ({});\nforeach(list;; mixed item)\n{\nif(!seen[item]++)\nsome_func(item);\n}\n// the following is probably the most natural for pike\nmapping seen = ([]);\narray   uniq = ({});\nforeach(list;; mixed item)\n{\nseen[item]++;\n}\nuniq = indices(seen);\n// not necessarily faster but shorter:\narray uniq = indices(({ list[*],1 }));\n// also short, and preserving the originaal order:\narray uniq = list&indices(({ list[*],1 }));\nobject pipe = Stdio.File();\nProcess.create_process(({ "who" }), ([ "stdout":pipe->pipe() ]));\nmapping ucnt = ([]);\nforeach(pipe->line_iterator();; string line)\n{\nucnt[(line/" ")[0]]++;\n}\narray users = sort(indices(ucnt));\nwrite("users logged in: %s\\n", users*" ");\n'})}),"\n",(0,a.jsx)(n.h2,{id:"finding-elements-in-one-array-but-not-another-1",children:"Finding Elements in One Array but Not Another"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:"// one of pikes strenghts are operators.\n// the following are the only idiomatic solutions to the problem\narray A = ({ 1, 2, 3 });\narray B = ({ 2, 3, 4 });\narray aonly = A-B;\n// Result: ({ 1 });\n"})}),"\n",(0,a.jsx)(n.h2,{id:"computing-union-intersection-or-difference-of-unique-lists-1",children:"Computing Union, Intersection, or Difference of Unique Lists"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:"array a = ({ 1, 3, 5, 6, 7, 8 });\narray b = ({ 2, 3, 5, 7, 9 });\n// union:\narray union = a|b;\n// ({ 1, 3, 5, 6, 7, 8, 2, 9 })\n// intersection\narray intersection = a&b;\n// ({ 3, 5, 7 })\n// difference\narray difference = a-b;\n// ({ 1, 6, 8 })\n// symetric difference\narray symdiff= a^b;\n// ({ 1, 6, 8, 2, 9 })\n"})}),"\n",(0,a.jsx)(n.h2,{id:"appending-one-array-to-another-1",children:"Appending One Array to Another"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'// join arrays\n// appending to an array will always create a new array and pike is designed to\n// handle this efficiently.\narray members = ({ "Time", "Flies" });\narray initiates = ({ "An", "Arrow" });\nmembers += initiates;\n// members is now ({ "Time", "Flies", "An", "Arrow" })\nmembers = members[..1]+({ "Like" })+members[2..];\nwrite("%s\\n", members*" ");\nmembers[0] = "Fruit";\nmembers = members[..sizeof(members)-3]+({ "A", "Banana" });\nwrite("%s\\n", members*" ");\n// Time Flies Like An Arrow\n// Fruit Flies Like A Banana\n'})}),"\n",(0,a.jsx)(n.h2,{id:"reversing-an-array-1",children:"Reversing an Array"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:"// almost any operation you do on the elements will add more overhead than\n// reversing the array, if there is any possible optimization, pike will do it\n// for you.\narray reversed = reverse(arr);\n// unless you were going to use for anyways then foreach(reverse( ...)) is\n// preferable.\nforeach(reverse(arr);; mixed item)\n{\n// do something with item\n}\nfor(int i=sizeof(arr)-1; i<=0; i--)\n{\n// so something with arr[i]\n}\narray ascending = sort(users);\narray descending = reverse(sort(users));\n// reverse(sort()) is faster by a magnitude\narray descending = Array.sort_array(users, lambda(mixed a, mixed b)\n{\nreturn a<b;\n}\n);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"processing-multiple-elements-of-an-array-1",children:"Processing Multiple Elements of an Array"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'array arr = ({ 0,1,2,3,4,5,6,7,8,9 });\nint n=3;\narray front = arr[..n-1];\narr = arr[n..];\narray back = arr[sizeof(arr)-n..];\narr = arr[..sizeof(arr)-(n+1)];\n// since new arrays are created if elements are added or removed\n// shift and pop are not usefull here.\n// if you need shift and pop capabilities use the ADT classes:\narray shift2(ADT.Queue queue)\n{\nreturn ({ queue->read(), queue->read() });\n}\nADT.Queue friends = ADT.Queue("Peter", "Paul", "Mary", "Jim", "Tim");\nstring this, that;\n[this, that] = shift2(friends);\n// this contains Peter, that has Paul, and\n// friends has Mary, Jim, and Tim\nADT.Stack beverages = ADT.Stack();\nbeverages->set_stack(({ "Dew", "Jolt", "Cola", "Sprite", "Fresca" }));\narray pair = beverages->pop(2); // implementing pop2 would gain nothing here\n// pair[0] contains Sprite, pair[1] has Fresca,\n// and beverages has (Dew, Jolt, Cola)\n// to be able to shift and pop on the same list use the following:\narray shift2(ADT.CircularList list)\n{\nreturn ({ list->pop_front(), list->pop_front() });\n}\narray pop2(ADT.CircularList list)\n{\nreturn reverse( ({ list->pop_back(), list->pop_back() }) );\n}\nADT.CircularList friends = ADT.CircularList( ({"Peter", "Paul", "Mary", "Jim", "Tim"}) );\nstring this, that;\n[this, that] = shift2(friends);\n// this contains Peter, that has Paul, and\n// friends has Mary, Jim, and Tim\nADT.CircularList beverages = ADT.CircularList( ({ "Dew", "Jolt", "Cola", "Sprite", "Fresca" }) );\narray pair = pop2(beverates);\n// pair[0] contains Sprite, pair[1] has Fresca,\n// and beverages has (Dew, Jolt, Cola)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"finding-the-first-list-element-that-passes-a-test-1",children:"Finding the First List Element That Passes a Test"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:"mixed match = search(arr, element);\nint test(mixed element)\n{\nif(sizeof(element)==5)\nreturn 1;\nelse\nreturn 0;\n}\nmixed match = Array.search_array(arr, test);\nif(match != -1)\n{\n// do something with arr[match]\n}\nelse\n{\n// do something else\n}\n// another convenient way if you do many tests on the same list,\n// and you do not care for the position is:\nif( (multiset)arr[element] )\n{\n// found\n}\nelse\n{\n// not found\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"finding-all-elements-in-an-array-matching-certain-criteria-1",children:"Finding All Elements in an Array Matching Certain Criteria"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:"array matching=({});\nforeach(list;; mixed element)\n{\nif(test(element))\nmatching+=({ element });\n}\narray matching = map(list, test)-({ 0 });\narray matching = test(list[*])-({ 0 });\n// apply test() on each element in list, collect the results, and remove\n// results that are 0.\n"})}),"\n",(0,a.jsx)(n.h2,{id:"sorting-an-array-numerically-1",children:"Sorting an Array Numerically"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'// since pike has different types for strings and numbers, ints and floats are\n// of course sorted numerically\n// (sort() is destructive, the original array is changed)\narray(int) unsorted = ...;\narray(int) sorted = sort(unsorted);\n// but suppose you want to sort an array of strings by their numeric value then\n// things get a bit more interresting:\narray(string) unsorted = ({ "123asdf", "3poiu", "23qwert", "3ayxcv" });\nsort((array(int))unsorted, unsorted);\n// unsorted is now sorted.\n'})}),"\n",(0,a.jsx)(n.h2,{id:"sorting-a-list-by-computable-field-1",children:"Sorting a List by Computable Field"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'array unordered;\nint compare(mixed a, mixed b)\n{\n// return comparison of a and b\n}\narray ordered = Array.sort_array(unordered, compare);\n//-------------------------------------------------------------\nint compute(mixed element)\n{\n// return computation from element\n}\narray precomputed = map(unordered, compute);\nsort(precomputed, unordered); // will destructively sort unordered in the same\narray ordered = unordered;    // manner as precomputed.\n//-------------------------------------------------------------\nsort(map(unordered, compute), unordered); // without a temp variable\nsort(compute(unordered[*]), unordered);   // using the automap operator\n// both get compiled to the same code\n//-------------------------------------------------------------\narray ordered = sort(employees, lambda(mixed a, mixed b)\n{\nreturn a->name > b->name;\n}\n);\n//-------------------------------------------------------------\nforeach(Array.sort_array(employees,\nlambda(mixed a, mixed b){ return a->name > b->name; })\n;; mixed employee)\n{\nwrite("%s earns $%d\\n", employee->name, employee->salary);\n}\n//-------------------------------------------------------------\narray ordered_employees =\nArray.sort_array(employees,\nlambda(mixed a, mixed b){ return a->name > b->name; });\nforeach(ordered_employees;; mixed employee)\n{\nwrite("%s earns $%d\\n", employee->name, employee->salary);\n}\nmapping bonus;\nforeach(ordered_employees;; mixed employee)\n{\n// you are not supposed to use the social security number as an id\nif(bonus[employee->id])\nwrite("%s got a bonus!\\n", employee->name);\n}\n//-------------------------------------------------------------\narray sorted = Array.sort_array(employees,\nlambda(mixed a, mixed b)\n{\nif(a->name!=b->name)\nreturn (a->name < b->name)\nreturn (b->age < a->age);\n}\n);\n//-------------------------------------------------------------\narray(array) users = System.get_all_users();\nsort(users);\n// System.get_all_users() returns an array of arrays, with the name as the\n// first element in each inner array, sort handles multidimensional arrays, so\n// we can skip creating our own sort function.\n// if we wanted to sort on something else one could rearrange the array:\narray user;\nwhile(user=System.getpwent())\n{\nusers += ({ user[2], user });\n}\nSystem.endpwent();\nsort(users);  // now we are sorting by uid.\n// alternative:\narray(array) users = System.get_all_users();\nsort(users[*][2], users);\nwrite(users[*][0]*"\\n");\nwrite("\\n");\n//-------------------------------------------------------------\narray names;\narray sorted = Array.sort_array(names, lambda(mixed a, mixed b)\n{\nreturn a[1] < b[1];\n}\n);\n// faster:\nsort(names[*][1], names);\nsorted=names;\n//-------------------------------------------------------------\narray strings;\narray sorted = Array.sort_array(strings, lambda(mixed a, mixed b)\n{\nreturn sizeof(a) < sizeof(b);\n}\n);\n// faster:\nsort(sizeof(strings[*]), strings);\nsorted=strings;\n//-------------------------------------------------------------\narray strings;\narray temp = map(strings, sizeof);\nsort(temp, strings);\narray sorted = strings;\n//-------------------------------------------------------------\narray strings;\nsort(map(strings, sizeof), strings);   // pick one\nsort(sizeof(strings[*]), strings);\nsorted=strings;\n//-------------------------------------------------------------\narray fields;\narray temp = map(fields, array_sscanf, "%*s%d%*s");\nsort(temp, fields);\narray sorted_fields=fields;\n//-------------------------------------------------------------\nsort(array_sscanf(fields[*], "%*s%d%*s"), fields);\narray sorted_fields=fields;\n//-------------------------------------------------------------\narray passwd_lines = (Stdio.read_file("/etc/passwd")/"\\n")-({""});\narray(array) passwd = passwd_lines[*]/":";\nint compare(mixed a, mixed b)\n{\nif(a[3]!=b[3])\nreturn (int)a[3]<(int)b[3];\nif(a[2]!=b[2])\nreturn (int)a[2]<(int)b[2];\nreturn a[0]<b[0];\n}\narray sorted_passwd = Array.sort_array(passwd, compare);\n// alternatively the following uses the builtin sort\nsort( passwd[*][0], passwd);\nsort( ((array(int))passwd[*][2]), passwd);\nsort( ((array(int))passwd[*][3]), passwd);\n'})}),"\n",(0,a.jsx)(n.h2,{id:"implementing-a-circular-list-1",children:"Implementing a Circular List"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'ADT.CircularList circular;\ncircular->push_front(circular->pop_back());\ncircular->push_back(circular->pop_front());\n//-------------------------------------------------------------\nmixed grab_and_rotate(ADT.CircularList list)\n{\nmixed element = list->pop_front();\nlist->push_back(element);\nreturn element;\n}\nADT.CircularList processes = ADT.CircularList( ({ 1, 2, 3, 4, 5 }) );\nwhile(1)\n{\nint process = grab_and_rotate(processes);\nwrite("Handling process %d\\n", process);\nsleep(1);\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"randomizing-an-array-1",children:"Randomizing an Array"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'array arr;\nArray.shuffle(arr);  // this uses the fisher-yates shuffle\n//-------------------------------------------------------------\n// being creative with the algorithm, this is not as memory efficient,\n// but it shows the utility of multisets.\narray set_shuffle(array list)\n{\nmultiset elements=(multiset)list;\nlist=({});                     // reset the list\nwhile(sizeof(elements))        // while we still have elements left\n{\nmixed pick=random(elements); // pick a random element\nlist+=({ pick });            // add it to the new list\nelements[pick]--;            // remove the element we picked\n}\nreturn list;\n}\narray list;\nlist=set_shuffle(list);\n//-------------------------------------------------------------\ninherit "mjd_permute";\nint permutations = factorial(sizeof(list));\narray shuffle = list[n2perm(random(permutations)+1, sizeof(list))[*]];\n//-------------------------------------------------------------\nvoid naive_shuffle(array list)\n{\nfor(int i=0; i<sizeof(list); i++)\n{\nint j=random(sizeof(list)-1);\n[ list[i], list[j] ] = ({ list[j], list[i] });\n}\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"program-words-1",children:"Program: words"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'// download the following standalone program\n#!/usr/bin/pike\n// section 4.18 example 4.2\n// words - gather lines, present in columns\nvoid main()\n{\narray words=Stdio.stdin.read()/"\\n";   // get all input\nint maxlen=sort(sizeof(words[*]))[-1]; // sort by size and pick the largest\nmaxlen++;                              // add space\n// get boundaries, this should be portable\nint cols = Stdio.stdout->tcgetattr()->columns/maxlen;\nint rows = (sizeof(words)/cols) + 1;\nstring mask="%{%-"+maxlen+"s%}\\n";     // compute format\nwords=Array.transpose(words/rows);     // split into groups as large as the\n// number of rows and then transpose\nwrite(mask, words[*]);                 // apply mask to each group\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"program-permute-1",children:"Program: permute"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pike",children:'int factorial(int n)\n{\nint s=1;\nwhile(n)\ns*=n--;\nreturn s;\n}\nwrite("%d\\n", factorial(500));\n// Using Array.permute() to generate all permutations\n// -------------------------------------------------------------\n// Example: Generate all permutations of an array using Array.permute()\n// Note: Array.permute() returns all possible orderings of array elements\nimport Array;\n// Simple permutation example\narray(string) fruits = ({"apple", "banana", "cherry"});\narray(array(string)) perms = permute(fruits);\nforeach(perms, array(string) p)\n{\nwrite("%s\\n", p*", ");\n}\n// Output:\n// apple, banana, cherry\n// apple, cherry, banana\n// banana, apple, cherry\n// banana, cherry, apple\n// cherry, apple, banana\n// cherry, banana, apple\n//-------------------------------------------------------------\n// download the following standalone program\n#!/usr/bin/pike\nvoid main()\n{\nstring line;\nwhile(line=Stdio.stdin->gets())\n{\npermute(line/" ");\n}\n}\nvoid permute(array items, array|void perms)\n{\nif(!perms)\nperms=({});\nif(!sizeof(items))\nwrite((perms*" ")+"\\n");\nelse\n{\nforeach(items; int i;)\n{\narray newitems=items[..i-1]+items[i+1..];\narray newperms=items[i..i]+perms;\npermute(newitems, newperms);\n}\n}\n}\n//-------------------------------------------------------------\n// download the following standalone program\n#!/usr/bin/pike\nmapping fact=([ 1:1 ]);\nint factorial(int n)\n{\nif(!fact[n])\nfact[n]=n*factorial(n-1);\nreturn fact[n];\n}\narray n2pat(int N, int len)\n{\nint i=1;\narray pat=({});\nwhile(i <= len)\n{\npat += ({ N%i });\nN/=i;\ni++;\n}\nreturn pat;\n}\narray pat2perm(array pat)\n{\narray source=indices(pat);\narray perm=({});\nwhile(sizeof(pat))\n{\nperm += ({ source[pat[-1]] });\nsource = source[..pat[-1]-1]+source[pat[-1]+1..];\npat=pat[..sizeof(pat)-2];\n}\nreturn perm;\n}\narray n2perm(int N, int len)\n{\nreturn pat2perm(n2pat(N, len));\n}\nvoid main()\n{\narray data;\nwhile(data=Stdio.stdin->gets()/" ")\n{\nint num_permutations = factorial(sizeof(data));\nfor(int i; i<num_permutations; i++)\n{\narray permutation = data[n2perm(i, sizeof(data))[*]];\nwrite(permutation*" "+"\\n");\n}\n}\n}\n'})})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453(e,n,r){r.d(n,{R:()=>t,x:()=>l});var i=r(6540);const a={},s=i.createContext(a);function t(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);