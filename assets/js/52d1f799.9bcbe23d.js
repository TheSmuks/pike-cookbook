"use strict";(self.webpackChunkpike_cookbook=self.webpackChunkpike_cookbook||[]).push([[80],{4633(n,e,i){i.r(e),i.d(e,{assets:()=>o,contentTitle:()=>a,default:()=>f,frontMatter:()=>s,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"files/file-contents","title":"File Contents","description":"Introduction","source":"@site/docs/files/file-contents.md","sourceDirName":"files","slug":"/files/file-contents","permalink":"/pike-cookbook/docs/files/file-contents","draft":false,"unlisted":false,"editUrl":"https://github.com/TheSmuks/pike-cookbook/tree/main/docs/files/file-contents.md","tags":[],"version":"current","frontMatter":{"id":"file-contents","title":"File Contents","sidebar_label":"File Contents"},"sidebar":"tutorialSidebar","previous":{"title":"File Access","permalink":"/pike-cookbook/docs/files/file-access"},"next":{"title":"Directories","permalink":"/pike-cookbook/docs/files/directories"}}');var t=i(4848),l=i(8453);const s={id:"file-contents",title:"File Contents",sidebar_label:"File Contents"},a="File Contents",o={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Reading Lines with Continuation Characters",id:"reading-lines-with-continuation-characters",level:2},{value:"Continuation Line Processing",id:"continuation-line-processing",level:3},{value:"Counting Lines (or Paragraphs or Records) in a File",id:"counting-lines-or-paragraphs-or-records-in-a-file",level:2},{value:"Line Counter with Empty Line Handling",id:"line-counter-with-empty-line-handling",level:3},{value:"Processing Every Word in a File",id:"processing-every-word-in-a-file",level:2},{value:"Word-by-Word Processing",id:"word-by-word-processing",level:3},{value:"Reading a File Backwards by Line or Paragraph",id:"reading-a-file-backwards-by-line-or-paragraph",level:2},{value:"Reverse Line Reading",id:"reverse-line-reading",level:3},{value:"Trailing a Growing File",id:"trailing-a-growing-file",level:2},{value:"Tail Implementation (Like Unix <code>tail -f</code>)",id:"tail-implementation-like-unix-tail--f",level:3},{value:"Picking a Random Line from a File",id:"picking-a-random-line-from-a-file",level:2},{value:"Random Line Selection",id:"random-line-selection",level:3},{value:"Randomizing All Lines",id:"randomizing-all-lines",level:2},{value:"Shuffle File Lines",id:"shuffle-file-lines",level:3},{value:"Reading a Particular Line in a File",id:"reading-a-particular-line-in-a-file",level:2},{value:"Direct Line Access",id:"direct-line-access",level:3},{value:"Processing Variable-Length Text Fields",id:"processing-variable-length-text-fields",level:2},{value:"Fixed-Width Field Parsing",id:"fixed-width-field-parsing",level:3},{value:"Removing the Last Line of a File",id:"removing-the-last-line-of-a-file",level:2},{value:"Efficient Last Line Removal",id:"efficient-last-line-removal",level:3},{value:"Processing Binary Files",id:"processing-binary-files",level:2},{value:"Binary Data Operations",id:"binary-data-operations",level:3},{value:"Using Random-Access I/O",id:"using-random-access-io",level:2},{value:"Direct File Positioning",id:"direct-file-positioning",level:3},{value:"Reading Configuration Files",id:"reading-configuration-files",level:2},{value:"INI-Style Config Parser",id:"ini-style-config-parser",level:3},{value:"See Also",id:"see-also",level:2}];function c(n){const e={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"file-contents",children:"File Contents"})}),"\n",(0,t.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(e.p,{children:"Processing file contents efficiently is crucial for data manipulation, parsing, and transformation tasks. This section covers advanced techniques for reading, processing, and writing file data in Pike 8."}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"What this covers:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Reading files with continuation characters"}),"\n",(0,t.jsx)(e.li,{children:"Counting lines, paragraphs, and records"}),"\n",(0,t.jsx)(e.li,{children:"Processing files word-by-word and backwards"}),"\n",(0,t.jsx)(e.li,{children:"Handling binary files and random access"}),"\n",(0,t.jsx)(e.li,{children:"Working with configuration files"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Why use it:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Process large files efficiently without loading everything into memory"}),"\n",(0,t.jsx)(e.li,{children:"Parse structured data formats (CSV, JSON, XML)"}),"\n",(0,t.jsx)(e.li,{children:"Transform and analyze text data"}),"\n",(0,t.jsx)(e.li,{children:"Build data processing pipelines"}),"\n"]}),"\n",(0,t.jsx)(e.admonition,{type:"tip",children:(0,t.jsxs)(e.p,{children:["For basic file operations, see ",(0,t.jsx)(e.a,{href:"/docs/files/file-access",children:"File Access"}),". This section focuses on advanced content processing."]})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"reading-lines-with-continuation-characters",children:"Reading Lines with Continuation Characters"}),"\n",(0,t.jsx)(e.h3,{id:"continuation-line-processing",children:"Continuation Line Processing"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Process lines with backslash continuations\n//-----------------------------\n\n// Read file and merge continuation lines\narray(string) read_continued_lines(string path) {\n    Stdio.File file = Stdio.File(path, "r");\n    if (!file) {\n        werror("Cannot open file\\n");\n        return ({});\n    }\n\n    array(string) result = ({});\n    string current_line = "";\n\n    foreach(file->line_iterator();; string raw_line) {\n        // Trim whitespace\n        string line = String.trim_whites(raw_line);\n\n        // Check if line ends with backslash continuation\n        if (sizeof(line) && line[-1] == \'\\\\\') {\n            // Remove backslash and accumulate\n            current_line += line[0..sizeof(line)-2];\n        } else {\n            // Add current accumulated line + this line\n            current_line += line;\n            result += ({current_line});\n            current_line = "";\n        }\n    }\n\n    file->close();\n    return result;\n}\n\n// Usage\narray(string) lines = read_continued_lines("config.txt");\nforeach(lines; int i; string line) {\n    write("Line %d: %s\\n", i+1, line);\n}\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"counting-lines-or-paragraphs-or-records-in-a-file",children:"Counting Lines (or Paragraphs or Records) in a File"}),"\n",(0,t.jsx)(e.h3,{id:"line-counter-with-empty-line-handling",children:"Line Counter with Empty Line Handling"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Count lines or paragraphs accurately\n//-----------------------------\n\nint count_lines(string path, void|bool count_paragraphs) {\n    Stdio.File file = Stdio.File(path, "r");\n    if (!file) return 0;\n\n    int count = 0;\n\n    if (count_paragraphs) {\n        // Count non-empty paragraphs (separated by blank lines)\n        int in_paragraph = 0;\n\n        foreach(file->line_iterator();; string line) {\n            string trimmed = String.trim_whites(line);\n\n            if (sizeof(trimmed)) {\n                if (!in_paragraph) {\n                    count++;\n                    in_paragraph = 1;\n                }\n            } else {\n                in_paragraph = 0;\n            }\n        }\n    } else {\n        // Count all lines including empty ones\n        foreach(file->line_iterator();; string line) {\n            count++;\n        }\n    }\n\n    file->close();\n    return count;\n}\n\n// Usage\nint lines = count_lines("data.txt");\nint paragraphs = count_lines("data.txt", true);\nwrite("Lines: %d, Paragraphs: %d\\n", lines, paragraphs);\n'})}),"\n",(0,t.jsx)(e.admonition,{type:"note",children:(0,t.jsxs)(e.p,{children:["Using ",(0,t.jsx)(e.code,{children:"line_iterator()"})," automatically handles different line ending styles (\\n, \\r\\n, \\r)."]})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"processing-every-word-in-a-file",children:"Processing Every Word in a File"}),"\n",(0,t.jsx)(e.h3,{id:"word-by-word-processing",children:"Word-by-Word Processing"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Process each word in a file\n//-----------------------------\n\nvoid process_words(string path, function(string:void) callback) {\n    Stdio.File file = Stdio.File(path, "r");\n    if (!file) return;\n\n    foreach(file->line_iterator();; string line) {\n        // Split line into words (whitespace-separated)\n        array(string) words = String.normalize_space(line) / " ";\n\n        foreach(words; string word) {\n            // Skip empty strings\n            if (sizeof(word)) {\n                callback(word);\n            }\n        }\n    }\n\n    file->close();\n}\n\n// Usage: word frequency counter\nmapping(string:int) word_freq = ([]);\n\nprocess_words("text.txt", lambda(string word) {\n    word = lower_case(word);\n    word_freq[word]++;\n});\n\n// Display top 10 words\narray(string) sorted_words = indices(word_freq);\nsort(word_freq[*], sorted_words);\nsorted_words = reverse(sorted_words);\n\nwrite("Top 10 words:\\n");\nforeach(sorted_words[0..9]; int i; string word) {\n    write("%2d. %s: %d\\n", i+1, word, word_freq[word]);\n}\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"reading-a-file-backwards-by-line-or-paragraph",children:"Reading a File Backwards by Line or Paragraph"}),"\n",(0,t.jsx)(e.h3,{id:"reverse-line-reading",children:"Reverse Line Reading"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Read file from end to beginning\n//-----------------------------\n\narray(string) read_file_backwards(string path) {\n    // Read entire file into array\n    array(string) lines = Stdio.read_file(path) / "\\n";\n\n    // Remove trailing empty line if present\n    if (sizeof(lines) && !sizeof(lines[-1])) {\n        lines = lines[0..sizeof(lines)-2];\n    }\n\n    // Reverse the array\n    return reverse(lines);\n}\n\n// Memory-efficient version for large files\nvoid process_backwards_efficient(string path, function(string:void) callback) {\n    Stdio.File file = Stdio.File(path, "r");\n    if (!file) return;\n\n    // Store lines in array (for memory efficiency, use temp file)\n    array(string) lines = ({});\n\n    foreach(file->line_iterator();; string line) {\n        lines += ({line});\n    }\n\n    file->close();\n\n    // Process in reverse order\n    for (int i = sizeof(lines) - 1; i >= 0; i--) {\n        callback(lines[i]);\n    }\n}\n\n// Usage\nprocess_backwards_efficient("log.txt", lambda(string line) {\n    write("%s\\n", line);\n});\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"trailing-a-growing-file",children:"Trailing a Growing File"}),"\n",(0,t.jsxs)(e.h3,{id:"tail-implementation-like-unix-tail--f",children:["Tail Implementation (Like Unix ",(0,t.jsx)(e.code,{children:"tail -f"}),")"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Monitor file for new lines (tail -f)\n//-----------------------------\n\nvoid tail_file(string path, void|function(string:void) callback) {\n    if (!callback) {\n        callback = lambda(string line) { write("%s\\n", line); };\n    }\n\n    Stdio.File file = Stdio.File(path, "r");\n    if (!file) {\n        werror("Cannot open file\\n");\n        return;\n    }\n\n    // Seek to end of file\n    file->seek(0, SEEK_END);\n\n    write("Monitoring %s (Ctrl+C to stop)...\\n", path);\n\n    while (1) {\n        string line = file->gets();\n        if (line) {\n            callback(line);\n        } else {\n            // No new data, wait a bit\n            sleep(0.1);\n        }\n    }\n\n    file->close();\n}\n\n// Enhanced version with line count limit\nvoid tail_file_n(string path, int n_lines) {\n    Stdio.File file = Stdio.File(path, "r");\n    if (!file) return;\n\n    array(string) last_n = ({});\n\n    foreach(file->line_iterator();; string line) {\n        last_n += ({line});\n        if (sizeof(last_n) > n_lines) {\n            last_n = last_n[1..];  // Keep only last N lines\n        }\n    }\n\n    file->close();\n\n    // Output last N lines\n    foreach(last_n; string line) {\n        write("%s\\n", line);\n    }\n}\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"picking-a-random-line-from-a-file",children:"Picking a Random Line from a File"}),"\n",(0,t.jsx)(e.h3,{id:"random-line-selection",children:"Random Line Selection"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Select random line from file\n//-----------------------------\n\nstring random_line(string path) {\n    Stdio.File file = Stdio.File(path, "r");\n    if (!file) return 0;\n\n    string selected = 0;\n    int count = 0;\n\n    // Reservoir sampling - pick one line uniformly at random\n    foreach(file->line_iterator();; string line) {\n        count++;\n        // Replace selected line with probability 1/count\n        if (random(count) == 0) {\n            selected = line;\n        }\n    }\n\n    file->close();\n    return selected;\n}\n\n// Select N random lines without duplicates\narray(string) random_lines(string path, int n) {\n    Stdio.File file = Stdio.File(path, "r");\n    if (!file) return ({});\n\n    array(string) reservoir = ({});\n    int count = 0;\n\n    foreach(file->line_iterator();; string line) {\n        count++;\n\n        if (sizeof(reservoir) < n) {\n            reservoir += ({line});\n        } else {\n            // Replace with probability n/count\n            int replace_at = random(count);\n            if (replace_at < n) {\n                reservoir[replace_at] = line;\n            }\n        }\n    }\n\n    file->close();\n    return reservoir;\n}\n\n// Usage\nstring quote = random_line("quotes.txt");\nwrite("Random quote: %s\\n", quote);\n\narray(string) five_quotes = random_lines("quotes.txt", 5);\nforeach(five_quotes; int i; string quote) {\n    write("%d. %s\\n", i+1, quote);\n}\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"randomizing-all-lines",children:"Randomizing All Lines"}),"\n",(0,t.jsx)(e.h3,{id:"shuffle-file-lines",children:"Shuffle File Lines"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Randomize line order in file\n//-----------------------------\n\nvoid shuffle_file(string input_path, string output_path) {\n    // Read all lines\n    string content = Stdio.read_file(input_path);\n    array(string) lines = content / "\\n";\n\n    // Remove trailing empty line if present\n    if (sizeof(lines) && !sizeof(lines[-1])) {\n        lines = lines[0..sizeof(lines)-2];\n    }\n\n    // Shuffle using Fisher-Yates algorithm\n    for (int i = sizeof(lines) - 1; i > 0; i--) {\n        int j = random(i + 1);\n        // Swap lines[i] and lines[j]\n        string temp = lines[i];\n        lines[i] = lines[j];\n        lines[j] = temp;\n    }\n\n    // Write shuffled lines\n    Stdio.write_file(output_path, lines * "\\n" + "\\n");\n    write("Shuffled %d lines from %s to %s\\n",\n          sizeof(lines), input_path, output_path);\n}\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"reading-a-particular-line-in-a-file",children:"Reading a Particular Line in a File"}),"\n",(0,t.jsx)(e.h3,{id:"direct-line-access",children:"Direct Line Access"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Read specific line by number\n//-----------------------------\n\nstring|zero read_line_number(string path, int line_num) {\n    Stdio.File file = Stdio.File(path, "r");\n    if (!file) return 0;\n\n    int current = 0;\n    string result = 0;\n\n    foreach(file->line_iterator();; string line) {\n        current++;\n        if (current == line_num) {\n            result = line;\n            break;\n        }\n    }\n\n    file->close();\n    return result;\n}\n\n// Read multiple lines by range\narray(string) read_line_range(string path, int start, int end) {\n    Stdio.File file = Stdio.File(path, "r");\n    if (!file) return ({});\n\n    array(string) result = ({});\n    int current = 0;\n\n    foreach(file->line_iterator();; string line) {\n        current++;\n        if (current >= start && current <= end) {\n            result += ({line});\n        }\n        if (current > end) break;\n    }\n\n    file->close();\n    return result;\n}\n\n// Usage\nstring line_10 = read_line_number("data.txt", 10);\nif (line_10) {\n    write("Line 10: %s\\n", line_10);\n}\n\narray(string) lines_5_to_10 = read_line_range("data.txt", 5, 10);\nwrite("Lines 5-10:\\n%s\\n", lines_5_to_10 * "\\n");\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"processing-variable-length-text-fields",children:"Processing Variable-Length Text Fields"}),"\n",(0,t.jsx)(e.h3,{id:"fixed-width-field-parsing",children:"Fixed-Width Field Parsing"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Parse fixed-width text fields\n//-----------------------------\n\nmapping parse_fixed_width(string line, array(int) widths) {\n    mapping result = ([]);\n    int pos = 0;\n\n    foreach(widths; int i; int width) {\n        string field = line[pos..pos+width-1];\n        result[i] = String.trim_whites(field);\n        pos += width;\n    }\n\n    return result;\n}\n\n// Example: Parse a data file with fixed-width columns\nvoid process_fixed_width_file(string path) {\n    // Define column widths\n    array(int) widths = ({10, 20, 15, 10});  // Name, Email, Phone, City\n\n    Stdio.File file = Stdio.File(path, "r");\n    if (!file) return;\n\n    // Skip header\n    file->gets();\n\n    foreach(file->line_iterator();; string line) {\n        mapping fields = parse_fixed_width(line, widths);\n        write("Name: %s, Email: %s, Phone: %s, City: %s\\n",\n              fields[0], fields[1], fields[2], fields[3]);\n    }\n\n    file->close();\n}\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"removing-the-last-line-of-a-file",children:"Removing the Last Line of a File"}),"\n",(0,t.jsx)(e.h3,{id:"efficient-last-line-removal",children:"Efficient Last Line Removal"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Remove last line from file\n//-----------------------------\n\nvoid remove_last_line(string path) {\n    string content = Stdio.read_file(path);\n    array(string) lines = content / "\\n";\n\n    // Remove last element (empty string from trailing newline or actual last line)\n    if (sizeof(lines)) {\n        lines = lines[0..sizeof(lines)-2];\n    }\n\n    // Write back\n    Stdio.write_file(path, lines * "\\n");\n}\n\n// Memory-efficient version for large files\nvoid remove_last_line_efficient(string path) {\n    Stdio.File file = Stdio.File(path, "r");\n    if (!file) return;\n\n    array(string) all_but_last = ({});\n    string prev_line = "";\n\n    // Read all lines, keeping track of previous\n    string line;\n    while ((line = file->gets())) {\n        if (sizeof(prev_line)) {\n            all_but_last += ({prev_line});\n        }\n        prev_line = line;\n    }\n\n    file->close();\n\n    // Write all but last line\n    Stdio.write_file(path, all_but_last * "\\n" + "\\n");\n}\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"processing-binary-files",children:"Processing Binary Files"}),"\n",(0,t.jsx)(e.h3,{id:"binary-data-operations",children:"Binary Data Operations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Read and process binary files\n//-----------------------------\n\n// Read binary data with specific structure\nvoid process_binary_file(string path) {\n    Stdio.File file = Stdio.File(path, "r");\n    if (!file) {\n        werror("Cannot open binary file\\n");\n        return;\n    }\n\n    // Read header\n    string magic = file->read(4);\n    write("Magic: %O\\n", magic);\n\n    // Read 32-bit integer (big-endian)\n    string int_bytes = file->read(4);\n    int value = 0;\n    for (int i = 0; i < 4; i++) {\n        value = (value << 8) | int_bytes[i];\n    }\n    write("Value: %d\\n", value);\n\n    // Read null-terminated string\n    array(string) str_parts = ({});\n    string ch;\n    while ((ch = file->read(1)) != "\\0") {\n        str_parts += ({ch});\n    }\n    string str = str_parts * "";\n    write("String: %s\\n", str);\n\n    file->close();\n}\n\n// Copy file with progress\nvoid copy_file_with_progress(string src, string dst) {\n    Stdio.File input = Stdio.File(src, "r");\n    Stdio.File output = Stdio.File(dst, "wc");\n\n    if (!input || !output) {\n        werror("Cannot open files\\n");\n        return;\n    }\n\n    int total = 0;\n    int chunk_size = 65536;  // 64KB\n    string chunk;\n\n    while ((chunk = input->read(chunk_size))) {\n        output->write(chunk);\n        total += sizeof(chunk);\n\n        if (total % (1024 * 1024) == 0) {\n            write("Copied %d MB\\n", total / (1024 * 1024));\n        }\n    }\n\n    write("Total copied: %d bytes\\n", total);\n\n    input->close();\n    output->close();\n}\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"using-random-access-io",children:"Using Random-Access I/O"}),"\n",(0,t.jsx)(e.h3,{id:"direct-file-positioning",children:"Direct File Positioning"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Random access to file positions\n//-----------------------------\n\nvoid demo_random_access(string path) {\n    Stdio.File file = Stdio.File(path, "r");\n    if (!file) return;\n\n    // Get file size\n    file->seek(0, SEEK_END);\n    int file_size = file->tell();\n    write("File size: %d bytes\\n", file_size);\n\n    // Read first 100 bytes\n    file->seek(0);\n    string header = file->read(100);\n    write("Header: %O...\\n", header[0..50]);\n\n    // Read last 100 bytes\n    file->seek(-100, SEEK_END);\n    string trailer = file->read(100);\n    write("Trailer: %O\\n", trailer);\n\n    // Jump to middle and read\n    file->seek(file_size / 2);\n    string middle = file->read(100);\n    write("Middle: %O\\n", middle);\n\n    file->close();\n}\n\n// Replace bytes at specific position\nvoid patch_binary(string path, int pos, string new_data) {\n    Stdio.File file = Stdio.File(path, "rw");\n    if (!file) {\n        werror("Cannot open file\\n");\n        return;\n    }\n\n    file->seek(pos);\n    file->write(new_data);\n\n    write("Patched %d bytes at position %d\\n", sizeof(new_data), pos);\n\n    file->close();\n}\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"reading-configuration-files",children:"Reading Configuration Files"}),"\n",(0,t.jsx)(e.h3,{id:"ini-style-config-parser",children:"INI-Style Config Parser"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Parse INI configuration files\n//-----------------------------\n\nmapping(string:mapping(string:string)) parse_ini(string path) {\n    string content = Stdio.read_file(path);\n    array(string) lines = content / "\\n";\n\n    mapping(string:mapping(string:string)) config = ([]);\n    string current_section = "default";\n\n    foreach(lines; string line) {\n        string trimmed = String.trim_whites(line);\n\n        // Skip empty lines and comments\n        if (!sizeof(trimmed) || trimmed[0] == \'#\' || trimmed[0] == \';\')\n            continue;\n\n        // Section header [section]\n        if (trimmed[0] == \'[\' && trimmed[-1] == \']\') {\n            current_section = trimmed[1..sizeof(trimmed)-2];\n            config[current_section] = ([]);\n            continue;\n        }\n\n        // Key = Value\n        int eq_pos = search(trimmed, \'=\');\n        if (eq_pos > 0) {\n            string key = String.trim_whites(trimmed[0..eq_pos-1]);\n            string value = String.trim_whites(trimmed[eq_pos+1..]);\n\n            if (!config[current_section])\n                config[current_section] = ([]);\n\n            config[current_section][key] = value;\n        }\n    }\n\n    return config;\n}\n\n// Usage\nmapping config = parse_ini("config.ini");\n\nif (config["database"]) {\n    write("Database host: %s\\n", config["database"]["host"]);\n    write("Database name: %s\\n", config["database"]["name"]);\n}\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"see-also",children:"See Also"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:"/docs/files/file-access",children:"File Access"})," - Basic file operations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:"/docs/files/directories",children:"Directories"})," - Directory management"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:"/docs/basics/strings",children:"Strings"})," - Text processing functions"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:"/docs/basics/pattern-matching",children:"Pattern Matching"})," - Advanced text parsing"]}),"\n"]})]})}function f(n={}){const{wrapper:e}={...(0,l.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(c,{...n})}):c(n)}},8453(n,e,i){i.d(e,{R:()=>s,x:()=>a});var r=i(6540);const t={},l=r.createContext(t);function s(n){const e=r.useContext(l);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:s(n.components),r.createElement(l.Provider,{value:e},n.children)}}}]);