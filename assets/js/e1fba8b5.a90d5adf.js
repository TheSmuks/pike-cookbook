"use strict";(self.webpackChunkpike_cookbook=self.webpackChunkpike_cookbook||[]).push([[577],{2746(n,e,t){t.r(e),t.d(e,{assets:()=>o,contentTitle:()=>c,default:()=>p,frontMatter:()=>r,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"advanced/classes","title":"Classes and Objects","description":"Introduction","source":"@site/docs/advanced/classes.md","sourceDirName":"advanced","slug":"/advanced/classes","permalink":"/pike-cookbook/docs/advanced/classes","draft":false,"unlisted":false,"editUrl":"https://github.com/TheSmuks/pike-cookbook/tree/main/docs/advanced/classes.md","tags":[],"version":"current","frontMatter":{"id":"classes","title":"Classes and Objects","sidebar_label":"Classes and Objects"},"sidebar":"tutorialSidebar","previous":{"title":"Internet Services","permalink":"/pike-cookbook/docs/network/internet-services"},"next":{"title":"References and Records","permalink":"/pike-cookbook/docs/advanced/references"}}');var i=t(4848),s=t(8453);const r={id:"classes",title:"Classes and Objects",sidebar_label:"Classes and Objects"},c="Classes and Objects",o={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Constructing an Object",id:"constructing-an-object",level:2},{value:"Basic Class and Constructor",id:"basic-class-and-constructor",level:3},{value:"Constructor with Default Values",id:"constructor-with-default-values",level:3},{value:"Destroying an Object",id:"destroying-an-object",level:2},{value:"Resource Cleanup",id:"resource-cleanup",level:3},{value:"Managing Instance Data",id:"managing-instance-data",level:2},{value:"Instance Variables and Encapsulation",id:"instance-variables-and-encapsulation",level:3},{value:"Managing Class Data",id:"managing-class-data",level:2},{value:"Static Class Members",id:"static-class-members",level:3},{value:"Creating Hierarchical Modules",id:"creating-hierarchical-modules",level:2},{value:"Module Organization",id:"module-organization",level:3},{value:"Access Control",id:"access-control",level:2},{value:"Public, Protected, Private",id:"public-protected-private",level:3},{value:"Inheritance",id:"inheritance",level:2},{value:"Single Inheritance",id:"single-inheritance",level:3},{value:"Multiple Inheritance",id:"multiple-inheritance",level:3},{value:"Accessing Overridden Methods",id:"accessing-overridden-methods",level:2},{value:"Calling Parent Methods",id:"calling-parent-methods",level:3},{value:"Operator Overloading",id:"operator-overloading",level:2},{value:"Custom Operators",id:"custom-operators",level:3},{value:"Closure-based Objects",id:"closure-based-objects",level:2},{value:"Closures as Objects",id:"closures-as-objects",level:3},{value:"Cloning Objects",id:"cloning-objects",level:2},{value:"Deep Copy",id:"deep-copy",level:3},{value:"See Also",id:"see-also",level:2}];function d(n){const e={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"classes-and-objects",children:"Classes and Objects"})}),"\n",(0,i.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(e.p,{children:"Pike 8 is a modern object-oriented language with first-class support for classes, objects, inheritance, polymorphism, and encapsulation. This chapter covers Pike's object-oriented programming features including class declaration, methods, inheritance, access control, operator overloading, and lambda functions."}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"What this covers:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Class declaration and instantiation"}),"\n",(0,i.jsx)(e.li,{children:"Methods and properties with type annotations"}),"\n",(0,i.jsx)(e.li,{children:"Single and multiple inheritance"}),"\n",(0,i.jsx)(e.li,{children:"Access control and encapsulation"}),"\n",(0,i.jsx)(e.li,{children:"Operator overloading"}),"\n",(0,i.jsx)(e.li,{children:"Static members and class methods"}),"\n",(0,i.jsx)(e.li,{children:"Lambda functions and closures"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Why use it:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Organize code into reusable components"}),"\n",(0,i.jsx)(e.li,{children:"Model real-world entities and relationships"}),"\n",(0,i.jsx)(e.li,{children:"Create maintainable, modular code"}),"\n",(0,i.jsx)(e.li,{children:"Implement design patterns"}),"\n",(0,i.jsx)(e.li,{children:"Leverage polymorphism for flexible architectures"}),"\n"]}),"\n",(0,i.jsx)(e.admonition,{type:"tip",children:(0,i.jsxs)(e.p,{children:["Pike 8's ",(0,i.jsx)(e.code,{children:"#pragma strict_types"})," combined with OOP provides robust type safety while maintaining Pike's flexibility."]})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"constructing-an-object",children:"Constructing an Object"}),"\n",(0,i.jsx)(e.h3,{id:"basic-class-and-constructor",children:"Basic Class and Constructor"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Simple class with constructor\n//-----------------------------\n\n#pragma strict_types\n\nclass Person {\n    protected string name;\n    protected int age;\n\n    // Constructor with required parameters\n    void create(string name_, int age_) {\n        name = name_;\n        age = age_;\n    }\n\n    // Public getter methods\n    public string get_name() {\n        return name;\n    }\n\n    public int get_age() {\n        return age;\n    }\n\n    // String representation\n    public string _sprintf(int type) {\n        return sprintf("Person(%s, %d)", name, age);\n    }\n}\n\n// Usage\nPerson p = Person("Alice", 30);\nwrite("%s\\n", p);  // Output: Person(Alice, 30)\nwrite("Name: %s\\n", p->get_name());\n'})}),"\n",(0,i.jsx)(e.h3,{id:"constructor-with-default-values",children:"Constructor with Default Values"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Constructor with optional parameters\n//-----------------------------\n\n#pragma strict_types\n\nclass Config {\n    protected mapping(string:mixed) options;\n\n    void create(void|mapping(string:mixed) opts) {\n        options = opts || ([]);\n    }\n\n    mixed get(string key, void|mixed default_val) {\n        return options[key] || default_val;\n    }\n\n    void set(string key, mixed value) {\n        options[key] = value;\n    }\n}\n\nConfig cfg1 = Config();\nConfig cfg2 = Config((["host": "localhost", "port": 8080]));\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"destroying-an-object",children:"Destroying an Object"}),"\n",(0,i.jsx)(e.h3,{id:"resource-cleanup",children:"Resource Cleanup"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Automatic cleanup with destroy()\n//-----------------------------\n\n#pragma strict_types\n\nclass DatabaseConnection {\n    protected string connection_string;\n    protected bool is_connected = false;\n\n    void create(string conn_str) {\n        connection_string = conn_str;\n        is_connected = true;\n        write("Connected to: %s\\n", conn_str);\n    }\n\n    void destroy() {\n        if (is_connected) {\n            write("Closing connection to: %s\\n", connection_string);\n            is_connected = false;\n        }\n    }\n}\n\nvoid test_connection() {\n    DatabaseConnection db = DatabaseConnection("postgresql://localhost/test");\n    write("Working with database...\\n");\n}  // destroy() called here\n'})}),"\n",(0,i.jsx)(e.admonition,{type:"note",children:(0,i.jsxs)(e.p,{children:["Pike uses garbage collection, so ",(0,i.jsx)(e.code,{children:"destroy()"})," is called when an object is no longer referenced."]})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"managing-instance-data",children:"Managing Instance Data"}),"\n",(0,i.jsx)(e.h3,{id:"instance-variables-and-encapsulation",children:"Instance Variables and Encapsulation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Class with private data and public accessors\n//-----------------------------\n\n#pragma strict_types\n\nclass BankAccount {\n    // Private instance data\n    protected string account_number;\n    protected float balance;\n\n    // Public constant\n    public constant OVERDRAFT_FEE = 35.0;\n\n    void create(string owner, string acct_num) {\n        account_number = acct_num;\n        balance = 0.0;\n    }\n\n    public float get_balance() {\n        return balance;\n    }\n\n    public int deposit(float amount) {\n        if (amount <= 0) return 0;\n        balance += amount;\n        return 1;\n    }\n\n    public int withdraw(float amount) {\n        if (amount <= 0 || amount > balance) return 0;\n        balance -= amount;\n        return 1;\n    }\n}\n\nBankAccount acct = BankAccount("Alice", "123-456");\nacct->deposit(100.0);\nwrite("Balance: $%.2f\\n", acct->get_balance());\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"managing-class-data",children:"Managing Class Data"}),"\n",(0,i.jsx)(e.h3,{id:"static-class-members",children:"Static Class Members"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Shared class data\n//-----------------------------\n\n#pragma strict_types\n\nclass Counter {\n    // Static class data - shared across all instances\n    static int instance_count = 0;\n    static mapping(string:int) registry = ([]);\n\n    protected string name;\n\n    void create(string name_) {\n        name = name_;\n        instance_count++;\n        registry[name_] = instance_count;\n    }\n\n    void destroy() {\n        instance_count--;\n        m_delete(registry, name);\n    }\n\n    // Static class method\n    static int get_instance_count() {\n        return instance_count;\n    }\n}\n\nCounter c1 = Counter("first");\nCounter c2 = Counter("second");\nwrite("Instances: %d\\n", Counter->get_instance_count());  // 2\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"creating-hierarchical-modules",children:"Creating Hierarchical Modules"}),"\n",(0,i.jsx)(e.h3,{id:"module-organization",children:"Module Organization"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Nested module structure\n//-----------------------------\n\n// Directory structure:\n// MyApp/\n//   MyApp.pmod\n//   Utils.pmod/\n//     String.pmod\n//     Math.pmod\n\n// File: MyApp.pmod\n#pragma strict_types\n\nconstant VERSION = "2.0.0";\n\n// This makes Utils available as MyApp.Utils\nimport .Utils;\n\n// File: MyApp/Utils/String.pmod\n#pragma strict_types\n\n//! String manipulation utilities.\nstring title_case(string s) {\n    return String.capitalize(lower_case(s));\n}\n\n// File: MyApp/Utils/Math.pmod\n#pragma strict_types\n\n//! Math operations.\nint add(int a, int b) {\n    return a + b;\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"access-control",children:"Access Control"}),"\n",(0,i.jsx)(e.h3,{id:"public-protected-private",children:"Public, Protected, Private"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Controlling member visibility\n//-----------------------------\n\n#pragma strict_types\n\nclass SecureData {\n    // Public - accessible from anywhere\n    public constant API_VERSION = "1.0";\n\n    // Protected - accessible in this class and subclasses\n    protected string _internal_state = "";\n\n    // Private - only in this class\n    private string _private_key = "secret";\n\n    public string get_state() {\n        return _internal_state;\n    }\n\n    protected void set_state(string new_state) {\n        _internal_state = new_state;\n    }\n\n    private void _encrypt(string data) {\n        // Implementation\n    }\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"inheritance",children:"Inheritance"}),"\n",(0,i.jsx)(e.h3,{id:"single-inheritance",children:"Single Inheritance"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Base and derived classes\n//-----------------------------\n\n#pragma strict_types\n\nclass Shape {\n    protected string name;\n\n    void create(string name_) {\n        name = name_;\n    }\n\n    public float area() {\n        return 0.0;\n    }\n\n    public void describe() {\n        write("%s: area=%.2f\\n", name, area());\n    }\n}\n\nclass Circle {\n    inherit Shape;\n\n    protected float radius;\n\n    void create(float r) {\n        ::create("Circle");\n        radius = r;\n    }\n\n    public float area() {\n        return Math.PI * radius * radius;\n    }\n}\n\nclass Rectangle {\n    inherit Shape;\n\n    protected float width;\n    protected float height;\n\n    void create(float w, float h) {\n        ::create("Rectangle");\n        width = w;\n        height = h;\n    }\n\n    public float area() {\n        return width * height;\n    }\n}\n\n// Polymorphism in action\narray(Shape) shapes = ({\n    Circle(2.5),\n    Rectangle(3.0, 4.0)\n});\n\nforeach(shapes; Shape shape) {\n    shape->describe();\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"multiple-inheritance",children:"Multiple Inheritance"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Multiple inheritance\n//-----------------------------\n\n#pragma strict_types\n\nclass Drawable {\n    public void draw() {\n        write("Drawing...\\n");\n    }\n}\n\nclass Serializable {\n    public string serialize() {\n        return "serialized data";\n    }\n}\n\nclass Sprite {\n    inherit Drawable;\n    inherit Serializable;\n\n    protected int x = 0;\n    protected int y = 0;\n\n    void move(int dx, int dy) {\n        x += dx;\n        y += dy;\n    }\n}\n\nSprite sprite = Sprite();\nsprite->draw();        // From Drawable\nwrite("%s\\n", sprite->serialize());  // From Serializable\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"accessing-overridden-methods",children:"Accessing Overridden Methods"}),"\n",(0,i.jsx)(e.h3,{id:"calling-parent-methods",children:"Calling Parent Methods"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Use :: to access parent methods\n//-----------------------------\n\n#pragma strict_types\n\nclass Vehicle {\n    protected string make;\n    protected string model;\n\n    void create(string make_, string model_) {\n        ::create(make_, model_);\n        write("Vehicle created: %s %s\\n", make_, model_);\n    }\n\n    public string get_info() {\n        return sprintf("%s %s", make, model);\n    }\n}\n\nclass Car {\n    inherit Vehicle;\n\n    protected int num_doors;\n\n    void create(string make_, string model_, int doors) {\n        ::create(make_, model_);  // Call parent constructor\n        num_doors = doors;\n    }\n\n    public string get_info() {\n        // Extend parent method\n        return ::get_info() + sprintf(" (%d doors)", num_doors);\n    }\n}\n\nCar car = Car("Toyota", "Camry", 4);\nwrite("%s\\n", car->get_info());  // "Toyota Camry (4 doors)"\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"operator-overloading",children:"Operator Overloading"}),"\n",(0,i.jsx)(e.h3,{id:"custom-operators",children:"Custom Operators"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Overload operators for custom behavior\n//-----------------------------\n\n#pragma strict_types\n\nclass Complex {\n    public float real;\n    public float imag;\n\n    void create(float r, float i) {\n        real = r;\n        imag = i;\n    }\n\n    // Overload +\n    public Complex `+(mixed other) {\n        if (!objectp(other) || object_program(other) != Complex)\n            error("Can only add Complex to Complex\\n");\n        return Complex(real + other->real, imag + other->imag);\n    }\n\n    // Overload ==\n    public int `==(mixed other) {\n        return objectp(other) &&\n               object_program(other) == Complex &&\n               real == other->real &&\n               imag == other->imag;\n    }\n\n    public string _sprintf(int type) {\n        if (type == \'O\' || type == \'s\') {\n            return sprintf("Complex(%.2f%+.2fi)", real, imag);\n        }\n        return sprintf("%O", this);\n    }\n}\n\nComplex c1 = Complex(3.0, 4.0);\nComplex c2 = Complex(1.0, 2.0);\n\nComplex sum = c1 + c2;\nwrite("Sum: %s\\n", sum);  // Complex(4.00+6.00i)\n\nif (sum == Complex(4.0, 6.0)) {\n    write("Equality works\\n");\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"closure-based-objects",children:"Closure-based Objects"}),"\n",(0,i.jsx)(e.h3,{id:"closures-as-objects",children:"Closures as Objects"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Use closures instead of classes\n//-----------------------------\n\n#pragma strict_types\n\n// Counter using closure\nfunction(int:void) create_counter(int start) {\n    int count = start;\n    return lambda(int delta) {\n        count += delta;\n        write("Count: %d\\n", count);\n    };\n}\n\nfunction(int:void) counter1 = create_counter(0);\nfunction(int:void) counter2 = create_counter(100);\n\ncounter1(1);   // Output: Count: 1\ncounter2(10);  // Output: Count: 110\n\n// Getter/setter using closure\nmapping(string:function) create_property(mixed initial_value) {\n    mixed value = initial_value;\n    return ([\n        "get": lambda() { return value; },\n        "set": lambda(mixed new_val) { value = new_val; }\n    ]);\n}\n\nmapping(string:function) prop = create_property("test");\nwrite("%s\\n", prop["get"]());  // "test"\nprop["set"]("updated");\nwrite("%s\\n", prop["get"]());  // "updated"\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"cloning-objects",children:"Cloning Objects"}),"\n",(0,i.jsx)(e.h3,{id:"deep-copy",children:"Deep Copy"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Clone objects with copy_value()\n//-----------------------------\n\n#pragma strict_types\n\nclass Widget {\n    public string name;\n    public int id;\n    public array(mixed) data;\n\n    void create(string name_, int id_) {\n        name = name_;\n        id = id_;\n        data = ({});\n    }\n\n    public Widget clone() {\n        Widget w = Widget(name, id);\n        w->data = copy_value(data);  // Deep copy\n        return w;\n    }\n}\n\nWidget original = Widget("widget", 1);\noriginal->data = ({1, 2, 3});\n\nWidget cloned = original->clone();\ncloned->data[0] = 99;\n\nwrite("Original: %O\\n", original->data);  // ({99, 2, 3})\nwrite("Clone: %O\\n", cloned->data);    // ({99, 2, 3})\n\n// For complete independence\ncloned->data = copy_value(original->data);\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"see-also",children:"See Also"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.a,{href:"/docs/advanced/modules",children:"Modules"})," - Code organization"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.a,{href:"/docs/advanced/references",children:"References"})," - Advanced data structures"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.a,{href:"/docs/advanced/processes",children:"Process Management"})," - IPC and communication"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.a,{href:"/docs/basics/subroutines",children:"Lambda Expressions"})," - Closures and functional programming"]}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},8453(n,e,t){t.d(e,{R:()=>r,x:()=>c});var a=t(6540);const i={},s=a.createContext(i);function r(n){const e=a.useContext(s);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:r(n.components),a.createElement(s.Provider,{value:e},n.children)}}}]);