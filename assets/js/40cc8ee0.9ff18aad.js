"use strict";(self.webpackChunkpike_cookbook=self.webpackChunkpike_cookbook||[]).push([[799],{1108(n,e,t){t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"basics/subroutines","title":"Subroutines","description":"Introduction","source":"@site/docs/basics/subroutines.md","sourceDirName":"basics","slug":"/basics/subroutines","permalink":"/pike-cookbook/docs/basics/subroutines","draft":false,"unlisted":false,"editUrl":"https://github.com/TheSmuks/pike-cookbook/tree/main/docs/basics/subroutines.md","tags":[],"version":"current","frontMatter":{"id":"subroutines","title":"Subroutines","sidebar_label":"Subroutines"},"sidebar":"tutorialSidebar","previous":{"title":"Pattern Matching","permalink":"/pike-cookbook/docs/basics/pattern-matching"},"next":{"title":"File Access","permalink":"/pike-cookbook/docs/files/file-access"}}');var a=t(4848),r=t(8453);const s={id:"subroutines",title:"Subroutines",sidebar_label:"Subroutines"},o=void 0,c={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Accessing Subroutine Arguments",id:"accessing-subroutine-arguments",level:2},{value:"Making Variables Private to a Function",id:"making-variables-private-to-a-function",level:2},{value:"Creating Persistent Private Variables",id:"creating-persistent-private-variables",level:2}];function u(n){const e={code:"code",h2:"h2",pre:"pre",...(0,r.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-pike",children:"#pragma strict_types\n// Here, in this simple example, 'greeted', is used as a 'global'\n// variable. In a more complex program, however, this would not be\n// the case [subsequent sections exlain why]\n\nint greeted;\n\n// ----\n\nvoid hello()\n{\n  write(\"hi there!, this procedure has been called %d times\\n\", ++greeted);\n}\n\nint how_many_greetings()\n{\n  return greeted;\n}\n\n// ------------\n\nint main()\n{\n  hello();\n  int greetings = how_many_greetings();\n  write(\"bye there!, there have been %d greetings so far\\n\", greetings);\n}\n\n// ----------------------------\n\n// Alternate means of defining functions [could, optionally, have also\n// included type information in 'function' declaration]; could also\n// have been done within scope of 'main'\n\nint greeted;\n\n// ----\n\nfunction hello = lambda()\n  {\n    write(\"hi there!, this procedure has been called %d times\\n\", ++greeted);\n  };\n\nfunction how_many_greetings = lambda() { return greeted; };\n\n// ------------\n\nint main()\n{\n  hello();\n  int greetings = how_many_greetings();\n  write(\"bye there!, there have been %d greetings so far\\n\", greetings);\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"accessing-subroutine-arguments",children:"Accessing Subroutine Arguments"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-pike",children:"#pragma strict_types\n// Subroutine parameters are named, that is, access to these items from\n// within a function is reliant on their being named in the parameter\n// list [together with mandatory type information], something which is\n// in line with many other commonly-used languages\n\nfloat hypotenuse(float side1, float side2)\n{\n  // Arguments passed to this function are accessable as, 'side1',\n  // and 'side2', respectively, and each is expected to be a 'float'\n  // type\n\n  return side1 * side1 + side2 * side2;\n}\n\n// ----\n// 'side1' -> 3.0\n// 'side2' -> 4.0\n\nfloat diag = hypotenuse(3.0, 4.0);\n\n// ------------\n\n// However, Pike also allows parameters [and return types where applicable]:\n// * To have one of a set of types [see (1)]\n// * To have a generic type [see (2)]\n// * To be optional, in which case any arguments are packaged as an\n//   array, and array notation needed to access each item [see (3)]\n\n// (1). Here the function will accept either 'int' or 'float'\n// arguments, and perform runtime type checking to identify what is\n// supplied\n\nfloat hypotenuse(int|float side1, int|float side2)\n{\n  // If 'int' arguments passed. convert to 'float'\n  float s1 = intp(side1) ? (float) side1 : side1;\n  float s2 = intp(side2) ? (float) side2 : side2;\n\n  return s1 * s1 + s2 * s2;\n}\n\n// ----\n// Both are legal calls\n\nfloat diag = hypotenuse(3.0, 4.0);\nfloat diag = hypotenuse(3, 4);\n\n// ------------\n\n// (2). Here the function still expects to be called with two arguments\n// but each may be of *any* type [admittedly a very contrived example\n// of little utility except for illustrative value]. Such a function\n// is almost entirely reliant on careful runtime type checking if it\n// is to behave reliably\n\nfloat hypotenuse(mixed side1, mixed side2)\n{\n  if (stringp(side1)) { ... }\n  if (arrayp(side1)) { ... }\n  if (objectp(side1)) { ... }\n}\n\n// ----\n// All are legal calls\n\nfloat diag = hypotenuse(3.0, 4.0);\nfloat diag = hypotenuse(3, 4);\nfloat diag = hypotenuse(\"3\", \"4\");\nfloat diag = (({3}), ({4}));\n\n// ------------\n\n// (3). Here, the function is defined to accept two, mandatory\n// parameters [still accessable via name], then a set of zero or more\n// optional parameters, which are accessable within the function body\n// via an array [the placeholder, 'args', represents an array of zero\n// or more elements each corresponding to one of the passed arguments\n\nfloat hypotenuse(float side1, mixed side2, mixed ... args)\n{\n  // Mandatory parameters still accessable as usual\n  ... side1 ... side2 ...\n\n  // Total number of arguments passed to function determinable via:\n  int total_passed_args = query_num_arg();\n\n  // 'args' contains all optional arguments: 0 - N\n  int optional_args = sizeof(args);\n\n  // Process variable arguments ...\n  foreach(args, mixed arg)\n  {\n    ... if (strinp(arg)) { ... }\n  }\n\n  ...\n}\n\n// ----\n// All are legal calls\n\nfloat diag = hypotenuse(3.0, 4.0);\nfloat diag = hypotenuse(3.0, 4.0, \"a\");\nfloat diag = hypotenuse(3.0, 4.0, lambda(){ return 5; }, \"fff\");\nfloat diag = hypotenuse(3.0, 4.0, 1, \"x\", ({ 6, 7, 9 }));\n\n// ----------------------------\n\n// Modifies copy\narray(int|float) int_all(array(int|float) arr)\n{\n  array(int|float) retarr = copy_value(arr);\n  int i; for(int i; i < sizeof(retarr); ++i) { retarr[i] = (int) arr[i]; }\n  return retarr;\n}\n\n// Modifies original\n\narray(int|float) trunc_all(array(int|float) arr)\n{\n  int i; for(int i; i < sizeof(arr); ++i) { arr[i] = (int) arr[i]; }\n  return arr;\n}\n\n// ----\n\narray(int|float) nums = ({1.4, 3.5, 6.7});\n\n// Copy modified - 'ints' and 'nums' separate arrays\narray(int|float) ints = int_all(nums);\nwrite(\"%O\\n\", nums);\nwrite(\"%O\\n\", ints);\n\n// Original modified - 'ints' acts as alias for 'nums'\nints = trunc_all(nums);\nwrite(\"%O\\n\", nums);\nwrite(\"%O\\n\", ints);\n"})}),"\n",(0,a.jsx)(e.h2,{id:"making-variables-private-to-a-function",children:"Making Variables Private to a Function"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-pike",children:"#pragma strict_types\n\nvoid some_func()\n{\n  // Variables declared within a function are local to that function\n  mixed variable = something;\n}\n\n// ----------------------------\n\n// Assuming these are defined at file level, that is, outside of 'main'\n// or any other function they are accessable by every other member of\n// the same file [and if this file (read: class or program) is the\n// only one comprising the 'system', they are effectively 'global']\n\nstring name = argv[1]; int age = (int) argv[2];\n\nint c = fetch_time();\n\nint condition;\n\n// ------------\n\nint run_check()\n{\n  ...\n  condition = 1;\n}\n\nint check_x(int x)\n{\n  string y = \"whatever\";\n\n  // Whilst 'run_check' has access to 'name', 'age', and 'c' [because\n  // these are declared at a higher scope], it does not have access to\n  // 'y' or any other locally defined variable\n  run_check();\n\n  // 'run_check' will have updated 'condition'\n  if (condition) write(\"got x: %d\\n\", x);\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"creating-persistent-private-variables",children:"Creating Persistent Private Variables"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-pike",children:'#pragma strict_types\n// Pike does not implement C style \'static\' variables [i.e. persisent\n// local variables], nor does it implement C++ style \'class variables\'\n// [oddly enough, also implemented in C++ via use of the \'static\'\n// keyword], both of which could be used to implement solutions to the\n// problems presented in this section. Also, there is no direct\n// equivalent to Perl\'s \'BEGIN\' block [closest equivalent is the\n// class \'create\' method]. So, to solve a problem like implementing a\n// \'counter\':\n\n// * Use Pike\'s OOP facilities [simple, natural]\n// * Use closures [somewhat unwieldly, but possible]\n\n// OOP Approach\nclass Counter\n{\n  private int counter;\n\n  static void create(int start) { counter = start; }\n  public int next() { return ++counter; }\n  public int prev() { return --counter; }\n}\n\n// ----\n\nint main()\n{\n  Counter counter = Counter(42);\n\n  write("%d\\n", counter->next());\n  write("%d\\n", counter->prev());\n}\n\n// ----------------------------\n\n// A refinement of the previous implementation that mimics \'static\'\n// variables\n\nclass Static\n{\n  // \'static\' variable that is shared by all instance of \'Counter\'\n  int counter;\n\n  class Counter\n  {\n    public int next() { return ++counter; }\n    public int prev() { return --counter; }\n  }\n\n  Counter make() { return Counter(); }\n\n  public void create(int counter_) { counter = counter_; }\n}\n\n// ----\n\nint main()\n{\n  Static mkst = Static(42);\n\n  Static.Counter counter_1 = mkst->make();\n  Static.Counter counter_2 = mkst->make();\n\n  // Same value of, \'counter\', is accessed by each object\n  write("%d\\n", counter_1->next());\n  write("%d\\n", counter_1->next());\n\n  write("%d\\n", counter_2->next());\n  write("%d\\n", counter_2->prev());\n}\n\n// ----------------------------\n\n// Closure Approach [Admittedly somewhat contrived: a Scheme overdose ;) !]\n\nfunction(string : function(void : int)) make_counter(int start)\n{\n  int counter = start;\n  int next_counter() { return ++counter; };\n  int prev_counter() { return --counter; };\n\n  return\n    lambda(string op)\n    {\n      if (op == "next") return next_counter;\n      if (op == "prev") return prev_counter;\n      return 0;\n    };\n}\n\nint main()\n{\n  function(string : function(void : int)) counter = make_counter(42);\n\n  function(void : int) next = counter("next");\n  function(void : int) prev = counter("prev");\n\n  write("%d\\n", next());\n  write("%d\\n", next());\n  write("%d\\n", prev());\n  write("%d\\n", prev());\n}\n'})})]})}function d(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(u,{...n})}):u(n)}},8453(n,e,t){t.d(e,{R:()=>s,x:()=>o});var i=t(6540);const a={},r=i.createContext(a);function s(n){const e=i.useContext(r);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:s(n.components),i.createElement(r.Provider,{value:e},n.children)}}}]);