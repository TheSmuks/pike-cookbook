"use strict";(self.webpackChunkpike_cookbook=self.webpackChunkpike_cookbook||[]).push([[982],{5667(n,e,r){r.r(e),r.d(e,{assets:()=>d,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"advanced/references","title":"References and Records","description":"Introduction","source":"@site/docs/advanced/references.md","sourceDirName":"advanced","slug":"/advanced/references","permalink":"/pike-cookbook/docs/advanced/references","draft":false,"unlisted":false,"editUrl":"https://github.com/TheSmuks/pike-cookbook/tree/main/docs/advanced/references.md","tags":[],"version":"current","frontMatter":{"id":"references","title":"References and Records","sidebar_label":"References and Records"},"sidebar":"tutorialSidebar","previous":{"title":"Classes and Objects","permalink":"/pike-cookbook/docs/advanced/classes"},"next":{"title":"Modules and Packages","permalink":"/pike-cookbook/docs/advanced/modules"}}');var i=r(4848),a=r(8453);const s={id:"references",title:"References and Records",sidebar_label:"References and Records"},o="References and Records",d={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Taking References to Arrays",id:"taking-references-to-arrays",level:2},{value:"Making Hashes of Arrays",id:"making-hashes-of-arrays",level:2},{value:"Taking References to Hashes",id:"taking-references-to-hashes",level:2},{value:"Taking References to Functions",id:"taking-references-to-functions",level:2},{value:"Taking References to Scalars",id:"taking-references-to-scalars",level:2},{value:"Creating Arrays of Scalar References",id:"creating-arrays-of-scalar-references",level:2},{value:"Using Closures Instead of Objects",id:"using-closures-instead-of-objects",level:2},{value:"Creating References to Methods",id:"creating-references-to-methods",level:2},{value:"Constructing Records",id:"constructing-records",level:2},{value:"Reading and Writing Hash Records to Text Files",id:"reading-and-writing-hash-records-to-text-files",level:2},{value:"Printing Data Structures",id:"printing-data-structures",level:2},{value:"Copying Data Structures",id:"copying-data-structures",level:2},{value:"Storing Data Structures to Disk",id:"storing-data-structures-to-disk",level:2},{value:"Transparently Persistent Data Structures",id:"transparently-persistent-data-structures",level:2},{value:"Program: Binary Search Tree",id:"program-binary-search-tree",level:2},{value:"See Also",id:"see-also",level:2}];function l(n){const e={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"references-and-records",children:"References and Records"})}),"\n",(0,i.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"What this covers"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Reference types vs value types in Pike 8"}),"\n",(0,i.jsx)(e.li,{children:"Working with arrays, mappings, and functions as references"}),"\n",(0,i.jsx)(e.li,{children:"Creating and managing complex data structures"}),"\n",(0,i.jsx)(e.li,{children:"Implementing records with classes and mappings"}),"\n",(0,i.jsx)(e.li,{children:"Serializing and persisting data structures"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Why use it"}),"\nUnderstanding Pike's reference system is crucial for effective memory management and data manipulation. Unlike some languages that require explicit reference operators, Pike's approach to references provides both simplicity and power. This guide shows you how to leverage Pike's reference counting, garbage collection, and first-class functions to write clean, efficient code."]}),"\n",(0,i.jsx)(e.admonition,{title:"Key Concept",type:"tip",children:(0,i.jsxs)(e.p,{children:["In Pike 8, arrays, mappings, and objects are ",(0,i.jsx)(e.strong,{children:"always reference types"}),", while basic types (int, float, string) are ",(0,i.jsx)(e.strong,{children:"value types"}),". You don't need special operators to create references - assignment creates a reference for complex types."]})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'// Pike 8 - Reference basics\n#pragma strict_types\n\n// Arrays are reference types\narray(int) arr1 = ({1, 2, 3});\narray(int) arr2 = arr1;  // Both point to same array\narr2[0] = 99;            // Modifies the shared array\nwrite("arr1[0]: %d\\n", arr1[0]);  // Output: 99\n\n// Basic types are value types\nint x = 5;\nint y = x;     // Copy of the value\ny = 10;\nwrite("x: %d, y: %d\\n", x, y);  // Output: x: 5, y: 10\n\n// Mappings are reference types\nmapping(string:int) m1 = (["apple": 1]);\nmapping(string:int) m2 = m1;\nm2["apple"] = 2;\nwrite("m1[\\"apple\\"]: %d\\n", m1["apple"]);  // Output: 2\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"taking-references-to-arrays",children:"Taking References to Arrays"}),"\n",(0,i.jsx)(e.p,{children:"In Pike, you don't need explicit reference operators for arrays. Arrays are always reference types. For explicit reference semantics, use the ADT.Array module or store arrays in containers."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Work with array references\n//-----------------------------\n#pragma strict_types\nimport ADT;\n\n// Simple array assignment creates a reference\narray(string) fruits = ({"apple", "banana", "cherry"});\narray(string) ref = fruits;  // Reference to same array\nref[0] = "apricot";\nwrite("fruits[0]: %s\\n", fruits[0]);  // Output: apricot\n\n// Using modern ADT.Array for explicit array operations\nArray arr = Array();\narr->push("first");\narr->push("second");\nwrite("Array contents: %s\\n", arr->cast(array));  // Output: ({ "first", "second" })\n\n// Array of arrays (nested structures)\narray(array(int)) matrix = ({\n    ({1, 2, 3}),\n    ({4, 5, 6}),\n    ({7, 8, 9})\n});\n\narray(int) row = matrix[0];  // Reference to first row\nrow[0] = 99;\nwrite("matrix[0][0]: %d\\n", matrix[0][0]);  // Output: 99\n\n// Safe indexing with ->? operator (Pike 8)\narray(int) maybe_empty = ({});\nint|zero val = maybe_empty->[0];  // Safe indexing returns UNDEFINED or 0\nwrite("Safe access: %d\\n", val);  // 0 if out of bounds\n'})}),"\n",(0,i.jsx)(e.admonition,{type:"tip",children:(0,i.jsxs)(e.p,{children:["Use the ",(0,i.jsx)(e.code,{children:"->?[]"})," operator for safe array indexing that returns ",(0,i.jsx)(e.code,{children:"UNDEFINED"})," instead of throwing an error when the index is out of bounds. This is especially useful when working with user input or dynamic data."]})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"making-hashes-of-arrays",children:"Making Hashes of Arrays"}),"\n",(0,i.jsx)(e.p,{children:"Pike uses mappings (hash tables) where values can be arrays. Create complex data structures by nesting arrays within mappings."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Create mapping of arrays\n//-----------------------------\n#pragma strict_types\n\n// Mapping with array values\nmapping(string:array(string)) employees = ([\n    "engineering": ({"alice", "bob", "charlie"}),\n    "sales": ({"david", "eve"}),\n    "marketing": ({"frank"})\n]);\n\n// Access and modify\nemployees["engineering"] += ({"david"});  // Add to array\nwrite("Engineering team: %s\\n", employees["engineering"] * ", ");\n\n// Safe indexing with ->?\narray(string)|zero dept = employees->["engineering"];\nif (dept) {\n    write("Department exists\\n");\n}\n\n// Initialize hash of arrays dynamically\nmapping(string:array(int)) scores = ([]);\n\nvoid add_score(string category, int score) {\n    if (!scores[category]) {\n        scores[category] = ({});\n    }\n    scores[category] += ({score});\n}\n\nadd_score("player1", 100);\nadd_score("player1", 150);\nadd_score("player2", 200);\n\n// Display all scores\nforeach (scores; string category; array(int) arr) {\n    write("%s: %s\\n", category, arr * ", ");\n}\n'})}),"\n",(0,i.jsx)(e.admonition,{type:"note",children:(0,i.jsx)(e.p,{children:"When dynamically building a hash of arrays, always check if the key exists before appending. This prevents errors and ensures clean initialization of array values."})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"taking-references-to-hashes",children:"Taking References to Hashes"}),"\n",(0,i.jsx)(e.p,{children:"Mappings in Pike are always reference types. Assign a mapping to another variable to create a reference to the same mapping."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Work with mapping references\n//-----------------------------\n#pragma strict_types\n\n// Mapping reference\nmapping(string:int) colors = ([\n    "red": 0xFF0000,\n    "green": 0x00FF00,\n    "blue": 0x0000FF\n]);\n\nmapping(string:int) ref = colors;  // Reference to same mapping\nref["red"] = 0x110000;\nwrite("colors[\\"red\\"]: %x\\n", colors["red"]);  // Output: 110000\n\n// Mapping of mappings\nmapping(string:mapping(string:int)) user_data = ([\n    "user1": (["age": 25, "score": 100]),\n    "user2": (["age": 30, "score": 150])\n]);\n\nmapping(string:int)|zero data = user_data->["user1"];\nif (data) {\n    data["score"] = 200;\n    write("Modified score: %d\\n", user_data["user1"]["score"]);  // Output: 200\n}\n\n// Copy mapping (shallow copy)\nmapping(string:int) copy = colors + ([]);\ncopy["green"] = 0x001100;\nwrite("Original green: %x, Copy green: %x\\n",\n      colors["green"], copy["green"]);\n\n// Deep copy function\nmapping(string:mapping(string:int)) deep_copy(mapping(string:mapping(string:int)) m) {\n    mapping(string:mapping(string:int)) result = ([]);\n    foreach (m; string key; mapping(string:int) val) {\n        result[key] = val + ([]);  // Shallow copy of inner mapping\n    }\n    return result;\n}\n'})}),"\n",(0,i.jsx)(e.admonition,{type:"warning",children:(0,i.jsxs)(e.p,{children:["Remember that ",(0,i.jsx)(e.code,{children:"mapping + ([])"})," creates a ",(0,i.jsx)(e.strong,{children:"shallow copy"}),". For nested mappings or mappings containing arrays, you'll need a recursive deep copy function to avoid unintended sharing of nested data."]})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"taking-references-to-functions",children:"Taking References to Functions"}),"\n",(0,i.jsx)(e.p,{children:"Pike supports first-class functions. Store functions in variables, pass them as arguments, and return them from other functions."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Use functions as first-class citizens\n//-----------------------------\n#pragma strict_types\n\n// Simple function reference\nint add(int a, int b) {\n    return a + b;\n}\n\nint multiply(int a, int b) {\n    return a * b;\n}\n\n// Store function in variable\nfunction(int,int:int) operation = add;\nwrite("5 + 3 = %d\\n", operation(5, 3));  // Output: 8\n\n// Change function reference\noperation = multiply;\nwrite("5 * 3 = %d\\n", operation(5, 3));  // Output: 15\n\n// Higher-order function\narray(int) apply_op(array(int) arr, function(int:int) func) {\n    return map(arr, func);\n}\n\n// Lambda functions\narray(int) nums = ({1, 2, 3, 4, 5});\narray(int) doubled = apply_op(nums, lambda(int x) { return x * 2; });\narray(int) squared = apply_op(nums, lambda(int x) { return x * x; });\n\nwrite("Doubled: %s\\n", doubled * ", ");    // Output: 2, 4, 6, 8, 10\nwrite("Squared: %s\\n", squared * ", ");    // Output: 1, 4, 9, 16, 25\n\n// Array of functions\narray(function(int,int:int)) ops = ({\n    lambda(int a, int b) { return a + b; },\n    lambda(int a, int b) { return a - b; },\n    lambda(int a, int b) { return a * b; }\n});\n\nforeach (ops; int i; function(int,int:int) op) {\n    write("op[%d](10, 5) = %d\\n", i, op(10, 5));\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"taking-references-to-scalars",children:"Taking References to Scalars"}),"\n",(0,i.jsx)(e.p,{children:"Pike doesn't have scalar references like Perl. Instead, use containers (single-element arrays or mappings) to achieve similar behavior."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Simulate scalar references with containers\n//-----------------------------\n#pragma strict_types\n\n// Using single-element array as reference\narray(int) ref = ({10});\nvoid modify_ref(array(int) r) {\n    r[0] = 20;\n}\nmodify_ref(ref);\nwrite("ref[0]: %d\\n", ref[0]);  // Output: 20\n\n// Using mapping as reference\nmapping(string:int) container = (["value": 100]);\nvoid modify_container(mapping(string:int) c) {\n    c["value"] = 200;\n}\nmodify_container(container);\nwrite("container[\\"value\\"]: %d\\n", container["value"]);  // Output: 200\n\n// Return multiple values via mapping\nmapping(string:mixed) divide(int a, int b) {\n    if (b == 0) {\n        error("Division by zero");\n    }\n    return ([\n        "quotient": a / b,\n        "remainder": a % b\n    ]);\n}\n\nmapping(string:mixed) result = divide(17, 5);\nwrite("17 / 5 = %d, remainder %d\\n",\n      result["quotient"], result["remainder"]);  // Output: 17 / 5 = 3, remainder 2\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"creating-arrays-of-scalar-references",children:"Creating Arrays of Scalar References"}),"\n",(0,i.jsx)(e.p,{children:"Use arrays or mappings as container objects to create arrays of mutable references."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Build array of container references\n//-----------------------------\n#pragma strict_types\n\n// Array of single-element arrays (simulating references)\narray(array(int)) refs = ({});\nfor (int i = 0; i < 5; i++) {\n    refs += ({ ({i}) });  // Each element is an array containing one value\n}\n\n// Modify through "references"\nrefs[0][0] = 99;\nrefs[2][0] = 88;\n\nforeach (refs; int i; array(int) ref) {\n    write("refs[%d] = %d\\n", i, ref[0]);\n}\n// Output:\n// refs[0] = 99\n// refs[1] = 1\n// refs[2] = 88\n// refs[3] = 3\n// refs[4] = 4\n\n// Practical example: updating multiple values\narray(mapping(string:int)) counters = ({\n    (["value": 0]),\n    (["value": 0]),\n    (["value": 0])\n});\n\nvoid increment_all(array(mapping(string:int)) counters) {\n    foreach (counters; int i; mapping(string:int) c) {\n        c["value"]++;\n    }\n}\n\nincrement_all(counters);\nwrite("Counters: %s\\n", counters->value * ", ");  // Output: 1, 1, 1\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"using-closures-instead-of-objects",children:"Using Closures Instead of Objects"}),"\n",(0,i.jsx)(e.p,{children:"Pike supports closures through lambda functions that capture variables from their enclosing scope. Use closures for encapsulation and state management."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Create closures for encapsulation\n//-----------------------------\n#pragma strict_types\n\n// Counter using closure\nfunction(int:void) create_counter(int start) {\n    int count = start;\n    return lambda(int delta) {\n        count += delta;\n        write("Count: %d\\n", count);\n    };\n}\n\nfunction(int:void) counter1 = create_counter(0);\nfunction(int:void) counter2 = create_counter(100);\n\ncounter1(1);   // Output: Count: 1\ncounter1(1);   // Output: Count: 2\ncounter2(10);  // Output: Count: 110\ncounter1(5);   // Output: Count: 7\n\n// Getter/setter using closure\nmapping(string:function) create_property(mixed initial_value) {\n    mixed value = initial_value;\n    return ([\n        "get": lambda() {\n            return value;\n        },\n        "set": lambda(mixed new_val) {\n            value = new_val;\n        }\n    ]);\n}\n\nmapping(string:function) prop = create_property("initial");\nwrite("Value: %s\\n", prop["get"]());  // Output: Value: initial\nprop["set"]("modified");\nwrite("Value: %s\\n", prop["get"]());  // Output: Value: modified\n\n// Private state with accessors\nfunction(void:mixed|int|string) create_bank_account(int initial) {\n    int balance = initial;\n    string owner = "unknown";\n\n    return lambda(mixed|int|string|void arg) {\n        if (stringp(arg)) {\n            // Set owner\n            owner = arg;\n            return owner;\n        } else if (intp(arg)) {\n            // Deposit/withdraw\n            balance += arg;\n            return balance;\n        } else {\n            // Get balance\n            return balance;\n        }\n    };\n}\n\nfunction(mixed:int|string) account = create_bank_account(100);\nwrite("Balance: %d\\n", account());         // Output: Balance: 100\naccount(50);                                // Deposit\nwrite("Balance: %d\\n", account());         // Output: Balance: 150\naccount("Alice");                           // Set owner\n'})}),"\n",(0,i.jsx)(e.admonition,{type:"tip",children:(0,i.jsx)(e.p,{children:"Closures in Pike capture variables from their enclosing scope, creating private state that persists between function calls. This is perfect for implementing encapsulation without the overhead of full classes."})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"creating-references-to-methods",children:"Creating References to Methods"}),"\n",(0,i.jsx)(e.p,{children:"Store method references in Pike using class methods and function pointers. Pike supports object-oriented programming with proper method references."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Store and pass method references\n//-----------------------------\n#pragma strict_types\n\nclass Calculator {\n    int add(int a, int b) {\n        return a + b;\n    }\n\n    int multiply(int a, int b) {\n        return a * b;\n    }\n\n    int apply(function(int,int:int) op, int a, int b) {\n        return op(a, b);\n    }\n}\n\nCalculator calc = Calculator();\n\n// Direct method call\nwrite("add: %d\\n", calc->add(5, 3));        // Output: add: 8\n\n// Method reference\nfunction(int,int:int) method = calc->add;\nwrite("method(5, 3): %d\\n", method(5, 3));  // Output: method(5, 3): 8\n\n// Pass method as argument\nwrite("apply multiply: %d\\n", calc->apply(calc->multiply, 4, 3));  // Output: 12\n\n// Array of method references\narray(function(int,int:int)) ops = ({\n    calc->add,\n    calc->multiply\n});\n\nforeach (ops; int i; function(int,int:int) op) {\n    write("Operation %d: 5, 3 -> %d\\n", i, op(5, 3));\n}\n\n// Callback pattern\nclass Processor {\n    array(int) process(array(int) data, function(int:int) func) {\n        return map(data, func);\n    }\n}\n\nProcessor proc = Processor();\narray(int) numbers = ({1, 2, 3, 4, 5});\n\n// Using lambda as callback\narray(int) result = proc->process(numbers, lambda(int x) { return x * 2; });\nwrite("Doubled: %s\\n", result * ", ");  // Output: 2, 4, 6, 8, 10\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"constructing-records",children:"Constructing Records"}),"\n",(0,i.jsx)(e.p,{children:'Pike doesn\'t have a dedicated "record" type. Use mappings or classes to create record-like structures. Classes provide type safety and methods.'}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Create records with classes\n//-----------------------------\n#pragma strict_types\n\n// Simple record using mapping\nmapping(string:mixed) create_person(string name, int age, string city) {\n    return ([\n        "name": name,\n        "age": age,\n        "city": city\n    ]);\n}\n\nmapping(string:mixed) person1 = create_person("Alice", 30, "NYC");\nmapping(string:mixed) person2 = create_person("Bob", 25, "LA");\n\nwrite("%s is %d years old\\n", person1["name"], person1["age"]);\n\n// Record using class (type-safe)\nclass Person {\n    string name;\n    int age;\n    string city;\n\n    void create(string name, int age, string city) {\n        this->name = name;\n        this->age = age;\n        this->city = city;\n    }\n\n    string get_summary() {\n        return sprintf("%s (%d) from %s", name, age, city);\n    }\n\n    void birthday() {\n        age++;\n    }\n}\n\nPerson p1 = Person("Charlie", 35, "Chicago");\nPerson p2 = Person("Diana", 28, "Boston");\n\nwrite("Person: %s\\n", p1->get_summary());  // Output: Person: Charlie (35) from Chicago\np1->birthday();\nwrite("After birthday: %d\\n", p1->age);    // Output: After birthday: 36\n\n// Array of records\narray(Person) people = ({\n    Person("Eve", 22, "Seattle"),\n    Person("Frank", 40, "Denver"),\n    Person("Grace", 31, "Austin")\n});\n\nforeach (people; int i; Person p) {\n    write("%d: %s\\n", i, p->get_summary());\n}\n\n// Record with validation\nclass Employee {\n    private string _name;\n    private int _id;\n    private float _salary;\n\n    void create(string name, int id, float salary) {\n        if (salary < 0) {\n            error("Salary cannot be negative");\n        }\n        _name = name;\n        _id = id;\n        _salary = salary;\n    }\n\n    string name() { return _name; }\n    int id() { return _id; }\n    float salary() { return _salary; }\n\n    void raise(float percent) {\n        if (percent < 0) {\n            error("Raise percent cannot be negative");\n        }\n        _salary *= (1.0 + percent / 100.0);\n    }\n}\n\nEmployee emp = Employee("Alice", 1001, 50000.0);\nemp->raise(10.0);\nwrite("New salary: %.2f\\n", emp->salary());  // Output: New salary: 55000.00\n'})}),"\n",(0,i.jsx)(e.admonition,{type:"tip",children:(0,i.jsx)(e.p,{children:"Classes are the recommended way to create records in Pike 8. They provide encapsulation, type safety, validation, and methods - all the benefits of object-oriented programming while maintaining the simplicity of record-like structures."})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"reading-and-writing-hash-records-to-text-files",children:"Reading and Writing Hash Records to Text Files"}),"\n",(0,i.jsx)(e.p,{children:"Serialize mapping data to text files using various formats. Pike provides encode_value for binary serialization and manual methods for text formats."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Persist records to text files\n//-----------------------------\n#pragma strict_types\n\nconstant DATA_FILE = "records.txt";\n\n// Write records as simple key-value pairs\nvoid write_records(array(mapping(string:string)) records, string filename) {\n    Stdio.File file = Stdio.File();\n    if (!file->open(filename, "wct")) {\n        error("Cannot open file for writing: " + strerror(file->errno()));\n    }\n\n    foreach (records; int i; mapping(string:string) record) {\n        foreach (record; string key; string value) {\n            file->write("%s=%s\\n", key, value);\n        }\n        file->write("---\\n");  // Record separator\n    }\n\n    file->close();\n}\n\n// Read records from file\narray(mapping(string:string)) read_records(string filename) {\n    Stdio.File file = Stdio.File();\n    if (!file->open(filename, "r")) {\n        error("Cannot open file for reading: " + strerror(file->errno()));\n    }\n\n    array(mapping(string:string)) records = ({});\n    mapping(string:string) current = ([]);\n\n    foreach (file->line_iterator(1); ; string line) {\n        line = String.trim_whites(line);\n        if (line == "" || line == "---") {\n            if (sizeof(current)) {\n                records += ({ current });\n                current = ([]);\n            }\n            continue;\n        }\n\n        array(string) parts = line / "=";\n        if (sizeof(parts) == 2) {\n            current[parts[0]] = parts[1];\n        }\n    }\n\n    if (sizeof(current)) {\n        records += ({ current });\n    }\n\n    file->close();\n    return records;\n}\n\n// Usage\narray(mapping(string:string)) employees = ({\n    (["name": "Alice", "id": "1001", "dept": "Engineering"]),\n    (["name": "Bob", "id": "1002", "dept": "Sales"]),\n    (["name": "Charlie", "id": "1003", "dept": "Marketing"])\n});\n\nwrite_records(employees, DATA_FILE);\narray(mapping(string:string)) loaded = read_records(DATA_FILE);\n\nforeach (loaded; int i; mapping(string:string) emp) {\n    write("Employee %d: %s (%s) - %s\\n",\n          i, emp["name"], emp["id"], emp["dept"]);\n}\n'})}),"\n",(0,i.jsx)(e.admonition,{type:"warning",children:(0,i.jsxs)(e.p,{children:["For production applications, consider using JSON, XML, or Pike's native ",(0,i.jsx)(e.code,{children:"encode_value()"}),"/",(0,i.jsx)(e.code,{children:"decode_value()"})," functions for better data integrity and error handling than simple text formats."]})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"printing-data-structures",children:"Printing Data Structures"}),"\n",(0,i.jsx)(e.p,{children:"Use Pike's built-in functions to inspect and debug data structures. sprintf with %O provides detailed output."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Pretty-print data structures\n//-----------------------------\n#pragma strict_types\n\n// Simple arrays and mappings\narray(int) nums = ({1, 2, 3, 4, 5});\nmapping(string:int) colors = (["red": 1, "green": 2, "blue": 3]);\n\nwrite("Array: %s\\n", (string)nums);        // Output: Array: ({1, 2, 3, 4, 5})\nwrite("Mapping: %s\\n", (string)colors);     // Output: Mapping: (["blue": 3, "green": 2, "red": 1])\n\n// Using %O for detailed output\nwrite("Detailed array: %O\\n", nums);\nwrite("Detailed mapping: %O\\n", colors);\n\n// Pretty print function\nstring pretty_print(mixed data, int|void indent) {\n    indent = indent || 0;\n    string ind = " " * indent;\n\n    if (arrayp(data)) {\n        array(string) parts =({});\n        parts += ({ind + "({\\n"});\n        foreach (data; int i; mixed val) {\n            parts += ({pretty_print(val, indent + 2)});\n            if (i < sizeof(data) - 1) {\n                parts[-1] += ",";\n            }\n            parts[-1] += "\\n";\n        }\n        parts += ({ind + "})"});\n        return parts * "";\n    } else if (mappingp(data)) {\n        array(string) parts =({});\n        parts += ({ind + "([\\n"});\n        array(string) keys = indices(data);\n        foreach (keys; int i; string key) {\n            parts += ({sprintf("%s%s: %s", ind + "  ", key,\n                               pretty_print(data[key], 0))});\n            if (i < sizeof(keys) - 1) {\n                parts[-1] += ",";\n            }\n            parts[-1] += "\\n";\n        }\n        parts += ({ind + "])"});\n        return parts * "";\n    } else {\n        return sprintf("%O", data);\n    }\n}\n\n// Complex nested structure\nmapping(string:mixed) complex = ([\n    "users": ({\n        (["name": "Alice", "age": 30]),\n        (["name": "Bob", "age": 25])\n    }),\n    "settings": ([\n        "theme": "dark",\n        "notifications": true\n    ])\n]);\n\nwrite("Complex structure:\\n%s\\n", pretty_print(complex));\n\n// Using Stdio.File.write for formatted output\nvoid debug_dump(string label, mixed data) {\n    write("=== %s ===\\n", label);\n    write("%O\\n", data);\n    write("===================\\n\\n");\n}\n\ndebug_dump("Numbers array", nums);\ndebug_dump("Colors mapping", colors);\n\n// Pretty print with indices\nvoid print_with_indices(array(mixed) arr) {\n    foreach (arr; int i; mixed val) {\n        write("[%d] %O\\n", i, val);\n    }\n}\n\narray(string) fruits = ({"apple", "banana", "cherry"});\nprint_with_indices(fruits);\n// Output:\n// [0] "apple"\n// [1] "banana"\n// [2] "cherry"\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"copying-data-structures",children:"Copying Data Structures"}),"\n",(0,i.jsx)(e.p,{children:"Pike provides shallow copying by default. Implement deep copy recursively for nested structures."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Deep copy nested structures\n//-----------------------------\n#pragma strict_types\n\n// Shallow copy of array\narray(int) original = ({1, 2, 3});\narray(int) shallow = original + ({});  // Add empty array to create copy\nshallow[0] = 99;\nwrite("Original[0]: %d, Shallow[0]: %d\\n", original[0], shallow[0]);\n// Output: Original[0]: 1, Shallow[0]: 99\n\n// Shallow copy of mapping\nmapping(string:int) m_original = (["a": 1, "b": 2]);\nmapping(string:int) m_shallow = m_original + ([]);  // Add empty mapping\nm_shallow["a"] = 99;\nwrite("Original[\'a\']: %d, Shallow[\'a\']: %d\\n",\n      m_original["a"], m_shallow["a"]);\n\n// Deep copy function\nmixed deep_copy(mixed data) {\n    if (arrayp(data)) {\n        array(mixed) result =({});\n        foreach (data; int i; mixed val) {\n            result += ({deep_copy(val)});\n        }\n        return result;\n    } else if (mappingp(data)) {\n        mapping(mixed:mixed) result = ([]);\n        foreach (data; mixed key; mixed val) {\n            result[deep_copy(key)] = deep_copy(val);\n        }\n        return result;\n    } else if (multisetp(data)) {\n        multiset(mixed) result = (<>);\n        foreach (data; mixed val; ) {\n            result[deep_copy(val)] = true;\n        }\n        return result;\n    } else {\n        return data;  // Basic types are immutable\n    }\n}\n\n// Test deep copy with nested structure\narray(array(int)) nested = ({\n    ({1, 2, 3}),\n    ({4, 5, 6})\n});\n\narray(array(int)) nested_copy = deep_copy(nested);\nnested_copy[0][0] = 999;\n\nwrite("Original[0][0]: %d\\n", nested[0][0]);        // Output: 1\nwrite("Copy[0][0]: %d\\n", nested_copy[0][0]);        // Output: 999\n\n// Deep copy with complex mapping\nmapping(string:mixed) complex = ([\n    "numbers": ({1, 2, 3}),\n    "nested": (["inner": (["data": "value"])])\n]);\n\nmapping(string:mixed) complex_copy = deep_copy(complex);\ncomplex_copy["nested"]["inner"]["data"] = "modified";\n\nwrite("Original data: %s\\n", complex["nested"]["inner"]["data"]);      // Output: value\nwrite("Copy data: %s\\n", complex_copy["nested"]["inner"]["data"]);    // Output: modified\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"storing-data-structures-to-disk",children:"Storing Data Structures to Disk"}),"\n",(0,i.jsx)(e.p,{children:"Use Pike's encode_value and decode_value for efficient binary serialization of data structures."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Serialize data to disk\n//-----------------------------\n#pragma strict_types\n\nconstant DATA_FILE = "datastore.dat";\n\n// Save data structure to disk\nvoid save_data(mixed data, string filename) {\n    string encoded = encode_value(data);\n    Stdio.File file = Stdio.File(filename, "wct");\n    if (!file) {\n        error("Cannot open file for writing");\n    }\n    file->write(encoded);\n    file->close();\n    write("Saved data to %s (%d bytes)\\n", filename, sizeof(encoded));\n}\n\n// Load data structure from disk\nmixed load_data(string filename) {\n    Stdio.File file = Stdio.File(filename, "r");\n    if (!file) {\n        error("Cannot open file for reading");\n    }\n    string encoded = file->read();\n    file->close();\n    mixed data = decode_value(encoded);\n    write("Loaded data from %s\\n", filename);\n    return data;\n}\n\n// Complex data structure\nmapping(string:mixed) app_data = ([\n    "version": "1.0",\n    "users": ({\n        (["name": "Alice", "age": 30, "scores": ({90, 85, 95})]),\n        (["name": "Bob", "age": 25, "scores": ({80, 75, 85})])\n    }),\n    "settings": ([\n        "theme": "dark",\n        "language": "en",\n        "autosave": true\n    ])\n]);\n\n// Save and load\nsave_data(app_data, DATA_FILE);\nmapping(string:mixed) loaded = load_data(DATA_FILE);\n\nwrite("Loaded version: %s\\n", loaded["version"]);\nwrite("Loaded users: %d\\n", sizeof(loaded["users"]));\n\n// Encode with codec for custom object support\nmixed save_with_codec(mixed data) {\n    // Use default codec\n    return encode_value(data, Codec());\n}\n\nmixed load_with_codec(string data) {\n    return decode_value(data, Codec());\n}\n\n// Incremental saves using History ADT\nimport ADT.History;\n\nclass HistoryStore {\n    private History _history = History();\n    private string _filename;\n\n    void create(string filename) {\n        _filename = filename;\n    }\n\n    void save(mixed data) {\n        _history->push_history(deep_copy(data));\n        save_data(_history->current(), _filename);\n    }\n\n    mixed|zero load() {\n        mixed data = load_data(_filename);\n        _history->push_history(data);\n        return data;\n    }\n\n    mixed|zero undo() {\n        return _history->pop_history();\n    }\n\n    private mixed deep_copy(mixed data) {\n        if (arrayp(data)) {\n            return map(data, deep_copy);\n        } else if (mappingp(data)) {\n            mapping(mixed:mixed) result = ([]);\n            foreach (data; mixed k; mixed v) {\n                result[deep_copy(k)] = deep_copy(v);\n            }\n            return result;\n        }\n        return data;\n    }\n}\n'})}),"\n",(0,i.jsx)(e.admonition,{type:"tip",children:(0,i.jsxs)(e.p,{children:["The ",(0,i.jsx)(e.code,{children:"encode_value()"})," and ",(0,i.jsx)(e.code,{children:"decode_value()"})," functions provide Pike's native binary serialization format. They're more efficient than text formats and preserve all Pike data types, including complex nested structures."]})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"transparently-persistent-data-structures",children:"Transparently Persistent Data Structures"}),"\n",(0,i.jsx)(e.p,{children:"Implement transparent persistence with automatic loading and saving. Use getter/setter functions to manage persistence."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Recipe: Auto-persisting mapping\n//-----------------------------\n#pragma strict_types\n\nclass PersistentMap {\n    private mapping(string:mixed) _data = ([]);\n    private string _filename;\n    private bool _dirty = false;\n\n    void create(string filename) {\n        _filename = filename;\n        load();\n    }\n\n    void load() {\n        if (Stdio.file_size(_filename) > 0) {\n            mixed decoded = decode_value(Stdio.read_file(_filename));\n            if (mappingp(decoded)) {\n                _data = decoded;\n            }\n        }\n        _dirty = false;\n    }\n\n    void save() {\n        if (_dirty) {\n            Stdio.write_file(_filename, encode_value(_data));\n            _dirty = false;\n        }\n    }\n\n    mixed `[](string key) {\n        return _data[key];\n    }\n\n    void `[]=(string key, mixed value) {\n        _data[key] = value;\n        _dirty = true;\n    }\n\n    array(string) _indices() {\n        return indices(_data);\n    }\n\n    array(mixed) _values() {\n        return values(_data);\n    }\n\n    void destroy() {\n        save();  // Auto-save on destruction\n    }\n}\n\n// Usage\nPersistentMap store = PersistentMap("persistent.dat");\nstore["username"] = "alice";\nstore["login_count"] = 5;\nstore->save();  // Explicit save\n\n// Later session\nPersistentMap store2 = PersistentMap("persistent.dat");\nwrite("Username: %s\\n", store2["username"]);       // Output: alice\nwrite("Logins: %d\\n", store2["login_count"]);      // Output: 5\n\n// Persistent cache with TTL\nclass PersistentCache {\n    private mapping(string:mapping) _cache = ([]);\n    private string _filename;\n    private int _default_ttl = 3600;\n\n    void create(string filename, int|void default_ttl) {\n        _filename = filename;\n        if (default_ttl) {\n            _default_ttl = default_ttl;\n        }\n        load();\n    }\n\n    void set(string key, mixed value, int|void ttl) {\n        ttl = ttl || _default_ttl;\n        _cache[key] = ([\n            "value": value,\n            "expires": time() + ttl\n        ]);\n        flush();\n    }\n\n    mixed|zero get(string key) {\n        if (!_cache[key]) {\n            return UNDEFINED;\n        }\n\n        mapping entry = _cache[key];\n        if (entry["expires"] < time()) {\n            // Expired\n            m_delete(_cache, key);\n            flush();\n            return UNDEFINED;\n        }\n\n        return entry["value"];\n    }\n\n    void flush() {\n        Stdio.write_file(_filename, encode_value(_cache));\n    }\n\n    void load() {\n        if (Stdio.file_size(_filename) > 0) {\n            mixed data = decode_value(Stdio.read_file(_filename));\n            if (mappingp(data)) {\n                _cache = data;\n                // Clean expired entries\n                cleanup_expired();\n            }\n        }\n    }\n\n    void cleanup_expired() {\n        int now = time();\n        foreach (indices(_cache), string key) {\n            if (_cache[key]["expires"] < now) {\n                m_delete(_cache, key);\n            }\n        }\n        flush();\n    }\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"program-binary-search-tree",children:"Program: Binary Search Tree"}),"\n",(0,i.jsx)(e.p,{children:"Implement a binary search tree in Pike using classes and proper memory management."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-pike",children:'//-----------------------------\n// Program: Binary Search Tree with full CRUD operations\n//-----------------------------\n#pragma strict_types\n\nclass TreeNode {\n    mixed value;\n    TreeNode|zero left;\n    TreeNode|zero right;\n\n    void create(mixed v) {\n        value = v;\n        left = UNDEFINED;\n        right = UNDEFINED;\n    }\n}\n\nclass BinarySearchTree {\n    private TreeNode|zero _root = UNDEFINED;\n\n    void insert(mixed value) {\n        _root = _insert(_root, value);\n    }\n\n    private TreeNode _insert(TreeNode|zero node, mixed value) {\n        if (!node) {\n            return TreeNode(value);\n        }\n\n        if (value < node->value) {\n            node->left = _insert(node->left, value);\n        } else if (value > node->value) {\n            node->right = _insert(node->right, value);\n        }\n        // If equal, don\'t insert duplicates\n\n        return node;\n    }\n\n    bool contains(mixed value) {\n        return _contains(_root, value);\n    }\n\n    private bool _contains(TreeNode|zero node, mixed value) {\n        if (!node) {\n            return false;\n        }\n\n        if (value == node->value) {\n            return true;\n        } else if (value < node->value) {\n            return _contains(node->left, value);\n        } else {\n            return _contains(node->right, value);\n        }\n    }\n\n    array(mixed) inorder() {\n        array(mixed) result = ({});\n        _inorder(_root, result);\n        return result;\n    }\n\n    private void _inorder(TreeNode|zero node, array(mixed) result) {\n        if (node) {\n            _inorder(node->left, result);\n            result += ({node->value});\n            _inorder(node->right, result);\n        }\n    }\n\n    int get_depth() {\n        return _depth(_root);\n    }\n\n    private int _depth(TreeNode|zero node) {\n        if (!node) {\n            return 0;\n        }\n        return 1 + max(_depth(node->left), _depth(node->right));\n    }\n\n    int get_size() {\n        return _size(_root);\n    }\n\n    private int _size(TreeNode|zero node) {\n        if (!node) {\n            return 0;\n        }\n        return 1 + _size(node->left) + _size(node->right);\n    }\n\n    void pretty_print() {\n        _print(_root, 0, "Root: ");\n    }\n\n    private void _print(TreeNode|zero node, int level, string prefix) {\n        if (node) {\n            write("%s%s\\n", "  " * level + prefix, node->value);\n            _print(node->left, level + 1, "L--- ");\n            _print(node->right, level + 1, "R--- ");\n        }\n    }\n}\n\n// Usage example\nBinarySearchTree bst = BinarySearchTree();\n\narray(int) values = ({50, 30, 70, 20, 40, 60, 80});\nforeach (values, int val) {\n    bst->insert(val);\n}\n\nwrite("BST Structure:\\n");\nbst->pretty_print();\n\nwrite("\\nInorder traversal: %s\\n", bst->inorder() * ", ");\nwrite("Depth: %d\\n", bst->get_depth());\nwrite("Size: %d\\n", bst->get_size());\n\nwrite("\\nSearch tests:\\n");\nforeach (({20, 40, 60, 99}), int val) {\n    write("Contains %d: %s\\n", val, bst->contains(val) ? "yes" : "no");\n}\n\n// Serialize/deserialize BST\nstring serialize_tree(BinarySearchTree tree) {\n    return encode_value(tree->inorder());\n}\n\nBinarySearchTree deserialize_tree(string data) {\n    array(int) values = decode_value(data);\n    BinarySearchTree tree = BinarySearchTree();\n    foreach (values, int val) {\n        tree->insert(val);\n    }\n    return tree;\n}\n\n// Test serialization\nwrite("\\nSerialization test:\\n");\nstring serialized = serialize_tree(bst);\nBinarySearchTree restored = deserialize_tree(serialized);\nwrite("Restored inorder: %s\\n", restored->inorder() * ", ");\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"see-also",children:"See Also"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.a,{href:"/docs/advanced/classes",children:"Classes"})," - Object-oriented programming in Pike"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.a,{href:"/docs/advanced/modules",children:"Modules"})," - Creating reusable code modules"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.a,{href:"/docs/basics/strings",children:"Strings"})," - Text processing and manipulation"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.a,{href:"/docs/files/file-access",children:"File Access"})," - Working with files and directories"]}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(l,{...n})}):l(n)}},8453(n,e,r){r.d(e,{R:()=>s,x:()=>o});var t=r(6540);const i={},a=t.createContext(i);function s(n){const e=t.useContext(a);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:s(n.components),t.createElement(a.Provider,{value:e},n.children)}}}]);